{
  "folderName": "cli",
  "folderPath": ".autodoc/docs/json/appkit/src/main/scala/org/ergoplatform/appkit/cli",
  "url": "https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/scala/org/ergoplatform/appkit/cli",
  "files": [
    {
      "fileName": "AppContext.scala",
      "filePath": "appkit/src/main/scala/org/ergoplatform/appkit/cli/AppContext.scala",
      "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/AppContext.scala",
      "summary": "The `AppContext` class is a data class that represents the context in which a command is executed in the Ergo platform. It contains all the necessary data to parse and execute a command. The purpose of this class is to provide a convenient way to pass around the context data between different parts of the application.\n\nThe class has several properties that represent different aspects of the context. The `cliApp` property represents the CLI application that created the context. The `commandLineArgs` property contains the arguments passed to the `ErgoTool.main` method. The `console` property represents the console interface to be used during command execution. The `cmdOptions` property contains the options parsed from the command line. The `cmdName` property represents the name of the command to be executed. The `cmdArgs` property contains the arguments taken from the command line (excluding the command name). The `toolConf` property represents the tool configuration read from the file. The `clientFactory` property is a factory method used to create an `ErgoClient` instance if and when it is needed. The `cmdParameters` property represents the parsed and instantiated command parameters.\n\nThe class also has several methods that provide convenient access to different aspects of the context. The `apiUrl` method returns the URL of the Ergo node API endpoint. The `apiKey` method returns the API key used for Ergo node API authentication. The `networkType` method returns the expected network type (Mainnet or Testnet). The `isDryRun` method returns true if the `DryRunOption` is defined in the command line. The `isPrintJson` method returns true if the `PrintJsonOption` is defined in the command line. The `withCmdParameters` method is used to attach parameters to the context.\n\nOverall, the `AppContext` class provides a convenient way to pass around the context data between different parts of the application. It encapsulates all the necessary data and provides convenient methods to access and modify it. This class is an important part of the Ergo platform and is used extensively throughout the application. Here is an example of how the `AppContext` class can be used:\n\n```scala\nval appContext = AppContext(\n  cliApp = myCliApp,\n  commandLineArgs = Seq(\"--option1\", \"value1\", \"--option2\", \"value2\"),\n  console = myConsole,\n  cmdOptions = Map(\"option1\" -> \"value1\", \"option2\" -> \"value2\"),\n  cmdName = \"myCommand\",\n  cmdArgs = Seq(\"arg1\", \"arg2\"),\n  toolConf = myToolConfig,\n  clientFactory = myClientFactory\n)\n\nval apiUrl = appContext.apiUrl\nval apiKey = appContext.apiKey\nval networkType = appContext.networkType\nval isDryRun = appContext.isDryRun\nval isPrintJson = appContext.isPrintJson\n\nval newContext = appContext.withCmdParameters(Seq(\"param1\", \"param2\"))\n```",
      "questions": "1. What is the purpose of the `AppContext` class?\n- The `AppContext` class is an application execution context that contains all the data necessary to parse and execute a command.\n\n2. What are the parameters of the `AppContext` class?\n- The parameters of the `AppContext` class include the CLI application that created the context, the command line arguments passed to `ErgoTool.main`, a console interface to be used during command execution, options parsed from the command line, the command name to execute, command args taken from the command line (excluding command name), tool configuration read from the file, a factory method used to create an `ErgoClient` instance, and parsed and instantiated command parameters.\n\n3. What are some of the methods available in the `AppContext` class?\n- Some of the methods available in the `AppContext` class include `apiUrl`, which returns the URL of the Ergo node API endpoint, `apiKey`, which returns the API key used for Ergo node API authentication, `networkType`, which returns the expected network type (Mainnet or Testnet), `isDryRun`, which returns true if the `DryRunOption` is defined in the command line, and `isPrintJson`, which returns true if the `PrintJsonOption` is defined in the command line."
    },
    {
      "fileName": "CliApplication.scala",
      "filePath": "appkit/src/main/scala/org/ergoplatform/appkit/cli/CliApplication.scala",
      "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/CliApplication.scala",
      "summary": "The code represents a base class for all CLI (Command Line Interface) applications in the Appkit Commands framework. The purpose of this class is to provide a set of methods and properties that can be used by derived classes to create CLI applications. \n\nThe `CliApplication` class contains several methods that are used to parse command-line arguments, load configuration files, and execute commands. The `commands` method returns an array of `CmdDescriptor` objects that represent the commands supported by the application. The `commandsMap` method returns a map of command names to `CmdDescriptor` objects. \n\nThe `run` method is the main entry point for the application. It takes three arguments: `args`, `console`, and `clientFactory`. The `args` argument is an array of strings that represent the command-line arguments passed to the application. The `console` argument is an instance of the `Console` trait that is used to interact with the user. The `clientFactory` argument is a function that creates an instance of the `ErgoClient` class. \n\nThe `run` method does the following steps:\n1. Parses the command-line arguments using the `CmdLineParser.parseOptions` method.\n2. Loads the configuration file using the `loadConfig` method.\n3. Creates an instance of the `AppContext` class.\n4. Parses the command parameters using the `parseCmd` method.\n5. Executes the command using the `Cmd.run` method.\n\nThe `loadConfig` method loads the `ErgoToolConfig` from a file specified either by the command-line option `--conf` or from the default file location. The `parseCmd` method parses the command parameters from the command line using the `AppContext` class and returns a new instance of the command configured with the parsed parameters. \n\nThe `printUsage` method prints usage help to the console for the given command (if defined). If the command is not defined, then it prints basic usage info about all commands. \n\nIn summary, the `CliApplication` class provides a set of methods and properties that can be used by derived classes to create CLI applications. It handles parsing command-line arguments, loading configuration files, and executing commands. It also provides a set of default commands that can be overridden by derived classes.",
      "questions": "1. What is the purpose of the `CliApplication` class?\n- The `CliApplication` class is the base class for all CLI applications in the Appkit Commands framework.\n\n2. What steps does the `run` method perform?\n- The `run` method performs the following steps: \n  1. Parse options from the command line.\n  2. Load the config file.\n  3. Create an `AppContext`.\n  4. Parse command parameters.\n  5. Create and execute the command.\n\n3. What is the purpose of the `printUsage` method?\n- The `printUsage` method prints usage help to the console for a given command (if defined) or basic usage info about all commands if the command is not defined."
    },
    {
      "fileName": "CmdLineParser.scala",
      "filePath": "appkit/src/main/scala/org/ergoplatform/appkit/cli/CmdLineParser.scala",
      "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/CmdLineParser.scala",
      "summary": "# `CmdLineParser` in `ergo-appkit`\n\n`CmdLineParser` is a Scala object that provides a method to parse command line arguments and extract options and parameters. It also provides a method to parse the network type from a string.\n\n## `parseOptions`\n\n`parseOptions` takes a sequence of strings as input, which represents the command line arguments. It returns a tuple of two values: a map of options and their values, and a sequence of parameters.\n\nThe method first creates an empty map to store the options and their values. It then creates a mutable buffer and copies the input sequence into it. This buffer is used to extract options and parameters.\n\nThe method then iterates over the buffer and checks if each argument starts with the `CmdOption.Prefix` string, which is `\"--\"`. If an argument starts with this prefix, it is considered an option. The method then looks up the option in the `CmdOption.options` list, which is a list of predefined options. If the option is found, the method checks if it is a flag or not. If it is a flag, the value is set to `\"true\"`. If it is not a flag, the method checks if there is a value for the option in the next argument. If there is no value, an error is thrown. If there is a value, it is added to the map of options, and the value is removed from the buffer.\n\nIf an argument does not start with the `CmdOption.Prefix` string, it is considered a parameter and is left in the buffer.\n\nThe method returns the map of options and their values, and the remaining parameters in the buffer.\n\n## `parseNetwork`\n\n`parseNetwork` takes a string as input, which represents the network type. It returns a `NetworkType` object, which is an enumeration that represents the network type.\n\nThe method checks if the input string is `\"testnet\"` or `\"mainnet\"`. If it is, it returns the corresponding `NetworkType` object. If it is not, an error is thrown.\n\n## Usage\n\n`CmdLineParser` can be used to parse command line arguments in a Scala application. For example, the following code shows how to use `parseOptions` to parse command line arguments and print the options and parameters:\n\n```scala\nobject MyApp {\n  def main(args: Array[String]): Unit = {\n    val (options, params) = CmdLineParser.parseOptions(args)\n    println(\"Options:\")\n    options.foreach { case (name, value) =>\n      println(s\"$name=$value\")\n    }\n    println(\"Parameters:\")\n    params.foreach { param =>\n      println(param)\n    }\n  }\n}\n```\n\nIf the application is run with the following command line arguments:\n\n```\n--conf myconf.json --verbose param1 param2\n```\n\nThe output will be:\n\n```\nOptions:\nconf=myconf.json\nverbose=true\nParameters:\nparam1\nparam2\n```",
      "questions": "1. What is the purpose of this code?\n    \n    This code defines a command line parser for extracting options and parameters from the command line arguments passed to the Ergo Appkit CLI.\n\n2. What is the format of the options that can be passed to this command line parser?\n    \n    The options that can be passed to this command line parser start with `--` and are parsed into name-value pairs. Any option with `CmdOption.isFlag == true` is parsed without a value.\n\n3. What is the purpose of the `parseNetwork` method?\n    \n    The `parseNetwork` method takes a string argument representing the network type and returns the corresponding `NetworkType` enum value. If the input string is not a valid network type, it raises a `usageError`."
    },
    {
      "fileName": "Console.scala",
      "filePath": "appkit/src/main/scala/org/ergoplatform/appkit/cli/Console.scala",
      "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/Console.scala",
      "summary": "The `Console` class is an abstract interface for console interactions, such as print and read operations. It defines methods for printing a string to the output stream, reading a line from the input stream, and reading a password. The `Console` class is implemented by two concrete classes: `MainConsole` and `TestConsole`.\n\nThe `MainConsole` class is a wrapper around the system console and is intended to be used in the `Application.main` method. It provides implementations for the methods defined in the `Console` class using the `System.console()` method to access the system console.\n\nThe `TestConsole` class is a console implementation intended to be used in tests. It takes a `BufferedReader` and a `PrintStream` as input and provides implementations for the methods defined in the `Console` class using these input and output streams.\n\nThe `Console` object provides utility methods for reading a new password from the console. The `readNewPassword` method takes a number of attempts and a `Console` instance as input, along with a code block that requests the user to enter a new password twice. It then compares the two passwords and returns the password as a `SecretString` if they match. If they do not match, it prompts the user to try again up to the specified number of attempts. If the user fails to enter a valid password within the specified number of attempts, it throws a `UsageException`.\n\nThe `Console` object also provides a convenience method `readNewPassword` that takes two prompts as input and uses the `Console` instance from the `AppContext` to read the passwords.\n\nThe `ConsoleException` class is an exception thrown by the `Console` class when incorrect usage is detected.\n\nOverall, the `Console` class and its implementations provide a way to interact with the console in a standardized way, making it easier to write and test console-based applications. The `readNewPassword` method is a useful utility for securely reading passwords from the console.",
      "questions": "1. What is the purpose of the `Console` abstract class?\n- The `Console` abstract class defines an interface for console interactions, including print and read operations.\n\n2. What is the purpose of the `readNewPassword` method in the `Console` object?\n- The `readNewPassword` method in the `Console` object provides a secure way to double-enter a new password, allowing the user multiple attempts before failing with an exception.\n\n3. What is the purpose of the `TestConsole` class?\n- The `TestConsole` class is a console implementation to be used in tests, providing methods for printing and reading input/output streams."
    },
    {
      "fileName": "HelpCmd.scala",
      "filePath": "appkit/src/main/scala/org/ergoplatform/appkit/cli/HelpCmd.scala",
      "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/HelpCmd.scala",
      "summary": "The code provided is a part of the ergo-appkit project and is located in the ergotool package. The purpose of this code is to provide a Help command that can be used to print usage help for a given command name. The Help command is implemented as a case class called HelpCmd, which takes three parameters: toolConf, name, and askedCmd. The toolConf parameter is an instance of ErgoToolConfig, which is used to configure the ErgoTool application. The name parameter is the name of the Help command, which is \"help\". The askedCmd parameter is the name of the command for which usage help should be printed.\n\nThe HelpCmd case class implements the run method, which takes an instance of AppContext as a parameter. The AppContext class provides access to the ErgoTool application context, which includes the list of available commands. The HelpCmd case class uses the commandsMap property of the AppContext class to look up the command with the given name. If the command is found, the printUsage method of the command is called to print the usage help. If the command is not found, an error message is printed.\n\nThe HelpCmd object provides a descriptor and parser for the Help command. The descriptor is an instance of the CmdDescriptor class, which provides information about the command, such as its name, syntax, and description. The parser is implemented as the createCmd method, which takes an instance of AppContext as a parameter and returns an instance of the HelpCmd case class. The createCmd method uses the cmdParameters property of the AppContext class to get the name of the command for which usage help should be printed.\n\nOverall, this code provides a useful Help command that can be used to get usage help for any command in the ErgoTool application. For example, to get usage help for the \"send\" command, the user can run the following command:\n\n```\nergotool help send\n```\n\nThis will print the usage help for the \"send\" command.",
      "questions": "1. What is the purpose of this code?\n- This code defines a HelpCmd class and a HelpCmd object that provide usage help for a given command name in the ergo-appkit project.\n\n2. What dependencies are required for this code to work?\n- This code requires dependencies from the org.ergoplatform.appkit.cli and org.ergoplatform.appkit.commands packages.\n\n3. How is the usage help printed for a given command name?\n- The run method of the HelpCmd class checks if the given command name exists in the commandsMap of the AppContext object and prints its usage help if it exists. Otherwise, it throws a CmdException with an error message."
    },
    {
      "fileName": "Options.scala",
      "filePath": "appkit/src/main/scala/org/ergoplatform/appkit/cli/Options.scala",
      "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/Options.scala",
      "summary": "The code defines a set of classes and objects that represent command-line interface (CLI) options for the Ergo blockchain platform. The `CmdOption` class represents a single option that can be passed to a command-line tool. Each option has a name, a type, a description, and a flag indicating whether it is a boolean option (i.e., it does not have an associated value). The `ConfigOption`, `DryRunOption`, `PrintJsonOption`, and `LimitListOption` objects are instances of `CmdOption` that represent specific options that can be passed to the Ergo CLI tool.\n\nThe `CmdOption` class has two methods: `cmdText` and `helpString`. The `cmdText` method returns the text of the command line with the name of the option, while the `helpString` method returns a string that is printed for this option in the usage help output.\n\nThe `ConfigOption` object represents an option that specifies the path to a configuration file. The file has JSON content corresponding to the `ErgoToolConfig` class. The `DryRunOption` object represents an option that forces the command to report what will be done by the operation without performing the actual operation. This is useful for commands that perform some real-world effects such as sending a transaction to the blockchain. The `PrintJsonOption` object represents an option that forces commands to print objects as formatted JSON instead of rows in a table. The `LimitListOption` object represents an option that specifies a number of items in the output list.\n\nThe `CmdOption` class and its subclasses are used in the Ergo CLI tool to provide a flexible and extensible way to specify options for commands. For example, the `SendCmd` command might use the `DryRunOption` to allow users to preview the effects of sending a transaction before actually sending it. The `CmdOption` class and its subclasses can be used in other projects that require a CLI tool with extensible options. \n\nExample usage:\n\n```\n$ ergo-cli --conf ergo_tool.json --dry-run\n```\n\nThis command runs the Ergo CLI tool with the `ConfigOption` and `DryRunOption` options. The `--conf` option specifies the path to a configuration file, and the `--dry-run` option forces the command to report what will be done by the operation without performing the actual operation.",
      "questions": "1. What is the purpose of the `CmdOption` class?\n- The `CmdOption` class represents a CLI option description that can be used in command line to specify parameters to be used by the command during its operation.\n\n2. What is the difference between a regular option and a flag option?\n- A regular option is given using the syntax `--optionName optionValue`, while a flag option is given using the syntax `--optionName` without an `optionValue` part. If a `CmdOption` instance has `isFlag` set to `true`, then such option doesn't have an `optionValue` part and the option is interpreted as Boolean value (`true` if it is present, `false` otherwise).\n\n3. What are some examples of options supported by the `ergo-appkit` application?\n- Some examples of options supported by the `ergo-appkit` application are `ConfigOption` (string option to specify path to a configuration file), `DryRunOption` (flag option to prevent the command to perform actual operation and instead forces it to report planned actions), `PrintJsonOption` (flag option to force commands to print objects as formatted json instead of rows in table), and `LimitListOption` (specifies a number of items in the output list)."
    },
    {
      "fileName": "Utils.scala",
      "filePath": "appkit/src/main/scala/org/ergoplatform/appkit/cli/Utils.scala",
      "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/Utils.scala",
      "summary": "# `Utils` Object in `ergo-appkit`\n\nThe `Utils` object in the `ergo-appkit` project is a collection of utility methods that can be used throughout the project. The purpose of this object is to provide a set of common functions that can be used by other parts of the project to simplify code and reduce duplication.\n\nThe `loggedStep` method is one of the utility methods provided by the `Utils` object. This method takes three parameters: a message to print to the console, a `Console` object to use for printing, and a block of code to execute. The method prints the message to the console, executes the block of code, and then prints the status of the step (either \"Ok\" or \"Error\") to the console.\n\nHere is an example of how the `loggedStep` method might be used in the larger project:\n\n```scala\nimport org.ergoplatform.appkit.cli.Utils\n\nval console = new Console // create a new Console object\nval result = Utils.loggedStep(\"Performing step 1\", console) {\n  // code to execute for step 1\n}\n```\n\nIn this example, the `loggedStep` method is used to execute a block of code and print a message to the console. The result of the block of code is stored in the `result` variable.\n\nOverall, the `Utils` object provides a set of common utility methods that can be used throughout the `ergo-appkit` project to simplify code and reduce duplication. The `loggedStep` method is just one example of the many useful functions provided by this object.",
      "questions": "1. What is the purpose of the `Utils` object?\n   - The `Utils` object contains utility methods.\n2. What does the `loggedStep` method do?\n   - The `loggedStep` method prints a step description to the console, performs the step, and then finishes the description with the step status.\n3. What is the input and output of the `loggedStep` method?\n   - The input of the `loggedStep` method is a message string and a console object, and the output is the result of the step."
    }
  ],
  "folders": [],
  "summary": "The `.autodoc/docs/json/appkit/src/main/scala/org/ergoplatform/appkit/cli` folder contains several Scala files that are part of the Ergo platform's command-line interface (CLI) tools. These files provide a framework for creating CLI applications, parsing command-line arguments, handling console interactions, and defining CLI options.\n\n`AppContext.scala` defines a data class that represents the context in which a command is executed. It encapsulates all the necessary data and provides convenient methods to access and modify it. This class is used extensively throughout the application to pass around the context data between different parts of the application.\n\n`CliApplication.scala` provides a base class for all CLI applications in the Appkit Commands framework. It handles parsing command-line arguments, loading configuration files, and executing commands. Derived classes can use the methods and properties provided by this class to create CLI applications.\n\n`CmdLineParser.scala` is a Scala object that provides methods to parse command line arguments and extract options and parameters. It can be used to parse command line arguments in a Scala application, making it easier to handle user input.\n\n`Console.scala` is an abstract interface for console interactions, such as print and read operations. It has two concrete implementations: `MainConsole` for the system console and `TestConsole` for testing purposes. The `Console` object also provides utility methods for securely reading passwords from the console.\n\n`HelpCmd.scala` provides a Help command that can be used to print usage help for a given command name. It is a useful addition to any CLI application, allowing users to get help on how to use specific commands.\n\n`Options.scala` defines a set of classes and objects that represent CLI options for the Ergo blockchain platform. The `CmdOption` class and its subclasses can be used in other projects that require a CLI tool with extensible options.\n\n`Utils.scala` is a collection of utility methods that can be used throughout the project. One example is the `loggedStep` method, which can be used to execute a block of code and print a message to the console.\n\nHere's an example of how these classes might be used together:\n\n```scala\nimport org.ergoplatform.appkit.cli._\n\nobject MyApp extends CliApplication {\n  def main(args: Array[String]): Unit = {\n    val console = new MainConsole\n    val clientFactory = () => new ErgoClient(...)\n    run(args, console, clientFactory)\n  }\n\n  override def commands: Array[CmdDescriptor] = Array(\n    HelpCmd.descriptor,\n    // other command descriptors\n  )\n}\n```\n\nIn this example, a new CLI application is created by extending the `CliApplication` class. The `main` method initializes a `MainConsole` instance, a `clientFactory`, and calls the `run` method with the command-line arguments. The `commands` method is overridden to include the `HelpCmd` descriptor and other command descriptors.",
  "questions": ""
}