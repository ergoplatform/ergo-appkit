{
  "folderName": "appkit",
  "folderPath": ".autodoc/docs/json/appkit",
  "url": "https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit",
  "files": [],
  "folders": [
    {
      "folderName": "src",
      "folderPath": ".autodoc/docs/json/appkit/src",
      "url": "https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src",
      "files": [],
      "folders": [
        {
          "folderName": "main",
          "folderPath": ".autodoc/docs/json/appkit/src/main",
          "url": "https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main",
          "files": [],
          "folders": [
            {
              "folderName": "java",
              "folderPath": ".autodoc/docs/json/appkit/src/main/java",
              "url": "https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/java",
              "files": [],
              "folders": [
                {
                  "folderName": "org",
                  "folderPath": ".autodoc/docs/json/appkit/src/main/java/org",
                  "url": "https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/java/org",
                  "files": [],
                  "folders": [
                    {
                      "folderName": "ergoplatform",
                      "folderPath": ".autodoc/docs/json/appkit/src/main/java/org/ergoplatform",
                      "url": "https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/java/org/ergoplatform",
                      "files": [],
                      "folders": [
                        {
                          "folderName": "appkit",
                          "folderPath": ".autodoc/docs/json/appkit/src/main/java/org/ergoplatform/appkit",
                          "url": "https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/java/org/ergoplatform/appkit",
                          "files": [
                            {
                              "fileName": "RestApiErgoClient.java",
                              "filePath": "appkit/src/main/java/org/ergoplatform/appkit/RestApiErgoClient.java",
                              "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/java/org/ergoplatform/appkit/RestApiErgoClient.java",
                              "summary": "The `RestApiErgoClient` class is an implementation of the `ErgoClient` interface that uses the REST API of an Ergo node for communication. It provides methods for creating instances of the `ErgoClient` interface that are connected to a given node of the Ergo network, with or without an explorer connection.\n\nThe `RestApiErgoClient` constructor takes in the following parameters:\n- `nodeUrl`: the http url to the Ergo node REST API endpoint\n- `networkType`: the type of network (mainnet, testnet) the Ergo node is part of\n- `apiKey`: the api key to authenticate the client\n- `explorerUrl`: an optional http url to the Ergo Explorer REST API endpoint. If null or empty, the client works in the `node only` mode.\n- `httpClientBuilder`: an optional builder used to construct http client instances. If null, a new `OkHttpClient` with default parameters is used.\n\nThe `execute` method takes in a `Function` that operates on a `BlockchainContext` and returns a result of type `T`. It creates a `BlockchainContext` using a `BlockchainContextBuilderImpl` instance that takes in the `NodeAndExplorerDataSourceImpl` instance created by the constructor and the `networkType`. It then applies the given `Function` to the `BlockchainContext` and returns the result.\n\nThe `RestApiErgoClient` class also provides several static factory methods for creating instances of the `ErgoClient` interface:\n- `createWithoutExplorer`: creates a new instance of `ErgoClient` in the `node-only` mode, i.e. connected to a given node of the given network type and not connected to explorer.\n- `create`: creates a new instance of `ErgoClient` connected to a given node of the given network type.\n- `createWithHttpClientBuilder`: creates a new instance of `ErgoClient` connected to a given node of the given network type, with an optional `httpClientBuilder`.\n- `create`: creates a new instance of `ErgoClient` using node configuration parameters and an optional explorerUrl.\n- `createWithHttpClientBuilder`: creates a new instance of `ErgoClient` using node configuration parameters, an optional explorerUrl, and an optional `httpClientBuilder`.\n\nThe `RestApiErgoClient` class also provides a `getDataSource` method that returns the `NodeAndExplorerDataSourceImpl` instance created by the constructor.\n\nOverall, the `RestApiErgoClient` class provides a convenient way to create instances of the `ErgoClient` interface that are connected to a given node of the Ergo network, with or without an explorer connection. It abstracts away the details of creating and configuring the necessary API clients and provides a simple interface for executing operations on the Ergo blockchain.",
                              "questions": "1. What is the purpose of this code?\n- This code provides an implementation of the ErgoClient interface that uses the REST API of an Ergo node for communication.\n\n2. What are the parameters required to create a new instance of RestApiErgoClient?\n- To create a new instance of RestApiErgoClient, you need to provide the http url to the Ergo node REST API endpoint, the type of network the Ergo node is part of, an api key to authenticate the client, and an optional http url to the Ergo Explorer REST API endpoint.\n\n3. What is the purpose of the execute method in RestApiErgoClient?\n- The execute method in RestApiErgoClient takes a function that operates on a BlockchainContext and returns a result of type T. It creates a new BlockchainContext using the NodeAndExplorerDataSourceImpl and the network type, and applies the function to this context to obtain the result."
                            }
                          ],
                          "folders": [
                            {
                              "folderName": "config",
                              "folderPath": ".autodoc/docs/json/appkit/src/main/java/org/ergoplatform/appkit/config",
                              "url": "https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/java/org/ergoplatform/appkit/config",
                              "files": [
                                {
                                  "fileName": "ApiConfig.java",
                                  "filePath": "appkit/src/main/java/org/ergoplatform/appkit/config/ApiConfig.java",
                                  "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/java/org/ergoplatform/appkit/config/ApiConfig.java",
                                  "summary": "The `ApiConfig` class in the `org.ergoplatform.appkit.config` package is responsible for storing the connection parameters for the Ergo node API. It has two private instance variables, `apiUrl` and `apiKey`, which are accessed through public getter methods.\n\nThe `getApiUrl()` method returns the URL of the Ergo node API endpoint. This URL is used to connect to the Ergo node and send requests to it. An example usage of this method would be to retrieve the current block height of the Ergo blockchain:\n\n```java\nApiConfig apiConfig = new ApiConfig();\napiConfig.setApiUrl(\"http://localhost:9052\");\nErgoClient ergoClient = RestApiErgoClient.create(apiConfig);\nint currentHeight = ergoClient.execute(ctx -> ctx.getHeaders().getHeight());\n```\n\nIn this example, an instance of `ApiConfig` is created and its `apiUrl` variable is set to the URL of the Ergo node API endpoint. An `ErgoClient` is then created using the `RestApiErgoClient.create()` method, which takes an instance of `ApiConfig` as an argument. Finally, the `execute()` method is called on the `ErgoClient` instance to retrieve the current block height of the Ergo blockchain.\n\nThe `getApiKey()` method returns the API key used for authentication with the Ergo node API. This key is a secret key whose hash was used in the Ergo node configuration. An example usage of this method would be to authenticate with the Ergo node API:\n\n```java\nApiConfig apiConfig = new ApiConfig();\napiConfig.setApiUrl(\"http://localhost:9052\");\napiConfig.setApiKey(\"mySecretApiKey\");\nErgoClient ergoClient = RestApiErgoClient.create(apiConfig);\nergoClient.execute(ctx -> ctx.getBoxesUnspent());\n```\n\nIn this example, an instance of `ApiConfig` is created and its `apiUrl` and `apiKey` variables are set to the URL of the Ergo node API endpoint and the secret API key, respectively. An `ErgoClient` is then created using the `RestApiErgoClient.create()` method, which takes an instance of `ApiConfig` as an argument. Finally, the `execute()` method is called on the `ErgoClient` instance to retrieve the unspent boxes on the Ergo blockchain, using the authenticated API key.",
                                  "questions": "1. What is the purpose of this class?\n   This class defines the connection parameters for the Ergo node API, including the API URL and API key for authentication.\n\n2. How are the API URL and API key set?\n   The values for the API URL and API key are set through the private instance variables `apiUrl` and `apiKey`, respectively.\n\n3. Can the API URL and API key be modified?\n   It is not clear from this code whether the API URL and API key can be modified after they are initially set. The class only provides getter methods for these values, indicating that they may be read-only."
                                },
                                {
                                  "fileName": "ErgoNodeConfig.java",
                                  "filePath": "appkit/src/main/java/org/ergoplatform/appkit/config/ErgoNodeConfig.java",
                                  "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/java/org/ergoplatform/appkit/config/ErgoNodeConfig.java",
                                  "summary": "The `ErgoNodeConfig` class is a part of the `ergo-appkit` project and is used to define the parameters of an Ergo node that will be used by the `ErgoClient`. The `ErgoClient` is a Java library that provides a high-level API for interacting with the Ergo blockchain. \n\nThe `ErgoNodeConfig` class has three private fields: `nodeApi`, `wallet`, and `networkType`. The `nodeApi` field is an instance of the `ApiConfig` class, which defines the connection parameters for the Ergo node's API. The `wallet` field is an instance of the `WalletConfig` class, which defines the parameters for working with the wallet. The `networkType` field is an instance of the `NetworkType` enum, which specifies the expected network type (Mainnet or Testnet).\n\nThe class has three public methods: `getNodeApi()`, `getWallet()`, and `getNetworkType()`. These methods return the values of the corresponding private fields. \n\nThis class can be used to configure an instance of the `ErgoClient` class. For example, to create an instance of the `ErgoClient` that connects to the Testnet Ergo node with the specified API and wallet configurations, the following code can be used:\n\n```\nApiConfig apiConfig = new ApiConfig(\"http://localhost:9053\");\nWalletConfig walletConfig = new WalletConfig(\"testnet\", \"password\");\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(apiConfig, walletConfig, NetworkType.TESTNET);\nErgoClient client = ErgoClient.create(nodeConfig);\n```\n\nIn this example, the `ApiConfig` and `WalletConfig` instances are created with the necessary parameters, and then an instance of the `ErgoNodeConfig` class is created with these instances and the `NetworkType.TESTNET` enum value. Finally, an instance of the `ErgoClient` class is created with the `ErgoNodeConfig` instance. \n\nOverall, the `ErgoNodeConfig` class is an important part of the `ergo-appkit` project that allows developers to configure an instance of the `ErgoClient` class with the necessary parameters to interact with the Ergo blockchain.",
                                  "questions": "1. What is the purpose of this code?\n- This code defines a class called `ErgoNodeConfig` that contains parameters for connecting to an Ergo node and working with its wallet.\n\n2. What other classes or files does this code interact with?\n- This code imports the `org.ergoplatform.appkit.NetworkType` class and uses it as a parameter type for the `networkType` field.\n\n3. How can this code be used in a larger project?\n- This code can be used to configure and connect to an Ergo node in a Java-based project that interacts with the Ergo blockchain. Other classes in the `org.ergoplatform.appkit` package may also be used in conjunction with this class."
                                },
                                {
                                  "fileName": "ErgoToolConfig.java",
                                  "filePath": "appkit/src/main/java/org/ergoplatform/appkit/config/ErgoToolConfig.java",
                                  "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/java/org/ergoplatform/appkit/config/ErgoToolConfig.java",
                                  "summary": "The `ErgoToolConfig` class is responsible for managing the configuration parameters of the ErgoTool utility. It contains two fields: `node` and `parameters`, which represent the configuration of the Ergo node and the tool parameters, respectively. \n\nThe `getNode()` method returns the `ErgoNodeConfig` object, which contains the configuration parameters of the Ergo node. \n\nThe `getParameters()` method returns a `ToolParameters` object, which is a HashMap of name-value pairs representing the tool parameters. \n\nThe class provides three methods for loading the configuration from a file: `load(Reader reader)`, `load(File file)`, and `load(String fileName)`. The `load(Reader reader)` method takes a `Reader` object as input and returns an `ErgoToolConfig` object created from the file content. The `load(File file)` method takes a `File` object as input and returns an `ErgoToolConfig` object created from the file content. The `load(String fileName)` method takes a `String` object as input, which is the name of the file relative to the current directory. It then resolves the file using `File#getAbsolutePath()` and returns an `ErgoToolConfig` object created from the file content. \n\nThis class can be used in the larger project to manage the configuration parameters of the ErgoTool utility. Developers can use the `load()` methods to load the configuration from a file and then access the configuration parameters using the `getNode()` and `getParameters()` methods. For example, the following code loads the configuration from a file named `config.json` and then gets the node configuration:\n\n```\nErgoToolConfig config = ErgoToolConfig.load(\"config.json\");\nErgoNodeConfig nodeConfig = config.getNode();\n```",
                                  "questions": "1. What is the purpose of the `ErgoToolConfig` class?\n    \n    The `ErgoToolConfig` class is responsible for holding configuration parameters for the ErgoTool utility.\n\n2. What is the purpose of the `load` methods?\n    \n    The `load` methods are used to load configuration data from a file or reader and create an instance of `ErgoToolConfig` with the file content.\n\n3. What is the purpose of the `ToolParameters` class?\n    \n    The `ToolParameters` class represents a section of the configuration with named parameters in the form of a HashMap of Name-Value pairs."
                                },
                                {
                                  "fileName": "ToolParameters.java",
                                  "filePath": "appkit/src/main/java/org/ergoplatform/appkit/config/ToolParameters.java",
                                  "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/java/org/ergoplatform/appkit/config/ToolParameters.java",
                                  "summary": "The `ToolParameters` class is a subclass of the `HashMap` class and is used to store key-value pairs of tool parameters. This class overrides the `equals`, `hashCode`, and `toString` methods of the `HashMap` class to provide custom implementations.\n\nThe `equals` method checks if the given object is equal to the current object by comparing their classes and calling the `equals` method of the superclass.\n\nThe `hashCode` method returns the hash code of the superclass.\n\nThe `toString` method returns a string representation of the object by calling the `toIndentedString` method and appending it to a string builder.\n\nThe `toIndentedString` method is a private helper method that converts the given object to a string with each line indented by 4 spaces (except the first line).\n\nThis class can be used to store tool parameters in a key-value format and to compare them with other instances of the `ToolParameters` class. For example, if we have two instances of `ToolParameters` called `params1` and `params2`, we can compare them using the `equals` method like this:\n\n```\nif (params1.equals(params2)) {\n    // do something\n}\n```\n\nWe can also print the contents of a `ToolParameters` object using the `toString` method like this:\n\n```\nToolParameters params = new ToolParameters();\nparams.put(\"param1\", \"value1\");\nparams.put(\"param2\", \"value2\");\nSystem.out.println(params.toString());\n```\n\nThis will output:\n\n```\nclass Parameters {\n    {param1=value1, param2=value2}\n}\n```\n\nOverall, the `ToolParameters` class provides a convenient way to store and compare tool parameters in a key-value format.",
                                  "questions": "1. What is the purpose of the `ToolParameters` class?\n    \n    The `ToolParameters` class extends `HashMap<String, String>` and provides methods for overriding `equals`, `hashCode`, and `toString` methods.\n\n2. Why does the `equals` method check if the object is of the same class?\n    \n    The `equals` method checks if the object is of the same class to ensure that the comparison is only done between objects of the same type.\n\n3. What is the purpose of the `toIndentedString` method?\n    \n    The `toIndentedString` method is a private helper method that converts an object to a string with each line indented by 4 spaces, except the first line. It is used by the `toString` method to format the output."
                                },
                                {
                                  "fileName": "WalletConfig.java",
                                  "filePath": "appkit/src/main/java/org/ergoplatform/appkit/config/WalletConfig.java",
                                  "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/java/org/ergoplatform/appkit/config/WalletConfig.java",
                                  "summary": "The `WalletConfig` class is a part of the `ergo-appkit` project and provides parameters for working with a wallet. The purpose of this class is to store the mnemonic, password, and mnemonic password used for generating keys in the wallet. \n\nThe `getMnemonic()` method returns the mnemonic used for generating keys in the wallet. It is important that this value is the same as the one used by the wallet of the node specified in `ErgoNodeConfig#getNodeApi()`. This ensures that the keys generated by the wallet are compatible with the node's wallet.\n\nThe `getPassword()` method returns the password used by the Ergo node wallet to protect wallet data. An empty or null string value means that no password is set.\n\nThe `getMnemonicPassword()` method returns the password used to protect the mnemonic. By default, this value is the same as the `password` value returned by the `getPassword()` method. \n\nThis class can be used in the larger project to configure the wallet used by the Ergo node. For example, a developer could create an instance of the `WalletConfig` class and set the mnemonic, password, and mnemonic password values to match the values used by the node's wallet. This instance could then be passed to other classes or methods that require access to the wallet configuration. \n\nHere is an example of how the `WalletConfig` class could be used in the larger project:\n\n```\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(...);\nWalletConfig walletConfig = new WalletConfig();\nwalletConfig.setMnemonic(\"example mnemonic\");\nwalletConfig.setPassword(\"example password\");\nwalletConfig.setMnemonicPassword(\"example mnemonic password\");\nnodeConfig.setWalletConfig(walletConfig);\n```\n\nIn this example, an instance of the `ErgoNodeConfig` class is created with some unspecified parameters. An instance of the `WalletConfig` class is also created and its mnemonic, password, and mnemonic password values are set. Finally, the `WalletConfig` instance is passed to the `setWalletConfig()` method of the `ErgoNodeConfig` instance, which configures the node's wallet with the specified values.",
                                  "questions": "1. What is the purpose of this class?\n   - This class contains parameters for working with a wallet in the Ergo platform.\n2. What are the three private variables declared in this class?\n   - The three private variables declared in this class are `mnemonic`, `password`, and `mnemonicPassword`.\n3. What is the difference between `password` and `mnemonicPassword`?\n   - `password` is used to protect wallet data, while `mnemonicPassword` is used to protect the mnemonic (which is used for generation of keys in the wallet). By default, `mnemonicPassword` is the same as `password`."
                                }
                              ],
                              "folders": [],
                              "summary": "The `org.ergoplatform.appkit.config` package contains classes responsible for managing the configuration of the Ergo node, wallet, and tool parameters. These classes are essential for setting up and interacting with the Ergo blockchain using the `ErgoClient` class.\n\n`ApiConfig.java` stores the connection parameters for the Ergo node API, including the API URL and the API key. This class is used to configure the `ErgoClient` for connecting to the Ergo node and sending requests. For example, to retrieve the current block height of the Ergo blockchain:\n\n```java\nApiConfig apiConfig = new ApiConfig();\napiConfig.setApiUrl(\"http://localhost:9052\");\nErgoClient ergoClient = RestApiErgoClient.create(apiConfig);\nint currentHeight = ergoClient.execute(ctx -> ctx.getHeaders().getHeight());\n```\n\n`ErgoNodeConfig.java` defines the parameters of an Ergo node, including the API configuration, wallet configuration, and network type (Mainnet or Testnet). This class is used to configure an instance of the `ErgoClient` class. For example, to create an `ErgoClient` that connects to a Testnet Ergo node:\n\n```java\nApiConfig apiConfig = new ApiConfig(\"http://localhost:9053\");\nWalletConfig walletConfig = new WalletConfig(\"testnet\", \"password\");\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(apiConfig, walletConfig, NetworkType.TESTNET);\nErgoClient client = ErgoClient.create(nodeConfig);\n```\n\n`ErgoToolConfig.java` manages the configuration parameters of the ErgoTool utility, including the Ergo node configuration and tool parameters. This class provides methods for loading the configuration from a file and accessing the configuration parameters. For example, to load the configuration from a file and get the node configuration:\n\n```java\nErgoToolConfig config = ErgoToolConfig.load(\"config.json\");\nErgoNodeConfig nodeConfig = config.getNode();\n```\n\n`ToolParameters.java` is a subclass of `HashMap` used to store key-value pairs of tool parameters. This class provides methods for storing, comparing, and printing tool parameters. For example, to compare two instances of `ToolParameters`:\n\n```java\nif (params1.equals(params2)) {\n    // do something\n}\n```\n\n`WalletConfig.java` provides parameters for working with a wallet, including the mnemonic, password, and mnemonic password used for generating keys. This class is used to configure the wallet used by the Ergo node. For example, to set the wallet configuration for an `ErgoNodeConfig` instance:\n\n```java\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(...);\nWalletConfig walletConfig = new WalletConfig();\nwalletConfig.setMnemonic(\"example mnemonic\");\nwalletConfig.setPassword(\"example password\");\nwalletConfig.setMnemonicPassword(\"example mnemonic password\");\nnodeConfig.setWalletConfig(walletConfig);\n```\n\nIn summary, the classes in the `org.ergoplatform.appkit.config` package are essential for configuring and interacting with the Ergo blockchain using the `ErgoClient` class. They provide a convenient way to manage the configuration of the Ergo node, wallet, and tool parameters.",
                              "questions": ""
                            }
                          ],
                          "summary": "The `RestApiErgoClient` class in the `org.ergoplatform.appkit` package is an implementation of the `ErgoClient` interface that uses the REST API of an Ergo node for communication. It provides a convenient way to create instances of the `ErgoClient` interface that are connected to a given node of the Ergo network, with or without an explorer connection. This class abstracts away the details of creating and configuring the necessary API clients and provides a simple interface for executing operations on the Ergo blockchain.\n\nFor example, to create an instance of `ErgoClient` connected to a Testnet Ergo node:\n\n```java\nApiConfig apiConfig = new ApiConfig(\"http://localhost:9053\");\nWalletConfig walletConfig = new WalletConfig(\"testnet\", \"password\");\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(apiConfig, walletConfig, NetworkType.TESTNET);\nErgoClient client = RestApiErgoClient.create(nodeConfig);\n```\n\nThe `RestApiErgoClient` class also provides several static factory methods for creating instances of the `ErgoClient` interface, such as `createWithoutExplorer`, `create`, and `createWithHttpClientBuilder`. These methods allow developers to create `ErgoClient` instances with different configurations, such as connecting to a node without an explorer connection or using a custom HTTP client builder.\n\nThe `execute` method in the `RestApiErgoClient` class takes in a `Function` that operates on a `BlockchainContext` and returns a result of type `T`. This method is used to perform operations on the Ergo blockchain, such as retrieving the current block height:\n\n```java\nint currentHeight = ergoClient.execute(ctx -> ctx.getHeaders().getHeight());\n```\n\nThe `org.ergoplatform.appkit.config` package contains classes responsible for managing the configuration of the Ergo node, wallet, and tool parameters. These classes are essential for setting up and interacting with the Ergo blockchain using the `ErgoClient` class. For example, the `ApiConfig` class stores the connection parameters for the Ergo node API, while the `ErgoNodeConfig` class defines the parameters of an Ergo node, including the API configuration, wallet configuration, and network type.\n\nIn summary, the `RestApiErgoClient` class and the classes in the `org.ergoplatform.appkit.config` package provide a convenient way to create instances of the `ErgoClient` interface and manage the configuration of the Ergo node, wallet, and tool parameters. They enable developers to easily interact with the Ergo blockchain and perform various operations, such as retrieving the current block height or sending transactions.",
                          "questions": ""
                        }
                      ],
                      "summary": "The `RestApiErgoClient` class in the `org.ergoplatform.appkit` package is a crucial component of the ergo-appkit project, as it provides an implementation of the `ErgoClient` interface that communicates with an Ergo node using its REST API. This class simplifies the process of creating and configuring instances of the `ErgoClient` interface, allowing developers to easily interact with the Ergo blockchain and perform various operations.\n\nFor instance, to create an `ErgoClient` instance connected to a Testnet Ergo node, you can use the following code snippet:\n\n```java\nApiConfig apiConfig = new ApiConfig(\"http://localhost:9053\");\nWalletConfig walletConfig = new WalletConfig(\"testnet\", \"password\");\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(apiConfig, walletConfig, NetworkType.TESTNET);\nErgoClient client = RestApiErgoClient.create(nodeConfig);\n```\n\nThe `RestApiErgoClient` class also offers several static factory methods, such as `createWithoutExplorer`, `create`, and `createWithHttpClientBuilder`, enabling developers to create `ErgoClient` instances with different configurations, like connecting to a node without an explorer connection or using a custom HTTP client builder.\n\nTo perform operations on the Ergo blockchain, the `execute` method in the `RestApiErgoClient` class is used. This method accepts a `Function` that operates on a `BlockchainContext` and returns a result of type `T`. For example, to retrieve the current block height, you can use the following code:\n\n```java\nint currentHeight = ergoClient.execute(ctx -> ctx.getHeaders().getHeight());\n```\n\nAdditionally, the `org.ergoplatform.appkit.config` package contains classes responsible for managing the configuration of the Ergo node, wallet, and tool parameters. These classes are essential for setting up and interacting with the Ergo blockchain using the `ErgoClient` class. For example, the `ApiConfig` class stores the connection parameters for the Ergo node API, while the `ErgoNodeConfig` class defines the parameters of an Ergo node, including the API configuration, wallet configuration, and network type.\n\nIn conclusion, the `RestApiErgoClient` class and the classes in the `org.ergoplatform.appkit.config` package play a vital role in the ergo-appkit project by providing a convenient way to create instances of the `ErgoClient` interface and manage the configuration of the Ergo node, wallet, and tool parameters. They enable developers to easily interact with the Ergo blockchain and perform various operations, such as retrieving the current block height or sending transactions.",
                      "questions": ""
                    }
                  ],
                  "summary": "The `RestApiErgoClient` class in the `org.ergoplatform.appkit` package is a crucial component of the ergo-appkit project, as it provides an implementation of the `ErgoClient` interface that communicates with an Ergo node using its REST API. This class simplifies the process of creating and configuring instances of the `ErgoClient` interface, allowing developers to easily interact with the Ergo blockchain and perform various operations.\n\nFor instance, to create an `ErgoClient` instance connected to a Testnet Ergo node, you can use the following code snippet:\n\n```java\nApiConfig apiConfig = new ApiConfig(\"http://localhost:9053\");\nWalletConfig walletConfig = new WalletConfig(\"testnet\", \"password\");\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(apiConfig, walletConfig, NetworkType.TESTNET);\nErgoClient client = RestApiErgoClient.create(nodeConfig);\n```\n\nThe `RestApiErgoClient` class also offers several static factory methods, such as `createWithoutExplorer`, `create`, and `createWithHttpClientBuilder`, enabling developers to create `ErgoClient` instances with different configurations, like connecting to a node without an explorer connection or using a custom HTTP client builder.\n\nTo perform operations on the Ergo blockchain, the `execute` method in the `RestApiErgoClient` class is used. This method accepts a `Function` that operates on a `BlockchainContext` and returns a result of type `T`. For example, to retrieve the current block height, you can use the following code:\n\n```java\nint currentHeight = ergoClient.execute(ctx -> ctx.getHeaders().getHeight());\n```\n\nAdditionally, the `org.ergoplatform.appkit.config` package contains classes responsible for managing the configuration of the Ergo node, wallet, and tool parameters. These classes are essential for setting up and interacting with the Ergo blockchain using the `ErgoClient` class. For example, the `ApiConfig` class stores the connection parameters for the Ergo node API, while the `ErgoNodeConfig` class defines the parameters of an Ergo node, including the API configuration, wallet configuration, and network type.\n\nIn conclusion, the `RestApiErgoClient` class and the classes in the `org.ergoplatform.appkit.config` package play a vital role in the ergo-appkit project by providing a convenient way to create instances of the `ErgoClient` interface and manage the configuration of the Ergo node, wallet, and tool parameters. They enable developers to easily interact with the Ergo blockchain and perform various operations, such as retrieving the current block height or sending transactions.",
                  "questions": ""
                }
              ],
              "summary": "The `RestApiErgoClient` class in the `org.ergoplatform.appkit` package is a crucial component of the ergo-appkit project, as it provides an implementation of the `ErgoClient` interface that communicates with an Ergo node using its REST API. This class simplifies the process of creating and configuring instances of the `ErgoClient` interface, allowing developers to easily interact with the Ergo blockchain and perform various operations.\n\nFor instance, to create an `ErgoClient` instance connected to a Testnet Ergo node, you can use the following code snippet:\n\n```java\nApiConfig apiConfig = new ApiConfig(\"http://localhost:9053\");\nWalletConfig walletConfig = new WalletConfig(\"testnet\", \"password\");\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(apiConfig, walletConfig, NetworkType.TESTNET);\nErgoClient client = RestApiErgoClient.create(nodeConfig);\n```\n\nThe `RestApiErgoClient` class also offers several static factory methods, such as `createWithoutExplorer`, `create`, and `createWithHttpClientBuilder`, enabling developers to create `ErgoClient` instances with different configurations, like connecting to a node without an explorer connection or using a custom HTTP client builder.\n\nTo perform operations on the Ergo blockchain, the `execute` method in the `RestApiErgoClient` class is used. This method accepts a `Function` that operates on a `BlockchainContext` and returns a result of type `T`. For example, to retrieve the current block height, you can use the following code:\n\n```java\nint currentHeight = ergoClient.execute(ctx -> ctx.getHeaders().getHeight());\n```\n\nAdditionally, the `org.ergoplatform.appkit.config` package contains classes responsible for managing the configuration of the Ergo node, wallet, and tool parameters. These classes are essential for setting up and interacting with the Ergo blockchain using the `ErgoClient` class. For example, the `ApiConfig` class stores the connection parameters for the Ergo node API, while the `ErgoNodeConfig` class defines the parameters of an Ergo node, including the API configuration, wallet configuration, and network type.\n\nIn conclusion, the `RestApiErgoClient` class and the classes in the `org.ergoplatform.appkit.config` package play a vital role in the ergo-appkit project by providing a convenient way to create instances of the `ErgoClient` interface and manage the configuration of the Ergo node, wallet, and tool parameters. They enable developers to easily interact with the Ergo blockchain and perform various operations, such as retrieving the current block height or sending transactions.",
              "questions": ""
            },
            {
              "folderName": "scala",
              "folderPath": ".autodoc/docs/json/appkit/src/main/scala",
              "url": "https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/scala",
              "files": [],
              "folders": [
                {
                  "folderName": "org",
                  "folderPath": ".autodoc/docs/json/appkit/src/main/scala/org",
                  "url": "https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/scala/org",
                  "files": [],
                  "folders": [
                    {
                      "folderName": "ergoplatform",
                      "folderPath": ".autodoc/docs/json/appkit/src/main/scala/org/ergoplatform",
                      "url": "https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/scala/org/ergoplatform",
                      "files": [],
                      "folders": [
                        {
                          "folderName": "appkit",
                          "folderPath": ".autodoc/docs/json/appkit/src/main/scala/org/ergoplatform/appkit",
                          "url": "https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/scala/org/ergoplatform/appkit",
                          "files": [
                            {
                              "fileName": "ColdErgoClient.scala",
                              "filePath": "appkit/src/main/scala/org/ergoplatform/appkit/ColdErgoClient.scala",
                              "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/ColdErgoClient.scala",
                              "summary": "The code above defines a class called `ColdErgoClient` that extends the `ErgoClient` class. The purpose of this class is to provide a way to interact with the Ergo blockchain in a cold environment, meaning that the private keys are stored offline and not connected to the internet. \n\nThe `ColdErgoClient` class takes two parameters: `networkType` and `params`. `networkType` specifies which Ergo network to connect to (mainnet or testnet), while `params` is an instance of `BlockchainParameters` that contains information about the blockchain, such as the node's address and port number. \n\nThe class has a convenience constructor that takes three parameters: `networkType`, `maxBlockCost`, and `blockVersion`. This constructor creates a new instance of `NodeInfoParameters` with the given `maxBlockCost` and `blockVersion` values, and passes it to the main constructor. \n\nThe `execute` method overrides the same method in the `ErgoClient` class. It takes a `Function` that operates on a `BlockchainContext` and returns a result of type `T`. It creates a new instance of `ColdBlockchainContext` with the given `networkType` and `params`, and applies the given `Function` to it. The result of the `Function` is returned. \n\nThe `getDataSource` method is not implemented and simply returns `null`. \n\nOverall, the `ColdErgoClient` class provides a way to interact with the Ergo blockchain in a cold environment, where private keys are stored offline. It can be used in the larger project to perform transactions and other operations on the blockchain without exposing sensitive information to the internet. \n\nExample usage:\n\n```\nval client = new ColdErgoClient(NetworkType.MAINNET, new BlockchainParameters(\"localhost\", 9052))\nval result = client.execute(ctx => {\n  val wallet = ctx.getWallet\n  val balance = wallet.getBalance\n  balance\n})\nprintln(result)\n```",
                              "questions": "1. What is the purpose of this code and what does it do?\n- This code defines a class called `ColdErgoClient` which extends `ErgoClient` and provides a convenience constructor for setting `maxBlockCost` and `blockVersion` parameters.\n\n2. What other classes or packages does this code depend on?\n- This code depends on `java.util.function`, `org.ergoplatform.restapi.client`, and `org.ergoplatform.appkit.impl` packages.\n\n3. What is the difference between `execute` and `getDataSource` methods in this class?\n- The `execute` method takes a function that operates on a `BlockchainContext` and returns a result of type `T`, while the `getDataSource` method returns a `BlockchainDataSource` object. However, the implementation of `getDataSource` is not provided and returns `???`."
                            }
                          ],
                          "folders": [
                            {
                              "folderName": "cli",
                              "folderPath": ".autodoc/docs/json/appkit/src/main/scala/org/ergoplatform/appkit/cli",
                              "url": "https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/scala/org/ergoplatform/appkit/cli",
                              "files": [
                                {
                                  "fileName": "AppContext.scala",
                                  "filePath": "appkit/src/main/scala/org/ergoplatform/appkit/cli/AppContext.scala",
                                  "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/AppContext.scala",
                                  "summary": "The `AppContext` class is a data class that represents the context in which a command is executed in the Ergo platform. It contains all the necessary data to parse and execute a command. The purpose of this class is to provide a convenient way to pass around the context data between different parts of the application.\n\nThe class has several properties that represent different aspects of the context. The `cliApp` property represents the CLI application that created the context. The `commandLineArgs` property contains the arguments passed to the `ErgoTool.main` method. The `console` property represents the console interface to be used during command execution. The `cmdOptions` property contains the options parsed from the command line. The `cmdName` property represents the name of the command to be executed. The `cmdArgs` property contains the arguments taken from the command line (excluding the command name). The `toolConf` property represents the tool configuration read from the file. The `clientFactory` property is a factory method used to create an `ErgoClient` instance if and when it is needed. The `cmdParameters` property represents the parsed and instantiated command parameters.\n\nThe class also has several methods that provide convenient access to different aspects of the context. The `apiUrl` method returns the URL of the Ergo node API endpoint. The `apiKey` method returns the API key used for Ergo node API authentication. The `networkType` method returns the expected network type (Mainnet or Testnet). The `isDryRun` method returns true if the `DryRunOption` is defined in the command line. The `isPrintJson` method returns true if the `PrintJsonOption` is defined in the command line. The `withCmdParameters` method is used to attach parameters to the context.\n\nOverall, the `AppContext` class provides a convenient way to pass around the context data between different parts of the application. It encapsulates all the necessary data and provides convenient methods to access and modify it. This class is an important part of the Ergo platform and is used extensively throughout the application. Here is an example of how the `AppContext` class can be used:\n\n```scala\nval appContext = AppContext(\n  cliApp = myCliApp,\n  commandLineArgs = Seq(\"--option1\", \"value1\", \"--option2\", \"value2\"),\n  console = myConsole,\n  cmdOptions = Map(\"option1\" -> \"value1\", \"option2\" -> \"value2\"),\n  cmdName = \"myCommand\",\n  cmdArgs = Seq(\"arg1\", \"arg2\"),\n  toolConf = myToolConfig,\n  clientFactory = myClientFactory\n)\n\nval apiUrl = appContext.apiUrl\nval apiKey = appContext.apiKey\nval networkType = appContext.networkType\nval isDryRun = appContext.isDryRun\nval isPrintJson = appContext.isPrintJson\n\nval newContext = appContext.withCmdParameters(Seq(\"param1\", \"param2\"))\n```",
                                  "questions": "1. What is the purpose of the `AppContext` class?\n- The `AppContext` class is an application execution context that contains all the data necessary to parse and execute a command.\n\n2. What are the parameters of the `AppContext` class?\n- The parameters of the `AppContext` class include the CLI application that created the context, the command line arguments passed to `ErgoTool.main`, a console interface to be used during command execution, options parsed from the command line, the command name to execute, command args taken from the command line (excluding command name), tool configuration read from the file, a factory method used to create an `ErgoClient` instance, and parsed and instantiated command parameters.\n\n3. What are some of the methods available in the `AppContext` class?\n- Some of the methods available in the `AppContext` class include `apiUrl`, which returns the URL of the Ergo node API endpoint, `apiKey`, which returns the API key used for Ergo node API authentication, `networkType`, which returns the expected network type (Mainnet or Testnet), `isDryRun`, which returns true if the `DryRunOption` is defined in the command line, and `isPrintJson`, which returns true if the `PrintJsonOption` is defined in the command line."
                                },
                                {
                                  "fileName": "CliApplication.scala",
                                  "filePath": "appkit/src/main/scala/org/ergoplatform/appkit/cli/CliApplication.scala",
                                  "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/CliApplication.scala",
                                  "summary": "The code represents a base class for all CLI (Command Line Interface) applications in the Appkit Commands framework. The purpose of this class is to provide a set of methods and properties that can be used by derived classes to create CLI applications. \n\nThe `CliApplication` class contains several methods that are used to parse command-line arguments, load configuration files, and execute commands. The `commands` method returns an array of `CmdDescriptor` objects that represent the commands supported by the application. The `commandsMap` method returns a map of command names to `CmdDescriptor` objects. \n\nThe `run` method is the main entry point for the application. It takes three arguments: `args`, `console`, and `clientFactory`. The `args` argument is an array of strings that represent the command-line arguments passed to the application. The `console` argument is an instance of the `Console` trait that is used to interact with the user. The `clientFactory` argument is a function that creates an instance of the `ErgoClient` class. \n\nThe `run` method does the following steps:\n1. Parses the command-line arguments using the `CmdLineParser.parseOptions` method.\n2. Loads the configuration file using the `loadConfig` method.\n3. Creates an instance of the `AppContext` class.\n4. Parses the command parameters using the `parseCmd` method.\n5. Executes the command using the `Cmd.run` method.\n\nThe `loadConfig` method loads the `ErgoToolConfig` from a file specified either by the command-line option `--conf` or from the default file location. The `parseCmd` method parses the command parameters from the command line using the `AppContext` class and returns a new instance of the command configured with the parsed parameters. \n\nThe `printUsage` method prints usage help to the console for the given command (if defined). If the command is not defined, then it prints basic usage info about all commands. \n\nIn summary, the `CliApplication` class provides a set of methods and properties that can be used by derived classes to create CLI applications. It handles parsing command-line arguments, loading configuration files, and executing commands. It also provides a set of default commands that can be overridden by derived classes.",
                                  "questions": "1. What is the purpose of the `CliApplication` class?\n- The `CliApplication` class is the base class for all CLI applications in the Appkit Commands framework.\n\n2. What steps does the `run` method perform?\n- The `run` method performs the following steps: \n  1. Parse options from the command line.\n  2. Load the config file.\n  3. Create an `AppContext`.\n  4. Parse command parameters.\n  5. Create and execute the command.\n\n3. What is the purpose of the `printUsage` method?\n- The `printUsage` method prints usage help to the console for a given command (if defined) or basic usage info about all commands if the command is not defined."
                                },
                                {
                                  "fileName": "CmdLineParser.scala",
                                  "filePath": "appkit/src/main/scala/org/ergoplatform/appkit/cli/CmdLineParser.scala",
                                  "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/CmdLineParser.scala",
                                  "summary": "# `CmdLineParser` in `ergo-appkit`\n\n`CmdLineParser` is a Scala object that provides a method to parse command line arguments and extract options and parameters. It also provides a method to parse the network type from a string.\n\n## `parseOptions`\n\n`parseOptions` takes a sequence of strings as input, which represents the command line arguments. It returns a tuple of two values: a map of options and their values, and a sequence of parameters.\n\nThe method first creates an empty map to store the options and their values. It then creates a mutable buffer and copies the input sequence into it. This buffer is used to extract options and parameters.\n\nThe method then iterates over the buffer and checks if each argument starts with the `CmdOption.Prefix` string, which is `\"--\"`. If an argument starts with this prefix, it is considered an option. The method then looks up the option in the `CmdOption.options` list, which is a list of predefined options. If the option is found, the method checks if it is a flag or not. If it is a flag, the value is set to `\"true\"`. If it is not a flag, the method checks if there is a value for the option in the next argument. If there is no value, an error is thrown. If there is a value, it is added to the map of options, and the value is removed from the buffer.\n\nIf an argument does not start with the `CmdOption.Prefix` string, it is considered a parameter and is left in the buffer.\n\nThe method returns the map of options and their values, and the remaining parameters in the buffer.\n\n## `parseNetwork`\n\n`parseNetwork` takes a string as input, which represents the network type. It returns a `NetworkType` object, which is an enumeration that represents the network type.\n\nThe method checks if the input string is `\"testnet\"` or `\"mainnet\"`. If it is, it returns the corresponding `NetworkType` object. If it is not, an error is thrown.\n\n## Usage\n\n`CmdLineParser` can be used to parse command line arguments in a Scala application. For example, the following code shows how to use `parseOptions` to parse command line arguments and print the options and parameters:\n\n```scala\nobject MyApp {\n  def main(args: Array[String]): Unit = {\n    val (options, params) = CmdLineParser.parseOptions(args)\n    println(\"Options:\")\n    options.foreach { case (name, value) =>\n      println(s\"$name=$value\")\n    }\n    println(\"Parameters:\")\n    params.foreach { param =>\n      println(param)\n    }\n  }\n}\n```\n\nIf the application is run with the following command line arguments:\n\n```\n--conf myconf.json --verbose param1 param2\n```\n\nThe output will be:\n\n```\nOptions:\nconf=myconf.json\nverbose=true\nParameters:\nparam1\nparam2\n```",
                                  "questions": "1. What is the purpose of this code?\n    \n    This code defines a command line parser for extracting options and parameters from the command line arguments passed to the Ergo Appkit CLI.\n\n2. What is the format of the options that can be passed to this command line parser?\n    \n    The options that can be passed to this command line parser start with `--` and are parsed into name-value pairs. Any option with `CmdOption.isFlag == true` is parsed without a value.\n\n3. What is the purpose of the `parseNetwork` method?\n    \n    The `parseNetwork` method takes a string argument representing the network type and returns the corresponding `NetworkType` enum value. If the input string is not a valid network type, it raises a `usageError`."
                                },
                                {
                                  "fileName": "Console.scala",
                                  "filePath": "appkit/src/main/scala/org/ergoplatform/appkit/cli/Console.scala",
                                  "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/Console.scala",
                                  "summary": "The `Console` class is an abstract interface for console interactions, such as print and read operations. It defines methods for printing a string to the output stream, reading a line from the input stream, and reading a password. The `Console` class is implemented by two concrete classes: `MainConsole` and `TestConsole`.\n\nThe `MainConsole` class is a wrapper around the system console and is intended to be used in the `Application.main` method. It provides implementations for the methods defined in the `Console` class using the `System.console()` method to access the system console.\n\nThe `TestConsole` class is a console implementation intended to be used in tests. It takes a `BufferedReader` and a `PrintStream` as input and provides implementations for the methods defined in the `Console` class using these input and output streams.\n\nThe `Console` object provides utility methods for reading a new password from the console. The `readNewPassword` method takes a number of attempts and a `Console` instance as input, along with a code block that requests the user to enter a new password twice. It then compares the two passwords and returns the password as a `SecretString` if they match. If they do not match, it prompts the user to try again up to the specified number of attempts. If the user fails to enter a valid password within the specified number of attempts, it throws a `UsageException`.\n\nThe `Console` object also provides a convenience method `readNewPassword` that takes two prompts as input and uses the `Console` instance from the `AppContext` to read the passwords.\n\nThe `ConsoleException` class is an exception thrown by the `Console` class when incorrect usage is detected.\n\nOverall, the `Console` class and its implementations provide a way to interact with the console in a standardized way, making it easier to write and test console-based applications. The `readNewPassword` method is a useful utility for securely reading passwords from the console.",
                                  "questions": "1. What is the purpose of the `Console` abstract class?\n- The `Console` abstract class defines an interface for console interactions, including print and read operations.\n\n2. What is the purpose of the `readNewPassword` method in the `Console` object?\n- The `readNewPassword` method in the `Console` object provides a secure way to double-enter a new password, allowing the user multiple attempts before failing with an exception.\n\n3. What is the purpose of the `TestConsole` class?\n- The `TestConsole` class is a console implementation to be used in tests, providing methods for printing and reading input/output streams."
                                },
                                {
                                  "fileName": "HelpCmd.scala",
                                  "filePath": "appkit/src/main/scala/org/ergoplatform/appkit/cli/HelpCmd.scala",
                                  "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/HelpCmd.scala",
                                  "summary": "The code provided is a part of the ergo-appkit project and is located in the ergotool package. The purpose of this code is to provide a Help command that can be used to print usage help for a given command name. The Help command is implemented as a case class called HelpCmd, which takes three parameters: toolConf, name, and askedCmd. The toolConf parameter is an instance of ErgoToolConfig, which is used to configure the ErgoTool application. The name parameter is the name of the Help command, which is \"help\". The askedCmd parameter is the name of the command for which usage help should be printed.\n\nThe HelpCmd case class implements the run method, which takes an instance of AppContext as a parameter. The AppContext class provides access to the ErgoTool application context, which includes the list of available commands. The HelpCmd case class uses the commandsMap property of the AppContext class to look up the command with the given name. If the command is found, the printUsage method of the command is called to print the usage help. If the command is not found, an error message is printed.\n\nThe HelpCmd object provides a descriptor and parser for the Help command. The descriptor is an instance of the CmdDescriptor class, which provides information about the command, such as its name, syntax, and description. The parser is implemented as the createCmd method, which takes an instance of AppContext as a parameter and returns an instance of the HelpCmd case class. The createCmd method uses the cmdParameters property of the AppContext class to get the name of the command for which usage help should be printed.\n\nOverall, this code provides a useful Help command that can be used to get usage help for any command in the ErgoTool application. For example, to get usage help for the \"send\" command, the user can run the following command:\n\n```\nergotool help send\n```\n\nThis will print the usage help for the \"send\" command.",
                                  "questions": "1. What is the purpose of this code?\n- This code defines a HelpCmd class and a HelpCmd object that provide usage help for a given command name in the ergo-appkit project.\n\n2. What dependencies are required for this code to work?\n- This code requires dependencies from the org.ergoplatform.appkit.cli and org.ergoplatform.appkit.commands packages.\n\n3. How is the usage help printed for a given command name?\n- The run method of the HelpCmd class checks if the given command name exists in the commandsMap of the AppContext object and prints its usage help if it exists. Otherwise, it throws a CmdException with an error message."
                                },
                                {
                                  "fileName": "Options.scala",
                                  "filePath": "appkit/src/main/scala/org/ergoplatform/appkit/cli/Options.scala",
                                  "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/Options.scala",
                                  "summary": "The code defines a set of classes and objects that represent command-line interface (CLI) options for the Ergo blockchain platform. The `CmdOption` class represents a single option that can be passed to a command-line tool. Each option has a name, a type, a description, and a flag indicating whether it is a boolean option (i.e., it does not have an associated value). The `ConfigOption`, `DryRunOption`, `PrintJsonOption`, and `LimitListOption` objects are instances of `CmdOption` that represent specific options that can be passed to the Ergo CLI tool.\n\nThe `CmdOption` class has two methods: `cmdText` and `helpString`. The `cmdText` method returns the text of the command line with the name of the option, while the `helpString` method returns a string that is printed for this option in the usage help output.\n\nThe `ConfigOption` object represents an option that specifies the path to a configuration file. The file has JSON content corresponding to the `ErgoToolConfig` class. The `DryRunOption` object represents an option that forces the command to report what will be done by the operation without performing the actual operation. This is useful for commands that perform some real-world effects such as sending a transaction to the blockchain. The `PrintJsonOption` object represents an option that forces commands to print objects as formatted JSON instead of rows in a table. The `LimitListOption` object represents an option that specifies a number of items in the output list.\n\nThe `CmdOption` class and its subclasses are used in the Ergo CLI tool to provide a flexible and extensible way to specify options for commands. For example, the `SendCmd` command might use the `DryRunOption` to allow users to preview the effects of sending a transaction before actually sending it. The `CmdOption` class and its subclasses can be used in other projects that require a CLI tool with extensible options. \n\nExample usage:\n\n```\n$ ergo-cli --conf ergo_tool.json --dry-run\n```\n\nThis command runs the Ergo CLI tool with the `ConfigOption` and `DryRunOption` options. The `--conf` option specifies the path to a configuration file, and the `--dry-run` option forces the command to report what will be done by the operation without performing the actual operation.",
                                  "questions": "1. What is the purpose of the `CmdOption` class?\n- The `CmdOption` class represents a CLI option description that can be used in command line to specify parameters to be used by the command during its operation.\n\n2. What is the difference between a regular option and a flag option?\n- A regular option is given using the syntax `--optionName optionValue`, while a flag option is given using the syntax `--optionName` without an `optionValue` part. If a `CmdOption` instance has `isFlag` set to `true`, then such option doesn't have an `optionValue` part and the option is interpreted as Boolean value (`true` if it is present, `false` otherwise).\n\n3. What are some examples of options supported by the `ergo-appkit` application?\n- Some examples of options supported by the `ergo-appkit` application are `ConfigOption` (string option to specify path to a configuration file), `DryRunOption` (flag option to prevent the command to perform actual operation and instead forces it to report planned actions), `PrintJsonOption` (flag option to force commands to print objects as formatted json instead of rows in table), and `LimitListOption` (specifies a number of items in the output list)."
                                },
                                {
                                  "fileName": "Utils.scala",
                                  "filePath": "appkit/src/main/scala/org/ergoplatform/appkit/cli/Utils.scala",
                                  "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/Utils.scala",
                                  "summary": "# `Utils` Object in `ergo-appkit`\n\nThe `Utils` object in the `ergo-appkit` project is a collection of utility methods that can be used throughout the project. The purpose of this object is to provide a set of common functions that can be used by other parts of the project to simplify code and reduce duplication.\n\nThe `loggedStep` method is one of the utility methods provided by the `Utils` object. This method takes three parameters: a message to print to the console, a `Console` object to use for printing, and a block of code to execute. The method prints the message to the console, executes the block of code, and then prints the status of the step (either \"Ok\" or \"Error\") to the console.\n\nHere is an example of how the `loggedStep` method might be used in the larger project:\n\n```scala\nimport org.ergoplatform.appkit.cli.Utils\n\nval console = new Console // create a new Console object\nval result = Utils.loggedStep(\"Performing step 1\", console) {\n  // code to execute for step 1\n}\n```\n\nIn this example, the `loggedStep` method is used to execute a block of code and print a message to the console. The result of the block of code is stored in the `result` variable.\n\nOverall, the `Utils` object provides a set of common utility methods that can be used throughout the `ergo-appkit` project to simplify code and reduce duplication. The `loggedStep` method is just one example of the many useful functions provided by this object.",
                                  "questions": "1. What is the purpose of the `Utils` object?\n   - The `Utils` object contains utility methods.\n2. What does the `loggedStep` method do?\n   - The `loggedStep` method prints a step description to the console, performs the step, and then finishes the description with the step status.\n3. What is the input and output of the `loggedStep` method?\n   - The input of the `loggedStep` method is a message string and a console object, and the output is the result of the step."
                                }
                              ],
                              "folders": [],
                              "summary": "The `.autodoc/docs/json/appkit/src/main/scala/org/ergoplatform/appkit/cli` folder contains several Scala files that are part of the Ergo platform's command-line interface (CLI) tools. These files provide a framework for creating CLI applications, parsing command-line arguments, handling console interactions, and defining CLI options.\n\n`AppContext.scala` defines a data class that represents the context in which a command is executed. It encapsulates all the necessary data and provides convenient methods to access and modify it. This class is used extensively throughout the application to pass around the context data between different parts of the application.\n\n`CliApplication.scala` provides a base class for all CLI applications in the Appkit Commands framework. It handles parsing command-line arguments, loading configuration files, and executing commands. Derived classes can use the methods and properties provided by this class to create CLI applications.\n\n`CmdLineParser.scala` is a Scala object that provides methods to parse command line arguments and extract options and parameters. It can be used to parse command line arguments in a Scala application, making it easier to handle user input.\n\n`Console.scala` is an abstract interface for console interactions, such as print and read operations. It has two concrete implementations: `MainConsole` for the system console and `TestConsole` for testing purposes. The `Console` object also provides utility methods for securely reading passwords from the console.\n\n`HelpCmd.scala` provides a Help command that can be used to print usage help for a given command name. It is a useful addition to any CLI application, allowing users to get help on how to use specific commands.\n\n`Options.scala` defines a set of classes and objects that represent CLI options for the Ergo blockchain platform. The `CmdOption` class and its subclasses can be used in other projects that require a CLI tool with extensible options.\n\n`Utils.scala` is a collection of utility methods that can be used throughout the project. One example is the `loggedStep` method, which can be used to execute a block of code and print a message to the console.\n\nHere's an example of how these classes might be used together:\n\n```scala\nimport org.ergoplatform.appkit.cli._\n\nobject MyApp extends CliApplication {\n  def main(args: Array[String]): Unit = {\n    val console = new MainConsole\n    val clientFactory = () => new ErgoClient(...)\n    run(args, console, clientFactory)\n  }\n\n  override def commands: Array[CmdDescriptor] = Array(\n    HelpCmd.descriptor,\n    // other command descriptors\n  )\n}\n```\n\nIn this example, a new CLI application is created by extending the `CliApplication` class. The `main` method initializes a `MainConsole` instance, a `clientFactory`, and calls the `run` method with the command-line arguments. The `commands` method is overridden to include the `HelpCmd` descriptor and other command descriptors.",
                              "questions": ""
                            },
                            {
                              "folderName": "commands",
                              "folderPath": ".autodoc/docs/json/appkit/src/main/scala/org/ergoplatform/appkit/commands",
                              "url": "https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/scala/org/ergoplatform/appkit/commands",
                              "files": [
                                {
                                  "fileName": "Commands.scala",
                                  "filePath": "appkit/src/main/scala/org/ergoplatform/appkit/commands/Commands.scala",
                                  "url": "https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/commands/Commands.scala",
                                  "summary": "This code defines classes and traits that are used to implement commands for the ErgoTool application. The `Cmd` abstract class is the base class for all commands that can be executed by ErgoTool. It defines methods that return the current tool configuration parameters, the name of the command, the URL of the Ergo blockchain node used to communicate with the network, the API key used for Ergo node API authentication, and the network type (MAINNET or TESTNET) that ErgoTool is expected to communicate with. It also defines a `run` method that executes the command using the given `AppContext`.\n\nThe `RunWithErgoClient` trait can be used to implement commands that need to communicate with the Ergo blockchain. It extends the `Cmd` abstract class and overrides the `run` method to create an `ErgoClient` instance and call the `runWithClient` method with it.\n\nThe `CmdParameter` case class represents a command parameter descriptor. It contains information such as the parameter name, type, description, default value, and whether it is entered interactively or parsed from the command line.\n\nThe `CmdDescriptor` abstract class is the base class for all command descriptors (usually companion objects). It defines the command name used in the command line, the syntax for the command parameters, and a human-readable description of the command. It also defines a `createCmd` method that creates a new command instance based on the given `AppContext`, and a `parseArgs` method that parses the command line arguments into a sequence of parameter values.\n\nThe `CmdArgParser` abstract class is a parser of the command line string. It defines a `parse` method that parses the given raw string into a value of the parameter type.\n\nThe `CmdArgInput` abstract class is an input handler of `CmdParameter`. It defines an `input` method that is called to input the given parameter.\n\nThe `UsageException` case class is an exception thrown by the ErgoTool application when incorrect usage is detected. It contains an error message and an optional descriptor of the command which was incorrectly used.\n\nThe `ErgoToolException` case class is an exception thrown by the ErgoTool application before or after command execution. It contains an error message and an optional cause.\n\nThe `CmdException` case class is an exception thrown by executing `Cmd.run`, wrapping the cause if needed. It contains an error message, the command that threw the exception, and an optional cause.",
                                  "questions": "1. What is the purpose of the `Cmd` class and its methods?\n- The `Cmd` class is a base class for all commands that can be executed by ErgoTool. Its methods include returning the current tool configuration parameters, returning the name of the command, returning the URL of the Ergo blockchain node used to communicate with the network, and running the command using the given `AppContext`.\n\n2. What is the purpose of the `RunWithErgoClient` trait?\n- The `RunWithErgoClient` trait can be used to implement commands that need to communicate with the Ergo blockchain. It provides a default implementation of the `run` method and declares a new method with an additional `ErgoClient` parameter, which is called from the default implementation.\n\n3. What is the purpose of the `CmdParameter` case class and its fields?\n- The `CmdParameter` case class is a descriptor for a command parameter. Its fields include the parameter name, display name, type, description, default value, interactive input, and argument parser. It is used to specify the syntax for a command and to parse its parameters from the command line."
                                }
                              ],
                              "folders": [],
                              "summary": "The `Commands.scala` file in the `org.ergoplatform.appkit.commands` package is responsible for defining the structure and functionality of commands that can be executed by the ErgoTool application. It provides a set of classes and traits that can be extended or implemented to create custom commands for interacting with the Ergo blockchain.\n\nThe `Cmd` abstract class serves as the base class for all commands in ErgoTool. It provides methods for accessing the tool's configuration parameters, the command name, the Ergo node URL, the API key for authentication, and the network type (MAINNET or TESTNET). The `run` method is responsible for executing the command using the provided `AppContext`.\n\nFor commands that need to communicate with the Ergo blockchain, the `RunWithErgoClient` trait can be used. This trait extends the `Cmd` abstract class and overrides the `run` method to create an `ErgoClient` instance, which is then passed to the `runWithClient` method.\n\nTo define command parameters, the `CmdParameter` case class is used. It contains information about the parameter, such as its name, type, description, default value, and whether it is entered interactively or parsed from the command line.\n\nThe `CmdDescriptor` abstract class serves as the base class for command descriptors, which are usually companion objects. It defines the command name, parameter syntax, and a human-readable description. The `createCmd` method is responsible for creating a new command instance based on the given `AppContext`, while the `parseArgs` method parses command line arguments into a sequence of parameter values.\n\nFor parsing command line strings, the `CmdArgParser` abstract class is provided. It defines a `parse` method that takes a raw string and converts it into a value of the parameter type.\n\nThe `CmdArgInput` abstract class is an input handler for `CmdParameter`. It defines an `input` method that is called to input the given parameter.\n\nIn case of incorrect usage or errors during command execution, the `UsageException`, `ErgoToolException`, and `CmdException` case classes are provided. These exceptions contain error messages, optional command descriptors, and optional causes to help developers identify and handle issues.\n\nHere's an example of how to create a custom command using the provided classes and traits:\n\n```scala\nclass MyCommand extends Cmd with RunWithErgoClient {\n  override def name: String = \"my-command\"\n  override def ergoClient: ErgoClient = ...\n  // Implement the runWithClient method\n  override def runWithClient(ergoClient: ErgoClient, appCtx: AppContext): Unit = {\n    // Your command logic here\n  }\n}\n\nobject MyCommand extends CmdDescriptor {\n  override val name: String = \"my-command\"\n  override val description: String = \"A custom command for ErgoTool\"\n  override val syntax: String = \"my-command <param1> <param2>\"\n\n  override def createCmd(appCtx: AppContext): Cmd = new MyCommand\n  override def parseArgs(args: Seq[String]): Seq[CmdParameter] = ...\n}\n```\n\nIn summary, the `Commands.scala` file provides a framework for creating and executing commands in the ErgoTool application. It offers a set of classes and traits that can be extended or implemented to create custom commands for interacting with the Ergo blockchain, handling command parameters, parsing command line arguments, and managing exceptions.",
                              "questions": ""
                            }
                          ],
                          "summary": "The `org.ergoplatform.appkit` package provides a set of Scala classes and utilities for interacting with the Ergo blockchain. The main class in this package is `ColdErgoClient`, which allows developers to interact with the Ergo blockchain in a cold environment, where private keys are stored offline. This is useful for performing transactions and other operations on the blockchain without exposing sensitive information to the internet.\n\nExample usage of `ColdErgoClient`:\n\n```scala\nval client = new ColdErgoClient(NetworkType.MAINNET, new BlockchainParameters(\"localhost\", 9052))\nval result = client.execute(ctx => {\n  val wallet = ctx.getWallet\n  val balance = wallet.getBalance\n  balance\n})\nprintln(result)\n```\n\nThe `cli` subfolder contains a set of Scala files for creating command-line interface (CLI) tools for the Ergo platform. These files provide a framework for creating CLI applications, parsing command-line arguments, handling console interactions, and defining CLI options. An example of how to create a custom CLI application using these classes is shown below:\n\n```scala\nimport org.ergoplatform.appkit.cli._\n\nobject MyApp extends CliApplication {\n  def main(args: Array[String]): Unit = {\n    val console = new MainConsole\n    val clientFactory = () => new ErgoClient(...)\n    run(args, console, clientFactory)\n  }\n\n  override def commands: Array[CmdDescriptor] = Array(\n    HelpCmd.descriptor,\n    // other command descriptors\n  )\n}\n```\n\nThe `commands` subfolder contains the `Commands.scala` file, which provides a framework for creating and executing commands in the ErgoTool application. It offers a set of classes and traits that can be extended or implemented to create custom commands for interacting with the Ergo blockchain, handling command parameters, parsing command line arguments, and managing exceptions. An example of how to create a custom command using the provided classes and traits is shown below:\n\n```scala\nclass MyCommand extends Cmd with RunWithErgoClient {\n  override def name: String = \"my-command\"\n  override def ergoClient: ErgoClient = ...\n  // Implement the runWithClient method\n  override def runWithClient(ergoClient: ErgoClient, appCtx: AppContext): Unit = {\n    // Your command logic here\n  }\n}\n\nobject MyCommand extends CmdDescriptor {\n  override val name: String = \"my-command\"\n  override val description: String = \"A custom command for ErgoTool\"\n  override val syntax: String = \"my-command <param1> <param2>\"\n\n  override def createCmd(appCtx: AppContext): Cmd = new MyCommand\n  override def parseArgs(args: Seq[String]): Seq[CmdParameter] = ...\n}\n```\n\nIn summary, the `org.ergoplatform.appkit` package and its subfolders provide a set of Scala classes and utilities for interacting with the Ergo blockchain, creating CLI tools, and defining custom commands. These classes can be used in larger projects to perform transactions and other operations on the Ergo blockchain, as well as to create custom CLI applications and commands for interacting with the blockchain.",
                          "questions": ""
                        }
                      ],
                      "summary": "The `org.ergoplatform.appkit` package provides a set of Scala classes and utilities for interacting with the Ergo blockchain. The main class in this package is `ColdErgoClient`, which allows developers to interact with the Ergo blockchain in a cold environment, where private keys are stored offline. This is useful for performing transactions and other operations on the blockchain without exposing sensitive information to the internet.\n\nExample usage of `ColdErgoClient`:\n\n```scala\nval client = new ColdErgoClient(NetworkType.MAINNET, new BlockchainParameters(\"localhost\", 9052))\nval result = client.execute(ctx => {\n  val wallet = ctx.getWallet\n  val balance = wallet.getBalance\n  balance\n})\nprintln(result)\n```\n\nThe `cli` subfolder contains a set of Scala files for creating command-line interface (CLI) tools for the Ergo platform. These files provide a framework for creating CLI applications, parsing command-line arguments, handling console interactions, and defining CLI options. An example of how to create a custom CLI application using these classes is shown below:\n\n```scala\nimport org.ergoplatform.appkit.cli._\n\nobject MyApp extends CliApplication {\n  def main(args: Array[String]): Unit = {\n    val console = new MainConsole\n    val clientFactory = () => new ErgoClient(...)\n    run(args, console, clientFactory)\n  }\n\n  override def commands: Array[CmdDescriptor] = Array(\n    HelpCmd.descriptor,\n    // other command descriptors\n  )\n}\n```\n\nThe `commands` subfolder contains the `Commands.scala` file, which provides a framework for creating and executing commands in the ErgoTool application. It offers a set of classes and traits that can be extended or implemented to create custom commands for interacting with the Ergo blockchain, handling command parameters, parsing command line arguments, and managing exceptions. An example of how to create a custom command using the provided classes and traits is shown below:\n\n```scala\nclass MyCommand extends Cmd with RunWithErgoClient {\n  override def name: String = \"my-command\"\n  override def ergoClient: ErgoClient = ...\n  // Implement the runWithClient method\n  override def runWithClient(ergoClient: ErgoClient, appCtx: AppContext): Unit = {\n    // Your command logic here\n  }\n}\n\nobject MyCommand extends CmdDescriptor {\n  override val name: String = \"my-command\"\n  override val description: String = \"A custom command for ErgoTool\"\n  override val syntax: String = \"my-command <param1> <param2>\"\n\n  override def createCmd(appCtx: AppContext): Cmd = new MyCommand\n  override def parseArgs(args: Seq[String]): Seq[CmdParameter] = ...\n}\n```\n\nIn summary, the `org.ergoplatform.appkit` package and its subfolders provide a set of Scala classes and utilities for interacting with the Ergo blockchain, creating CLI tools, and defining custom commands. These classes can be used in larger projects to perform transactions and other operations on the Ergo blockchain, as well as to create custom CLI applications and commands for interacting with the blockchain.",
                      "questions": ""
                    }
                  ],
                  "summary": "The `org.ergoplatform.appkit` package provides a set of Scala classes and utilities for interacting with the Ergo blockchain. The main class in this package is `ColdErgoClient`, which allows developers to interact with the Ergo blockchain in a cold environment, where private keys are stored offline. This is useful for performing transactions and other operations on the blockchain without exposing sensitive information to the internet.\n\nExample usage of `ColdErgoClient`:\n\n```scala\nval client = new ColdErgoClient(NetworkType.MAINNET, new BlockchainParameters(\"localhost\", 9052))\nval result = client.execute(ctx => {\n  val wallet = ctx.getWallet\n  val balance = wallet.getBalance\n  balance\n})\nprintln(result)\n```\n\nThe `cli` subfolder contains a set of Scala files for creating command-line interface (CLI) tools for the Ergo platform. These files provide a framework for creating CLI applications, parsing command-line arguments, handling console interactions, and defining CLI options. An example of how to create a custom CLI application using these classes is shown below:\n\n```scala\nimport org.ergoplatform.appkit.cli._\n\nobject MyApp extends CliApplication {\n  def main(args: Array[String]): Unit = {\n    val console = new MainConsole\n    val clientFactory = () => new ErgoClient(...)\n    run(args, console, clientFactory)\n  }\n\n  override def commands: Array[CmdDescriptor] = Array(\n    HelpCmd.descriptor,\n    // other command descriptors\n  )\n}\n```\n\nThe `commands` subfolder contains the `Commands.scala` file, which provides a framework for creating and executing commands in the ErgoTool application. It offers a set of classes and traits that can be extended or implemented to create custom commands for interacting with the Ergo blockchain, handling command parameters, parsing command line arguments, and managing exceptions. An example of how to create a custom command using the provided classes and traits is shown below:\n\n```scala\nclass MyCommand extends Cmd with RunWithErgoClient {\n  override def name: String = \"my-command\"\n  override def ergoClient: ErgoClient = ...\n  // Implement the runWithClient method\n  override def runWithClient(ergoClient: ErgoClient, appCtx: AppContext): Unit = {\n    // Your command logic here\n  }\n}\n\nobject MyCommand extends CmdDescriptor {\n  override val name: String = \"my-command\"\n  override val description: String = \"A custom command for ErgoTool\"\n  override val syntax: String = \"my-command <param1> <param2>\"\n\n  override def createCmd(appCtx: AppContext): Cmd = new MyCommand\n  override def parseArgs(args: Seq[String]): Seq[CmdParameter] = ...\n}\n```\n\nIn summary, the `org.ergoplatform.appkit` package and its subfolders provide a set of Scala classes and utilities for interacting with the Ergo blockchain, creating CLI tools, and defining custom commands. These classes can be used in larger projects to perform transactions and other operations on the Ergo blockchain, as well as to create custom CLI applications and commands for interacting with the blockchain.",
                  "questions": ""
                }
              ],
              "summary": "The `.autodoc/docs/json/appkit/src/main/scala` folder contains the `org.ergoplatform.appkit` package, which provides a set of Scala classes and utilities for interacting with the Ergo blockchain. The main class in this package is `ColdErgoClient`, which allows developers to interact with the Ergo blockchain in a cold environment, where private keys are stored offline. This is useful for performing transactions and other operations on the blockchain without exposing sensitive information to the internet.\n\nExample usage of `ColdErgoClient`:\n\n```scala\nval client = new ColdErgoClient(NetworkType.MAINNET, new BlockchainParameters(\"localhost\", 9052))\nval result = client.execute(ctx => {\n  val wallet = ctx.getWallet\n  val balance = wallet.getBalance\n  balance\n})\nprintln(result)\n```\n\nThe `cli` subfolder contains a set of Scala files for creating command-line interface (CLI) tools for the Ergo platform. These files provide a framework for creating CLI applications, parsing command-line arguments, handling console interactions, and defining CLI options. An example of how to create a custom CLI application using these classes is shown below:\n\n```scala\nimport org.ergoplatform.appkit.cli._\n\nobject MyApp extends CliApplication {\n  def main(args: Array[String]): Unit = {\n    val console = new MainConsole\n    val clientFactory = () => new ErgoClient(...)\n    run(args, console, clientFactory)\n  }\n\n  override def commands: Array[CmdDescriptor] = Array(\n    HelpCmd.descriptor,\n    // other command descriptors\n  )\n}\n```\n\nThe `commands` subfolder contains the `Commands.scala` file, which provides a framework for creating and executing commands in the ErgoTool application. It offers a set of classes and traits that can be extended or implemented to create custom commands for interacting with the Ergo blockchain, handling command parameters, parsing command line arguments, and managing exceptions. An example of how to create a custom command using the provided classes and traits is shown below:\n\n```scala\nclass MyCommand extends Cmd with RunWithErgoClient {\n  override def name: String = \"my-command\"\n  override def ergoClient: ErgoClient = ...\n  // Implement the runWithClient method\n  override def runWithClient(ergoClient: ErgoClient, appCtx: AppContext): Unit = {\n    // Your command logic here\n  }\n}\n\nobject MyCommand extends CmdDescriptor {\n  override val name: String = \"my-command\"\n  override val description: String = \"A custom command for ErgoTool\"\n  override val syntax: String = \"my-command <param1> <param2>\"\n\n  override def createCmd(appCtx: AppContext): Cmd = new MyCommand\n  override def parseArgs(args: Seq[String]): Seq[CmdParameter] = ...\n}\n```\n\nIn summary, the `org.ergoplatform.appkit` package and its subfolders provide a set of Scala classes and utilities for interacting with the Ergo blockchain, creating CLI tools, and defining custom commands. These classes can be used in larger projects to perform transactions and other operations on the Ergo blockchain, as well as to create custom CLI applications and commands for interacting with the blockchain.",
              "questions": ""
            }
          ],
          "summary": "The `.autodoc/docs/json/appkit/src/main` folder contains two subfolders, `java` and `scala`, which provide essential classes and utilities for interacting with the Ergo blockchain and creating command-line interface (CLI) tools.\n\nIn the `java` subfolder, the `RestApiErgoClient` class is a key component, as it offers an implementation of the `ErgoClient` interface that communicates with an Ergo node using its REST API. This class simplifies the process of creating and configuring instances of the `ErgoClient` interface, allowing developers to easily interact with the Ergo blockchain and perform various operations. For example, to create an `ErgoClient` instance connected to a Testnet Ergo node, you can use the following code snippet:\n\n```java\nApiConfig apiConfig = new ApiConfig(\"http://localhost:9053\");\nWalletConfig walletConfig = new WalletConfig(\"testnet\", \"password\");\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(apiConfig, walletConfig, NetworkType.TESTNET);\nErgoClient client = RestApiErgoClient.create(nodeConfig);\n```\n\nThe `scala` subfolder contains the `org.ergoplatform.appkit` package, which provides a set of Scala classes and utilities for interacting with the Ergo blockchain. The main class in this package is `ColdErgoClient`, which allows developers to interact with the Ergo blockchain in a cold environment, where private keys are stored offline. This is useful for performing transactions and other operations on the blockchain without exposing sensitive information to the internet.\n\nExample usage of `ColdErgoClient`:\n\n```scala\nval client = new ColdErgoClient(NetworkType.MAINNET, new BlockchainParameters(\"localhost\", 9052))\nval result = client.execute(ctx => {\n  val wallet = ctx.getWallet\n  val balance = wallet.getBalance\n  balance\n})\nprintln(result)\n```\n\nThe `cli` subfolder in the `scala` folder contains a set of Scala files for creating command-line interface (CLI) tools for the Ergo platform. These files provide a framework for creating CLI applications, parsing command-line arguments, handling console interactions, and defining CLI options. An example of how to create a custom CLI application using these classes is shown below:\n\n```scala\nimport org.ergoplatform.appkit.cli._\n\nobject MyApp extends CliApplication {\n  def main(args: Array[String]): Unit = {\n    val console = new MainConsole\n    val clientFactory = () => new ErgoClient(...)\n    run(args, console, clientFactory)\n  }\n\n  override def commands: Array[CmdDescriptor] = Array(\n    HelpCmd.descriptor,\n    // other command descriptors\n  )\n}\n```\n\nIn summary, the `java` and `scala` subfolders in the `.autodoc/docs/json/appkit/src/main` folder provide essential classes and utilities for interacting with the Ergo blockchain, creating CLI tools, and defining custom commands. These classes can be used in larger projects to perform transactions and other operations on the Ergo blockchain, as well as to create custom CLI applications and commands for interacting with the blockchain.",
          "questions": ""
        }
      ],
      "summary": "The `.autodoc/docs/json/appkit/src` folder contains essential classes and utilities for interacting with the Ergo blockchain and creating command-line interface (CLI) tools. The folder is organized into two subfolders, `java` and `scala`, each providing implementations in their respective languages.\n\nIn the `java` subfolder, the `RestApiErgoClient` class is a key component, as it offers an implementation of the `ErgoClient` interface that communicates with an Ergo node using its REST API. This class simplifies the process of creating and configuring instances of the `ErgoClient` interface, allowing developers to easily interact with the Ergo blockchain and perform various operations. For example, to create an `ErgoClient` instance connected to a Testnet Ergo node, you can use the following code snippet:\n\n```java\nApiConfig apiConfig = new ApiConfig(\"http://localhost:9053\");\nWalletConfig walletConfig = new WalletConfig(\"testnet\", \"password\");\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(apiConfig, walletConfig, NetworkType.TESTNET);\nErgoClient client = RestApiErgoClient.create(nodeConfig);\n```\n\nThe `scala` subfolder contains the `org.ergoplatform.appkit` package, which provides a set of Scala classes and utilities for interacting with the Ergo blockchain. The main class in this package is `ColdErgoClient`, which allows developers to interact with the Ergo blockchain in a cold environment, where private keys are stored offline. This is useful for performing transactions and other operations on the blockchain without exposing sensitive information to the internet.\n\nExample usage of `ColdErgoClient`:\n\n```scala\nval client = new ColdErgoClient(NetworkType.MAINNET, new BlockchainParameters(\"localhost\", 9052))\nval result = client.execute(ctx => {\n  val wallet = ctx.getWallet\n  val balance = wallet.getBalance\n  balance\n})\nprintln(result)\n```\n\nThe `cli` subfolder in the `scala` folder contains a set of Scala files for creating command-line interface (CLI) tools for the Ergo platform. These files provide a framework for creating CLI applications, parsing command-line arguments, handling console interactions, and defining CLI options. An example of how to create a custom CLI application using these classes is shown below:\n\n```scala\nimport org.ergoplatform.appkit.cli._\n\nobject MyApp extends CliApplication {\n  def main(args: Array[String]): Unit = {\n    val console = new MainConsole\n    val clientFactory = () => new ErgoClient(...)\n    run(args, console, clientFactory)\n  }\n\n  override def commands: Array[CmdDescriptor] = Array(\n    HelpCmd.descriptor,\n    // other command descriptors\n  )\n}\n```\n\nIn summary, the `java` and `scala` subfolders in the `.autodoc/docs/json/appkit/src/main` folder provide essential classes and utilities for interacting with the Ergo blockchain, creating CLI tools, and defining custom commands. These classes can be used in larger projects to perform transactions and other operations on the Ergo blockchain, as well as to create custom CLI applications and commands for interacting with the blockchain.",
      "questions": ""
    }
  ],
  "summary": "The `.autodoc/docs/json/appkit` folder contains essential classes and utilities for interacting with the Ergo blockchain and creating command-line interface (CLI) tools. The folder is organized into a `src` subfolder, which is further divided into `java` and `scala` subfolders, each providing implementations in their respective languages.\n\nIn the `java` subfolder, the `RestApiErgoClient` class is a key component, as it offers an implementation of the `ErgoClient` interface that communicates with an Ergo node using its REST API. This class simplifies the process of creating and configuring instances of the `ErgoClient` interface, allowing developers to easily interact with the Ergo blockchain and perform various operations. For example, to create an `ErgoClient` instance connected to a Testnet Ergo node, you can use the following code snippet:\n\n```java\nApiConfig apiConfig = new ApiConfig(\"http://localhost:9053\");\nWalletConfig walletConfig = new WalletConfig(\"testnet\", \"password\");\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(apiConfig, walletConfig, NetworkType.TESTNET);\nErgoClient client = RestApiErgoClient.create(nodeConfig);\n```\n\nThe `scala` subfolder contains the `org.ergoplatform.appkit` package, which provides a set of Scala classes and utilities for interacting with the Ergo blockchain. The main class in this package is `ColdErgoClient`, which allows developers to interact with the Ergo blockchain in a cold environment, where private keys are stored offline. This is useful for performing transactions and other operations on the blockchain without exposing sensitive information to the internet.\n\nExample usage of `ColdErgoClient`:\n\n```scala\nval client = new ColdErgoClient(NetworkType.MAINNET, new BlockchainParameters(\"localhost\", 9052))\nval result = client.execute(ctx => {\n  val wallet = ctx.getWallet\n  val balance = wallet.getBalance\n  balance\n})\nprintln(result)\n```\n\nThe `cli` subfolder in the `scala` folder contains a set of Scala files for creating command-line interface (CLI) tools for the Ergo platform. These files provide a framework for creating CLI applications, parsing command-line arguments, handling console interactions, and defining CLI options. An example of how to create a custom CLI application using these classes is shown below:\n\n```scala\nimport org.ergoplatform.appkit.cli._\n\nobject MyApp extends CliApplication {\n  def main(args: Array[String]): Unit = {\n    val console = new MainConsole\n    val clientFactory = () => new ErgoClient(...)\n    run(args, console, clientFactory)\n  }\n\n  override def commands: Array[CmdDescriptor] = Array(\n    HelpCmd.descriptor,\n    // other command descriptors\n  )\n}\n```\n\nIn summary, the `java` and `scala` subfolders in the `.autodoc/docs/json/appkit/src/main` folder provide essential classes and utilities for interacting with the Ergo blockchain, creating CLI tools, and defining custom commands. These classes can be used in larger projects to perform transactions and other operations on the Ergo blockchain, as well as to create custom CLI applications and commands for interacting with the blockchain.",
  "questions": ""
}