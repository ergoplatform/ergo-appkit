{
  "folderName": "scalaapi",
  "folderPath": ".autodoc/docs/json/common/src/main/java/org/ergoplatform/appkit/scalaapi",
  "url": "https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/common/src/main/java/org/ergoplatform/appkit/scalaapi",
  "files": [
    {
      "fileName": "ErgoValueBuilder.scala",
      "filePath": "common/src/main/java/org/ergoplatform/appkit/scalaapi/ErgoValueBuilder.scala",
      "url": "https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/scalaapi/ErgoValueBuilder.scala",
      "summary": "The `ErgoValueBuilder` object is a helper builder that simplifies the construction of `ErgoValue` instances. `ErgoValue` is a class that represents a value in the Ergo blockchain, and it is used extensively throughout the Ergo appkit project. \n\nThe `buildFor` method takes two type parameters, `S` and `J`, which represent the Scala type and the corresponding Java type, respectively. The method also takes a value of type `S` and an isomorphism `iso` that maps `S` to `J`. The isomorphism is used to convert the Scala value to the corresponding Java value. \n\nThe method then constructs an `ErgoValue` instance of the Java type `J` that corresponds to the Scala type `S`. The `of` method of the `ErgoValue` class is used to create the instance, and it takes two arguments: the Java value and the Java class of the value. \n\nThis code is useful because it simplifies the creation of `ErgoValue` instances, which are used extensively throughout the Ergo appkit project. Instead of manually creating `ErgoValue` instances, developers can use the `ErgoValueBuilder` to construct them easily. \n\nHere is an example of how the `ErgoValueBuilder` can be used:\n\n```scala\nimport org.ergoplatform.appkit.scalaapi.ErgoValueBuilder\nimport org.ergoplatform.appkit.{ErgoTree, ErgoValue}\n\n// Define a Scala value\nval myValue: List[(Byte, List[Int])] = List((1.toByte, List(1, 2, 3)), (2.toByte, List(4, 5, 6)))\n\n// Define an isomorphism that maps the Scala value to the corresponding Java value\nimplicit val myIso = new Iso[List[(Byte, List[Int])], java.util.List[java.util.List[java.lang.Integer]]] {\n  override def toJava(s: List[(Byte, List[Int])]): java.util.List[java.util.List[java.lang.Integer]] = {\n    s.map { case (b, l) => l.map(Integer.valueOf).asJava }.asJava\n  }\n}\n\n// Use the ErgoValueBuilder to construct an ErgoValue instance\nval ergoValue: ErgoValue[java.util.List[java.util.List[java.lang.Integer]]] = ErgoValueBuilder.buildFor(myValue)\n```\n\nIn this example, the `myValue` variable is a Scala list of tuples, where each tuple contains a byte and a list of integers. The `myIso` variable is an isomorphism that maps the Scala list of tuples to a Java list of lists of integers. The `ErgoValueBuilder.buildFor` method is then used to construct an `ErgoValue` instance of the Java type `java.util.List[java.util.List[java.lang.Integer]]`.",
      "questions": "1. What is the purpose of this code?\n- This code defines a helper builder called `ErgoValueBuilder` that can be used to easily construct `ErgoValue` instances from Scala types supported by ErgoScript and ErgoTree.\n\n2. What is the input and output of the `buildFor` method?\n- The `buildFor` method takes a value of a Scala type supported by ErgoScript and an isomorphism that projects the given Scala type to the corresponding Java type. It returns an `ErgoValue` instance of the Java type that corresponds to the Scala type.\n\n3. How does the `buildFor` method convert the input value to an `ErgoValue` instance?\n- The `buildFor` method first uses the provided isomorphism to convert the input value to the corresponding Java type. It then creates an `ErgoValue` instance from the Java value and the Java type obtained from the isomorphism."
    },
    {
      "fileName": "Extensions.scala",
      "filePath": "common/src/main/java/org/ergoplatform/appkit/scalaapi/Extensions.scala",
      "url": "https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/scalaapi/Extensions.scala",
      "summary": "The `Extensions` object in the `org.ergoplatform.appkit.scalaapi` package provides a set of extension methods for the `Coll` and `CollBuilder` classes. These methods are used to perform various operations on collections, such as partitioning, grouping, and reducing. \n\nThe `CollOps` extension class provides several methods for partitioning a collection based on a predicate, converting a collection to a map, summing the elements of a collection, and grouping elements of a collection by a discriminator function. The `mapReduce` method applies a mapping function to each element of the collection, groups the elements by key, and reduces each group using a reduction function. The `groupByProjecting` method is similar to `groupBy`, but it also applies a projection function to each element of the collection before grouping. \n\nThe `PairCollOps` extension class provides methods for mapping the first and second components of a collection of pairs, reducing a collection of pairs by key, summing a collection of pairs by key, and grouping a collection of pairs by key. \n\nThe `CollBuilderOps` extension class provides a method for performing an outer join operation between two collections. It also provides a method for constructing a collection of pairs from a map.\n\nThese extension methods can be used to simplify the code for working with collections in the Ergo Appkit project. For example, the `groupBy` method can be used to group UTXOs by their ErgoTree, which is useful for building transactions. The `mapReduce` method can be used to compute the total value of a collection of UTXOs. The `outerJoin` method can be used to join two collections of UTXOs based on their ErgoTree and perform some operation on the resulting pairs.",
      "questions": "1. What is the purpose of the `Extensions` object?\n- The `Extensions` object provides extension methods for the `Coll` type, which is a collection type used in the project. \n\n2. What does the `sum` method do?\n- The `sum` method calculates the sum of the elements in a collection using the `Numeric` typeclass. If the collection is empty, it returns the zero value of the `Numeric` type.\n\n3. What is the difference between `groupBy` and `groupByProjecting`?\n- `groupBy` partitions a collection into a map of collections according to a discriminator function, where the keys of the map are the results of applying the discriminator function to the elements of the collection. `groupByProjecting` is similar, but it also applies a projection function to each element of the collection before grouping. The resulting map has keys that are the results of applying the discriminator function, and values that are collections of the projected values."
    },
    {
      "fileName": "Iso.scala",
      "filePath": "common/src/main/java/org/ergoplatform/appkit/scalaapi/Iso.scala",
      "url": "https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/scalaapi/Iso.scala",
      "summary": "The `Iso` class and its related classes define an isomorphism between Scala and Java types. An isomorphism is a bi-directional mapping between two types that preserves their structure. The `Iso` class is abstract and has two type parameters, `S` and `J`, which represent the Scala and Java types, respectively. The class has four methods: `scalaType`, `javaType`, `toJava`, and `toScala`. The `scalaType` and `javaType` methods return the type descriptors for the corresponding types. The `toJava` method converts a value of type `S` to a value of type `J`, and the `toScala` method converts a value of type `J` to a value of type `S`.\n\nThe `Iso` class has several subclasses that implement specific isomorphisms. The `IdentityIso` class is a subclass that implements an isomorphism between a type and itself. The `PrimIso` class is a subclass that implements an isomorphism between a primitive Scala type and its corresponding Java wrapper type. The `PairIso` class is a subclass that implements an isomorphism between a Scala pair type and a Java pair type. The `CollIso` class is a subclass that implements an isomorphism between a Scala collection type and a Java collection type.\n\nThe `Iso` object contains several implicit isomorphisms between Scala and Java types. These isomorphisms are used to convert values between the two languages. For example, the `isoByte` isomorphism converts a Scala `Byte` value to a Java `Byte` value, and the `isoColl` isomorphism converts a Scala collection of type `Coll[S]` to a Java collection of type `Coll[J]`.\n\nThe `Iso` class and its related classes are used throughout the `ergo-appkit` project to convert values between Scala and Java types. This is particularly useful when working with the Ergo blockchain, which uses a Java-based scripting language called Sigma. The `Iso` class allows developers to work with Scala types in their code and then convert them to Java types when interacting with the Ergo blockchain.",
      "questions": "1. What is the purpose of the `Iso` class and its subclasses?\n- The `Iso` class and its subclasses define isomorphisms between Scala and Java types, allowing for conversion between the two.\n\n2. What is the purpose of the `IsoLowPriority` class and its implicit values?\n- The `IsoLowPriority` class and its implicit values provide fallback isomorphisms for types that do not have a more specific isomorphism defined.\n\n3. What is the purpose of the `CollIso` class and its `toJava` and `toScala` methods?\n- The `CollIso` class defines an isomorphism between `Coll` collections of Scala and Java types, and its `toJava` and `toScala` methods allow for conversion between the two."
    },
    {
      "fileName": "Utils.scala",
      "filePath": "common/src/main/java/org/ergoplatform/appkit/scalaapi/Utils.scala",
      "url": "https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/scalaapi/Utils.scala",
      "summary": "The `Utils` object provides several utility functions that can be used across the `ergo-appkit` project. \n\nThe `outerJoin` function performs an outer join operation between two maps, `left` and `right`. It takes three projection functions as arguments: `l`, `r`, and `inner`. The `l` function is executed for each element of the `left` map, the `r` function is executed for each element of the `right` map, and the `inner` function is executed for matching items `(K, L)` and `(K, R)` with the same `K`. The function returns a map of `(K, O)` pairs, where each key comes from either the `left` or `right` map and values are produced by the projections. \n\nHere is an example of how to use the `outerJoin` function:\n\n```scala\nval left = Map(\"a\" -> 1, \"b\" -> 2)\nval right = Map(\"b\" -> 3, \"c\" -> 4)\n\nval result = Utils.outerJoin(left, right)(\n  (k, l) => l + 1, \n  (k, r) => r * 2, \n  (k, l, r) => l + r\n)\n\n// result: Map(\"a\" -> 2, \"b\" -> 5, \"c\" -> 8)\n```\n\nThe `mapReduce` function is a performance-optimized deterministic mapReduce primitive. It takes an array `arr` to be mapped to `(K, V)` pairs, a mapper function `m`, and a value reduction function `r`. The function returns a pair of arrays `(keys, values)`, where keys appear in order of their first production by `m` and for each `i => values(i)` corresponds to `keys(i)`. \n\nHere is an example of how to use the `mapReduce` function:\n\n```scala\nval arr = Array(1, 2, 3, 4, 5)\n\nval (keys, values) = Utils.mapReduce(arr, \n  (a: Int) => (a % 2, a), \n  (a: (Int, Int)) => a._1 + a._2\n)\n\n// keys: Array(1, 0)\n// values: Array(9, 6)\n```\n\nThe `mapToArrays` function converts a `Map` to a tuple of arrays, where the first array contains all keys of the map and the second array contains all values of the map. \n\nHere is an example of how to use the `mapToArrays` function:\n\n```scala\nval m = Map(\"a\" -> 1, \"b\" -> 2, \"c\" -> 3)\n\nval (keys, values) = Utils.mapToArrays(m)\n\n// keys: Array(\"a\", \"b\", \"c\")\n// values: Array(1, 2, 3)\n```\n\nThe `IntegralFromExactIntegral` class can adapt an `ExactIntegral` instance to be used where `Integral` is required. It implements the `Integral` trait and provides implementations for all of its methods. \n\nHere is an example of how to use the `IntegralFromExactIntegral` class:\n\n```scala\nimport scalan.math.Rational\n\nval ei = new ExactIntegral[Rational] {\n  override def plus(x: Rational, y: Rational): Rational = x + y\n  override def minus(x: Rational, y: Rational): Rational = x - y\n  override def times(x: Rational, y: Rational): Rational = x * y\n  override def negate(x: Rational): Rational = -x\n  override def fromInt(x: Int): Rational = Rational(x)\n  override def toInt(x: Rational): Int = x.toInt\n  override def toLong(x: Rational): Long = x.toLong\n  override def toFloat(x: Rational): Float = x.toFloat\n  override def toDouble(x: Rational): Double = x.toDouble\n  override def compare(x: Rational, y: Rational): Int = x.compare(y)\n  override def divisionRemainder(x: Rational, y: Rational): Rational = x % y\n  override def quot(x: Rational, y: Rational): Rational = x / y\n}\n\nval integral = new Utils.IntegralFromExactIntegral(ei)\n\nval a = Rational(3, 4)\nval b = Rational(1, 2)\n\nval sum = integral.plus(a, b) // Rational(5, 4)\n```",
      "questions": "1. What does the `outerJoin` function do and how is it used?\n- The `outerJoin` function performs an outer join operation between two maps, with optional projection functions for each map and a third projection function for matching items. It returns a map of (K, O) pairs. It can be used to combine data from two maps based on a common key.\n2. What is the purpose of the `mapReduce` function and how is it different from a regular `map` and `reduce` operation?\n- The `mapReduce` function is a performance-optimized deterministic mapReduce primitive that takes an array and applies a mapper function to produce (K, V) pairs, then reduces the values for each key using a value reduction function. It returns a pair of arrays (keys, values) where keys appear in order of their first production by the mapper function. It is different from a regular `map` and `reduce` operation because it guarantees the order of the keys and values in the output.\n3. What is the purpose of the `IntegralFromExactIntegral` class and how is it used?\n- The `IntegralFromExactIntegral` class can adapt an `ExactIntegral` instance to be used where `Integral` is required. It provides implementations for all `Integral` methods using the corresponding methods from `ExactIntegral`. It can be used to convert between different numeric types with different precision and rounding behavior."
    }
  ],
  "folders": [],
  "summary": "The `.autodoc/docs/json/common/src/main/java/org/ergoplatform/appkit/scalaapi` folder contains utility classes and objects that facilitate the interaction between Scala and Java types in the Ergo Appkit project. These utilities are particularly useful when working with the Ergo blockchain, which uses a Java-based scripting language called Sigma.\n\n`ErgoValueBuilder.scala` provides a helper builder for constructing `ErgoValue` instances, which represent values in the Ergo blockchain. The `buildFor` method simplifies the creation of `ErgoValue` instances by taking a Scala value, an isomorphism, and converting the value to its corresponding Java type. For example:\n\n```scala\nval ergoValue: ErgoValue[java.util.List[java.util.List[java.lang.Integer]]] = ErgoValueBuilder.buildFor(myValue)\n```\n\n`Extensions.scala` offers extension methods for the `Coll` and `CollBuilder` classes, simplifying operations like partitioning, grouping, and reducing. For instance, the `groupBy` method can be used to group UTXOs by their ErgoTree, which is useful for building transactions.\n\n`Iso.scala` defines an isomorphism between Scala and Java types, allowing developers to work with Scala types in their code and convert them to Java types when interacting with the Ergo blockchain. The `Iso` class has several subclasses that implement specific isomorphisms, such as `IdentityIso`, `PrimIso`, `PairIso`, and `CollIso`.\n\n`Utils.scala` provides utility functions that can be used across the Ergo Appkit project. The `outerJoin` function performs an outer join operation between two maps, while the `mapReduce` function is a performance-optimized deterministic mapReduce primitive. The `mapToArrays` function converts a `Map` to a tuple of arrays. The `IntegralFromExactIntegral` class adapts an `ExactIntegral` instance to be used where `Integral` is required.\n\nIn summary, this folder contains utility classes and objects that simplify the interaction between Scala and Java types, as well as provide useful functions for working with collections and maps. These utilities are essential for developers working with the Ergo blockchain and the Ergo Appkit project.",
  "questions": ""
}