[["0",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/appkit/src/main/java/org/ergoplatform/appkit/RestApiErgoClient.java)\n\nThe `RestApiErgoClient` class is an implementation of the `ErgoClient` interface that uses the REST API of an Ergo node for communication. It provides methods for creating instances of the `ErgoClient` interface that are connected to a given node of the Ergo network, with or without an explorer connection.\n\nThe `RestApiErgoClient` constructor takes in the following parameters:\n- `nodeUrl`: the http url to the Ergo node REST API endpoint\n- `networkType`: the type of network (mainnet, testnet) the Ergo node is part of\n- `apiKey`: the api key to authenticate the client\n- `explorerUrl`: an optional http url to the Ergo Explorer REST API endpoint. If null or empty, the client works in the `node only` mode.\n- `httpClientBuilder`: an optional builder used to construct http client instances. If null, a new `OkHttpClient` with default parameters is used.\n\nThe `execute` method takes in a `Function` that operates on a `BlockchainContext` and returns a result of type `T`. It creates a `BlockchainContext` using a `BlockchainContextBuilderImpl` instance that takes in the `NodeAndExplorerDataSourceImpl` instance created by the constructor and the `networkType`. It then applies the given `Function` to the `BlockchainContext` and returns the result.\n\nThe `RestApiErgoClient` class also provides several static factory methods for creating instances of the `ErgoClient` interface:\n- `createWithoutExplorer`: creates a new instance of `ErgoClient` in the `node-only` mode, i.e. connected to a given node of the given network type and not connected to explorer.\n- `create`: creates a new instance of `ErgoClient` connected to a given node of the given network type.\n- `createWithHttpClientBuilder`: creates a new instance of `ErgoClient` connected to a given node of the given network type, with an optional `httpClientBuilder`.\n- `create`: creates a new instance of `ErgoClient` using node configuration parameters and an optional explorerUrl.\n- `createWithHttpClientBuilder`: creates a new instance of `ErgoClient` using node configuration parameters, an optional explorerUrl, and an optional `httpClientBuilder`.\n\nThe `RestApiErgoClient` class also provides a `getDataSource` method that returns the `NodeAndExplorerDataSourceImpl` instance created by the constructor.\n\nOverall, the `RestApiErgoClient` class provides a convenient way to create instances of the `ErgoClient` interface that are connected to a given node of the Ergo network, with or without an explorer connection. It abstracts away the details of creating and configuring the necessary API clients and provides a simple interface for executing operations on the Ergo blockchain.\n## Questions: \n 1. What is the purpose of this code?\n- This code provides an implementation of the ErgoClient interface that uses the REST API of an Ergo node for communication.\n\n2. What are the parameters required to create a new instance of RestApiErgoClient?\n- To create a new instance of RestApiErgoClient, you need to provide the http url to the Ergo node REST API endpoint, the type of network the Ergo node is part of, an api key to authenticate the client, and an optional http url to the Ergo Explorer REST API endpoint.\n\n3. What is the purpose of the execute method in RestApiErgoClient?\n- The execute method in RestApiErgoClient takes a function that operates on a BlockchainContext and returns a result of type T. It creates a new BlockchainContext using the NodeAndExplorerDataSourceImpl and the network type, and applies the function to this context to obtain the result.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/java/org/ergoplatform/appkit/RestApiErgoClient.md"}}],["1",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/appkit/src/main/java/org/ergoplatform/appkit/config/ApiConfig.java)\n\nThe `ApiConfig` class in the `org.ergoplatform.appkit.config` package is responsible for storing the connection parameters for the Ergo node API. It has two private instance variables, `apiUrl` and `apiKey`, which are accessed through public getter methods.\n\nThe `getApiUrl()` method returns the URL of the Ergo node API endpoint. This URL is used to connect to the Ergo node and send requests to it. An example usage of this method would be to retrieve the current block height of the Ergo blockchain:\n\n```java\nApiConfig apiConfig = new ApiConfig();\napiConfig.setApiUrl(\"http://localhost:9052\");\nErgoClient ergoClient = RestApiErgoClient.create(apiConfig);\nint currentHeight = ergoClient.execute(ctx -> ctx.getHeaders().getHeight());\n```\n\nIn this example, an instance of `ApiConfig` is created and its `apiUrl` variable is set to the URL of the Ergo node API endpoint. An `ErgoClient` is then created using the `RestApiErgoClient.create()` method, which takes an instance of `ApiConfig` as an argument. Finally, the `execute()` method is called on the `ErgoClient` instance to retrieve the current block height of the Ergo blockchain.\n\nThe `getApiKey()` method returns the API key used for authentication with the Ergo node API. This key is a secret key whose hash was used in the Ergo node configuration. An example usage of this method would be to authenticate with the Ergo node API:\n\n```java\nApiConfig apiConfig = new ApiConfig();\napiConfig.setApiUrl(\"http://localhost:9052\");\napiConfig.setApiKey(\"mySecretApiKey\");\nErgoClient ergoClient = RestApiErgoClient.create(apiConfig);\nergoClient.execute(ctx -> ctx.getBoxesUnspent());\n```\n\nIn this example, an instance of `ApiConfig` is created and its `apiUrl` and `apiKey` variables are set to the URL of the Ergo node API endpoint and the secret API key, respectively. An `ErgoClient` is then created using the `RestApiErgoClient.create()` method, which takes an instance of `ApiConfig` as an argument. Finally, the `execute()` method is called on the `ErgoClient` instance to retrieve the unspent boxes on the Ergo blockchain, using the authenticated API key.\n## Questions: \n 1. What is the purpose of this class?\n   This class defines the connection parameters for the Ergo node API, including the API URL and API key for authentication.\n\n2. How are the API URL and API key set?\n   The values for the API URL and API key are set through the private instance variables `apiUrl` and `apiKey`, respectively.\n\n3. Can the API URL and API key be modified?\n   It is not clear from this code whether the API URL and API key can be modified after they are initially set. The class only provides getter methods for these values, indicating that they may be read-only.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/java/org/ergoplatform/appkit/config/ApiConfig.md"}}],["2",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/appkit/src/main/java/org/ergoplatform/appkit/config/ErgoNodeConfig.java)\n\nThe `ErgoNodeConfig` class is a part of the `ergo-appkit` project and is used to define the parameters of an Ergo node that will be used by the `ErgoClient`. The `ErgoClient` is a Java library that provides a high-level API for interacting with the Ergo blockchain. \n\nThe `ErgoNodeConfig` class has three private fields: `nodeApi`, `wallet`, and `networkType`. The `nodeApi` field is an instance of the `ApiConfig` class, which defines the connection parameters for the Ergo node's API. The `wallet` field is an instance of the `WalletConfig` class, which defines the parameters for working with the wallet. The `networkType` field is an instance of the `NetworkType` enum, which specifies the expected network type (Mainnet or Testnet).\n\nThe class has three public methods: `getNodeApi()`, `getWallet()`, and `getNetworkType()`. These methods return the values of the corresponding private fields. \n\nThis class can be used to configure an instance of the `ErgoClient` class. For example, to create an instance of the `ErgoClient` that connects to the Testnet Ergo node with the specified API and wallet configurations, the following code can be used:\n\n```\nApiConfig apiConfig = new ApiConfig(\"http://localhost:9053\");\nWalletConfig walletConfig = new WalletConfig(\"testnet\", \"password\");\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(apiConfig, walletConfig, NetworkType.TESTNET);\nErgoClient client = ErgoClient.create(nodeConfig);\n```\n\nIn this example, the `ApiConfig` and `WalletConfig` instances are created with the necessary parameters, and then an instance of the `ErgoNodeConfig` class is created with these instances and the `NetworkType.TESTNET` enum value. Finally, an instance of the `ErgoClient` class is created with the `ErgoNodeConfig` instance. \n\nOverall, the `ErgoNodeConfig` class is an important part of the `ergo-appkit` project that allows developers to configure an instance of the `ErgoClient` class with the necessary parameters to interact with the Ergo blockchain.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a class called `ErgoNodeConfig` that contains parameters for connecting to an Ergo node and working with its wallet.\n\n2. What other classes or files does this code interact with?\n- This code imports the `org.ergoplatform.appkit.NetworkType` class and uses it as a parameter type for the `networkType` field.\n\n3. How can this code be used in a larger project?\n- This code can be used to configure and connect to an Ergo node in a Java-based project that interacts with the Ergo blockchain. Other classes in the `org.ergoplatform.appkit` package may also be used in conjunction with this class.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/java/org/ergoplatform/appkit/config/ErgoNodeConfig.md"}}],["3",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/appkit/src/main/java/org/ergoplatform/appkit/config/ErgoToolConfig.java)\n\nThe `ErgoToolConfig` class is responsible for managing the configuration parameters of the ErgoTool utility. It contains two fields: `node` and `parameters`, which represent the configuration of the Ergo node and the tool parameters, respectively. \n\nThe `getNode()` method returns the `ErgoNodeConfig` object, which contains the configuration parameters of the Ergo node. \n\nThe `getParameters()` method returns a `ToolParameters` object, which is a HashMap of name-value pairs representing the tool parameters. \n\nThe class provides three methods for loading the configuration from a file: `load(Reader reader)`, `load(File file)`, and `load(String fileName)`. The `load(Reader reader)` method takes a `Reader` object as input and returns an `ErgoToolConfig` object created from the file content. The `load(File file)` method takes a `File` object as input and returns an `ErgoToolConfig` object created from the file content. The `load(String fileName)` method takes a `String` object as input, which is the name of the file relative to the current directory. It then resolves the file using `File#getAbsolutePath()` and returns an `ErgoToolConfig` object created from the file content. \n\nThis class can be used in the larger project to manage the configuration parameters of the ErgoTool utility. Developers can use the `load()` methods to load the configuration from a file and then access the configuration parameters using the `getNode()` and `getParameters()` methods. For example, the following code loads the configuration from a file named `config.json` and then gets the node configuration:\n\n```\nErgoToolConfig config = ErgoToolConfig.load(\"config.json\");\nErgoNodeConfig nodeConfig = config.getNode();\n```\n## Questions: \n 1. What is the purpose of the `ErgoToolConfig` class?\n    \n    The `ErgoToolConfig` class is responsible for holding configuration parameters for the ErgoTool utility.\n\n2. What is the purpose of the `load` methods?\n    \n    The `load` methods are used to load configuration data from a file or reader and create an instance of `ErgoToolConfig` with the file content.\n\n3. What is the purpose of the `ToolParameters` class?\n    \n    The `ToolParameters` class represents a section of the configuration with named parameters in the form of a HashMap of Name-Value pairs.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/java/org/ergoplatform/appkit/config/ErgoToolConfig.md"}}],["4",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/appkit/src/main/java/org/ergoplatform/appkit/config/ToolParameters.java)\n\nThe `ToolParameters` class is a subclass of the `HashMap` class and is used to store key-value pairs of tool parameters. This class overrides the `equals`, `hashCode`, and `toString` methods of the `HashMap` class to provide custom implementations.\n\nThe `equals` method checks if the given object is equal to the current object by comparing their classes and calling the `equals` method of the superclass.\n\nThe `hashCode` method returns the hash code of the superclass.\n\nThe `toString` method returns a string representation of the object by calling the `toIndentedString` method and appending it to a string builder.\n\nThe `toIndentedString` method is a private helper method that converts the given object to a string with each line indented by 4 spaces (except the first line).\n\nThis class can be used to store tool parameters in a key-value format and to compare them with other instances of the `ToolParameters` class. For example, if we have two instances of `ToolParameters` called `params1` and `params2`, we can compare them using the `equals` method like this:\n\n```\nif (params1.equals(params2)) {\n    // do something\n}\n```\n\nWe can also print the contents of a `ToolParameters` object using the `toString` method like this:\n\n```\nToolParameters params = new ToolParameters();\nparams.put(\"param1\", \"value1\");\nparams.put(\"param2\", \"value2\");\nSystem.out.println(params.toString());\n```\n\nThis will output:\n\n```\nclass Parameters {\n    {param1=value1, param2=value2}\n}\n```\n\nOverall, the `ToolParameters` class provides a convenient way to store and compare tool parameters in a key-value format.\n## Questions: \n 1. What is the purpose of the `ToolParameters` class?\n    \n    The `ToolParameters` class extends `HashMap<String, String>` and provides methods for overriding `equals`, `hashCode`, and `toString` methods.\n\n2. Why does the `equals` method check if the object is of the same class?\n    \n    The `equals` method checks if the object is of the same class to ensure that the comparison is only done between objects of the same type.\n\n3. What is the purpose of the `toIndentedString` method?\n    \n    The `toIndentedString` method is a private helper method that converts an object to a string with each line indented by 4 spaces, except the first line. It is used by the `toString` method to format the output.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/java/org/ergoplatform/appkit/config/ToolParameters.md"}}],["5",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/appkit/src/main/java/org/ergoplatform/appkit/config/WalletConfig.java)\n\nThe `WalletConfig` class is a part of the `ergo-appkit` project and provides parameters for working with a wallet. The purpose of this class is to store the mnemonic, password, and mnemonic password used for generating keys in the wallet. \n\nThe `getMnemonic()` method returns the mnemonic used for generating keys in the wallet. It is important that this value is the same as the one used by the wallet of the node specified in `ErgoNodeConfig#getNodeApi()`. This ensures that the keys generated by the wallet are compatible with the node's wallet.\n\nThe `getPassword()` method returns the password used by the Ergo node wallet to protect wallet data. An empty or null string value means that no password is set.\n\nThe `getMnemonicPassword()` method returns the password used to protect the mnemonic. By default, this value is the same as the `password` value returned by the `getPassword()` method. \n\nThis class can be used in the larger project to configure the wallet used by the Ergo node. For example, a developer could create an instance of the `WalletConfig` class and set the mnemonic, password, and mnemonic password values to match the values used by the node's wallet. This instance could then be passed to other classes or methods that require access to the wallet configuration. \n\nHere is an example of how the `WalletConfig` class could be used in the larger project:\n\n```\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(...);\nWalletConfig walletConfig = new WalletConfig();\nwalletConfig.setMnemonic(\"example mnemonic\");\nwalletConfig.setPassword(\"example password\");\nwalletConfig.setMnemonicPassword(\"example mnemonic password\");\nnodeConfig.setWalletConfig(walletConfig);\n```\n\nIn this example, an instance of the `ErgoNodeConfig` class is created with some unspecified parameters. An instance of the `WalletConfig` class is also created and its mnemonic, password, and mnemonic password values are set. Finally, the `WalletConfig` instance is passed to the `setWalletConfig()` method of the `ErgoNodeConfig` instance, which configures the node's wallet with the specified values.\n## Questions: \n 1. What is the purpose of this class?\n   - This class contains parameters for working with a wallet in the Ergo platform.\n2. What are the three private variables declared in this class?\n   - The three private variables declared in this class are `mnemonic`, `password`, and `mnemonicPassword`.\n3. What is the difference between `password` and `mnemonicPassword`?\n   - `password` is used to protect wallet data, while `mnemonicPassword` is used to protect the mnemonic (which is used for generation of keys in the wallet). By default, `mnemonicPassword` is the same as `password`.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/java/org/ergoplatform/appkit/config/WalletConfig.md"}}],["6",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/java/org/ergoplatform/appkit/config)\n\nThe `org.ergoplatform.appkit.config` package contains classes responsible for managing the configuration of the Ergo node, wallet, and tool parameters. These classes are essential for setting up and interacting with the Ergo blockchain using the `ErgoClient` class.\n\n`ApiConfig.java` stores the connection parameters for the Ergo node API, including the API URL and the API key. This class is used to configure the `ErgoClient` for connecting to the Ergo node and sending requests. For example, to retrieve the current block height of the Ergo blockchain:\n\n```java\nApiConfig apiConfig = new ApiConfig();\napiConfig.setApiUrl(\"http://localhost:9052\");\nErgoClient ergoClient = RestApiErgoClient.create(apiConfig);\nint currentHeight = ergoClient.execute(ctx -> ctx.getHeaders().getHeight());\n```\n\n`ErgoNodeConfig.java` defines the parameters of an Ergo node, including the API configuration, wallet configuration, and network type (Mainnet or Testnet). This class is used to configure an instance of the `ErgoClient` class. For example, to create an `ErgoClient` that connects to a Testnet Ergo node:\n\n```java\nApiConfig apiConfig = new ApiConfig(\"http://localhost:9053\");\nWalletConfig walletConfig = new WalletConfig(\"testnet\", \"password\");\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(apiConfig, walletConfig, NetworkType.TESTNET);\nErgoClient client = ErgoClient.create(nodeConfig);\n```\n\n`ErgoToolConfig.java` manages the configuration parameters of the ErgoTool utility, including the Ergo node configuration and tool parameters. This class provides methods for loading the configuration from a file and accessing the configuration parameters. For example, to load the configuration from a file and get the node configuration:\n\n```java\nErgoToolConfig config = ErgoToolConfig.load(\"config.json\");\nErgoNodeConfig nodeConfig = config.getNode();\n```\n\n`ToolParameters.java` is a subclass of `HashMap` used to store key-value pairs of tool parameters. This class provides methods for storing, comparing, and printing tool parameters. For example, to compare two instances of `ToolParameters`:\n\n```java\nif (params1.equals(params2)) {\n    // do something\n}\n```\n\n`WalletConfig.java` provides parameters for working with a wallet, including the mnemonic, password, and mnemonic password used for generating keys. This class is used to configure the wallet used by the Ergo node. For example, to set the wallet configuration for an `ErgoNodeConfig` instance:\n\n```java\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(...);\nWalletConfig walletConfig = new WalletConfig();\nwalletConfig.setMnemonic(\"example mnemonic\");\nwalletConfig.setPassword(\"example password\");\nwalletConfig.setMnemonicPassword(\"example mnemonic password\");\nnodeConfig.setWalletConfig(walletConfig);\n```\n\nIn summary, the classes in the `org.ergoplatform.appkit.config` package are essential for configuring and interacting with the Ergo blockchain using the `ErgoClient` class. They provide a convenient way to manage the configuration of the Ergo node, wallet, and tool parameters.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/java/org/ergoplatform/appkit/config/summary.md"}}],["7",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/java/org/ergoplatform/appkit)\n\nThe `RestApiErgoClient` class in the `org.ergoplatform.appkit` package is an implementation of the `ErgoClient` interface that uses the REST API of an Ergo node for communication. It provides a convenient way to create instances of the `ErgoClient` interface that are connected to a given node of the Ergo network, with or without an explorer connection. This class abstracts away the details of creating and configuring the necessary API clients and provides a simple interface for executing operations on the Ergo blockchain.\n\nFor example, to create an instance of `ErgoClient` connected to a Testnet Ergo node:\n\n```java\nApiConfig apiConfig = new ApiConfig(\"http://localhost:9053\");\nWalletConfig walletConfig = new WalletConfig(\"testnet\", \"password\");\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(apiConfig, walletConfig, NetworkType.TESTNET);\nErgoClient client = RestApiErgoClient.create(nodeConfig);\n```\n\nThe `RestApiErgoClient` class also provides several static factory methods for creating instances of the `ErgoClient` interface, such as `createWithoutExplorer`, `create`, and `createWithHttpClientBuilder`. These methods allow developers to create `ErgoClient` instances with different configurations, such as connecting to a node without an explorer connection or using a custom HTTP client builder.\n\nThe `execute` method in the `RestApiErgoClient` class takes in a `Function` that operates on a `BlockchainContext` and returns a result of type `T`. This method is used to perform operations on the Ergo blockchain, such as retrieving the current block height:\n\n```java\nint currentHeight = ergoClient.execute(ctx -> ctx.getHeaders().getHeight());\n```\n\nThe `org.ergoplatform.appkit.config` package contains classes responsible for managing the configuration of the Ergo node, wallet, and tool parameters. These classes are essential for setting up and interacting with the Ergo blockchain using the `ErgoClient` class. For example, the `ApiConfig` class stores the connection parameters for the Ergo node API, while the `ErgoNodeConfig` class defines the parameters of an Ergo node, including the API configuration, wallet configuration, and network type.\n\nIn summary, the `RestApiErgoClient` class and the classes in the `org.ergoplatform.appkit.config` package provide a convenient way to create instances of the `ErgoClient` interface and manage the configuration of the Ergo node, wallet, and tool parameters. They enable developers to easily interact with the Ergo blockchain and perform various operations, such as retrieving the current block height or sending transactions.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/java/org/ergoplatform/appkit/summary.md"}}],["8",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/java/org/ergoplatform)\n\nThe `RestApiErgoClient` class in the `org.ergoplatform.appkit` package is a crucial component of the ergo-appkit project, as it provides an implementation of the `ErgoClient` interface that communicates with an Ergo node using its REST API. This class simplifies the process of creating and configuring instances of the `ErgoClient` interface, allowing developers to easily interact with the Ergo blockchain and perform various operations.\n\nFor instance, to create an `ErgoClient` instance connected to a Testnet Ergo node, you can use the following code snippet:\n\n```java\nApiConfig apiConfig = new ApiConfig(\"http://localhost:9053\");\nWalletConfig walletConfig = new WalletConfig(\"testnet\", \"password\");\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(apiConfig, walletConfig, NetworkType.TESTNET);\nErgoClient client = RestApiErgoClient.create(nodeConfig);\n```\n\nThe `RestApiErgoClient` class also offers several static factory methods, such as `createWithoutExplorer`, `create`, and `createWithHttpClientBuilder`, enabling developers to create `ErgoClient` instances with different configurations, like connecting to a node without an explorer connection or using a custom HTTP client builder.\n\nTo perform operations on the Ergo blockchain, the `execute` method in the `RestApiErgoClient` class is used. This method accepts a `Function` that operates on a `BlockchainContext` and returns a result of type `T`. For example, to retrieve the current block height, you can use the following code:\n\n```java\nint currentHeight = ergoClient.execute(ctx -> ctx.getHeaders().getHeight());\n```\n\nAdditionally, the `org.ergoplatform.appkit.config` package contains classes responsible for managing the configuration of the Ergo node, wallet, and tool parameters. These classes are essential for setting up and interacting with the Ergo blockchain using the `ErgoClient` class. For example, the `ApiConfig` class stores the connection parameters for the Ergo node API, while the `ErgoNodeConfig` class defines the parameters of an Ergo node, including the API configuration, wallet configuration, and network type.\n\nIn conclusion, the `RestApiErgoClient` class and the classes in the `org.ergoplatform.appkit.config` package play a vital role in the ergo-appkit project by providing a convenient way to create instances of the `ErgoClient` interface and manage the configuration of the Ergo node, wallet, and tool parameters. They enable developers to easily interact with the Ergo blockchain and perform various operations, such as retrieving the current block height or sending transactions.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/java/org/ergoplatform/summary.md"}}],["9",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/java/org)\n\nThe `RestApiErgoClient` class in the `org.ergoplatform.appkit` package is a crucial component of the ergo-appkit project, as it provides an implementation of the `ErgoClient` interface that communicates with an Ergo node using its REST API. This class simplifies the process of creating and configuring instances of the `ErgoClient` interface, allowing developers to easily interact with the Ergo blockchain and perform various operations.\n\nFor instance, to create an `ErgoClient` instance connected to a Testnet Ergo node, you can use the following code snippet:\n\n```java\nApiConfig apiConfig = new ApiConfig(\"http://localhost:9053\");\nWalletConfig walletConfig = new WalletConfig(\"testnet\", \"password\");\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(apiConfig, walletConfig, NetworkType.TESTNET);\nErgoClient client = RestApiErgoClient.create(nodeConfig);\n```\n\nThe `RestApiErgoClient` class also offers several static factory methods, such as `createWithoutExplorer`, `create`, and `createWithHttpClientBuilder`, enabling developers to create `ErgoClient` instances with different configurations, like connecting to a node without an explorer connection or using a custom HTTP client builder.\n\nTo perform operations on the Ergo blockchain, the `execute` method in the `RestApiErgoClient` class is used. This method accepts a `Function` that operates on a `BlockchainContext` and returns a result of type `T`. For example, to retrieve the current block height, you can use the following code:\n\n```java\nint currentHeight = ergoClient.execute(ctx -> ctx.getHeaders().getHeight());\n```\n\nAdditionally, the `org.ergoplatform.appkit.config` package contains classes responsible for managing the configuration of the Ergo node, wallet, and tool parameters. These classes are essential for setting up and interacting with the Ergo blockchain using the `ErgoClient` class. For example, the `ApiConfig` class stores the connection parameters for the Ergo node API, while the `ErgoNodeConfig` class defines the parameters of an Ergo node, including the API configuration, wallet configuration, and network type.\n\nIn conclusion, the `RestApiErgoClient` class and the classes in the `org.ergoplatform.appkit.config` package play a vital role in the ergo-appkit project by providing a convenient way to create instances of the `ErgoClient` interface and manage the configuration of the Ergo node, wallet, and tool parameters. They enable developers to easily interact with the Ergo blockchain and perform various operations, such as retrieving the current block height or sending transactions.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/java/org/summary.md"}}],["10",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/java)\n\nThe `RestApiErgoClient` class in the `org.ergoplatform.appkit` package is a crucial component of the ergo-appkit project, as it provides an implementation of the `ErgoClient` interface that communicates with an Ergo node using its REST API. This class simplifies the process of creating and configuring instances of the `ErgoClient` interface, allowing developers to easily interact with the Ergo blockchain and perform various operations.\n\nFor instance, to create an `ErgoClient` instance connected to a Testnet Ergo node, you can use the following code snippet:\n\n```java\nApiConfig apiConfig = new ApiConfig(\"http://localhost:9053\");\nWalletConfig walletConfig = new WalletConfig(\"testnet\", \"password\");\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(apiConfig, walletConfig, NetworkType.TESTNET);\nErgoClient client = RestApiErgoClient.create(nodeConfig);\n```\n\nThe `RestApiErgoClient` class also offers several static factory methods, such as `createWithoutExplorer`, `create`, and `createWithHttpClientBuilder`, enabling developers to create `ErgoClient` instances with different configurations, like connecting to a node without an explorer connection or using a custom HTTP client builder.\n\nTo perform operations on the Ergo blockchain, the `execute` method in the `RestApiErgoClient` class is used. This method accepts a `Function` that operates on a `BlockchainContext` and returns a result of type `T`. For example, to retrieve the current block height, you can use the following code:\n\n```java\nint currentHeight = ergoClient.execute(ctx -> ctx.getHeaders().getHeight());\n```\n\nAdditionally, the `org.ergoplatform.appkit.config` package contains classes responsible for managing the configuration of the Ergo node, wallet, and tool parameters. These classes are essential for setting up and interacting with the Ergo blockchain using the `ErgoClient` class. For example, the `ApiConfig` class stores the connection parameters for the Ergo node API, while the `ErgoNodeConfig` class defines the parameters of an Ergo node, including the API configuration, wallet configuration, and network type.\n\nIn conclusion, the `RestApiErgoClient` class and the classes in the `org.ergoplatform.appkit.config` package play a vital role in the ergo-appkit project by providing a convenient way to create instances of the `ErgoClient` interface and manage the configuration of the Ergo node, wallet, and tool parameters. They enable developers to easily interact with the Ergo blockchain and perform various operations, such as retrieving the current block height or sending transactions.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/java/summary.md"}}],["11",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/ColdErgoClient.scala)\n\nThe code above defines a class called `ColdErgoClient` that extends the `ErgoClient` class. The purpose of this class is to provide a way to interact with the Ergo blockchain in a cold environment, meaning that the private keys are stored offline and not connected to the internet. \n\nThe `ColdErgoClient` class takes two parameters: `networkType` and `params`. `networkType` specifies which Ergo network to connect to (mainnet or testnet), while `params` is an instance of `BlockchainParameters` that contains information about the blockchain, such as the node's address and port number. \n\nThe class has a convenience constructor that takes three parameters: `networkType`, `maxBlockCost`, and `blockVersion`. This constructor creates a new instance of `NodeInfoParameters` with the given `maxBlockCost` and `blockVersion` values, and passes it to the main constructor. \n\nThe `execute` method overrides the same method in the `ErgoClient` class. It takes a `Function` that operates on a `BlockchainContext` and returns a result of type `T`. It creates a new instance of `ColdBlockchainContext` with the given `networkType` and `params`, and applies the given `Function` to it. The result of the `Function` is returned. \n\nThe `getDataSource` method is not implemented and simply returns `null`. \n\nOverall, the `ColdErgoClient` class provides a way to interact with the Ergo blockchain in a cold environment, where private keys are stored offline. It can be used in the larger project to perform transactions and other operations on the blockchain without exposing sensitive information to the internet. \n\nExample usage:\n\n```\nval client = new ColdErgoClient(NetworkType.MAINNET, new BlockchainParameters(\"localhost\", 9052))\nval result = client.execute(ctx => {\n  val wallet = ctx.getWallet\n  val balance = wallet.getBalance\n  balance\n})\nprintln(result)\n```\n## Questions: \n 1. What is the purpose of this code and what does it do?\n- This code defines a class called `ColdErgoClient` which extends `ErgoClient` and provides a convenience constructor for setting `maxBlockCost` and `blockVersion` parameters.\n\n2. What other classes or packages does this code depend on?\n- This code depends on `java.util.function`, `org.ergoplatform.restapi.client`, and `org.ergoplatform.appkit.impl` packages.\n\n3. What is the difference between `execute` and `getDataSource` methods in this class?\n- The `execute` method takes a function that operates on a `BlockchainContext` and returns a result of type `T`, while the `getDataSource` method returns a `BlockchainDataSource` object. However, the implementation of `getDataSource` is not provided and returns `???`.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/scala/org/ergoplatform/appkit/ColdErgoClient.md"}}],["12",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/AppContext.scala)\n\nThe `AppContext` class is a data class that represents the context in which a command is executed in the Ergo platform. It contains all the necessary data to parse and execute a command. The purpose of this class is to provide a convenient way to pass around the context data between different parts of the application.\n\nThe class has several properties that represent different aspects of the context. The `cliApp` property represents the CLI application that created the context. The `commandLineArgs` property contains the arguments passed to the `ErgoTool.main` method. The `console` property represents the console interface to be used during command execution. The `cmdOptions` property contains the options parsed from the command line. The `cmdName` property represents the name of the command to be executed. The `cmdArgs` property contains the arguments taken from the command line (excluding the command name). The `toolConf` property represents the tool configuration read from the file. The `clientFactory` property is a factory method used to create an `ErgoClient` instance if and when it is needed. The `cmdParameters` property represents the parsed and instantiated command parameters.\n\nThe class also has several methods that provide convenient access to different aspects of the context. The `apiUrl` method returns the URL of the Ergo node API endpoint. The `apiKey` method returns the API key used for Ergo node API authentication. The `networkType` method returns the expected network type (Mainnet or Testnet). The `isDryRun` method returns true if the `DryRunOption` is defined in the command line. The `isPrintJson` method returns true if the `PrintJsonOption` is defined in the command line. The `withCmdParameters` method is used to attach parameters to the context.\n\nOverall, the `AppContext` class provides a convenient way to pass around the context data between different parts of the application. It encapsulates all the necessary data and provides convenient methods to access and modify it. This class is an important part of the Ergo platform and is used extensively throughout the application. Here is an example of how the `AppContext` class can be used:\n\n```scala\nval appContext = AppContext(\n  cliApp = myCliApp,\n  commandLineArgs = Seq(\"--option1\", \"value1\", \"--option2\", \"value2\"),\n  console = myConsole,\n  cmdOptions = Map(\"option1\" -> \"value1\", \"option2\" -> \"value2\"),\n  cmdName = \"myCommand\",\n  cmdArgs = Seq(\"arg1\", \"arg2\"),\n  toolConf = myToolConfig,\n  clientFactory = myClientFactory\n)\n\nval apiUrl = appContext.apiUrl\nval apiKey = appContext.apiKey\nval networkType = appContext.networkType\nval isDryRun = appContext.isDryRun\nval isPrintJson = appContext.isPrintJson\n\nval newContext = appContext.withCmdParameters(Seq(\"param1\", \"param2\"))\n```\n## Questions: \n 1. What is the purpose of the `AppContext` class?\n- The `AppContext` class is an application execution context that contains all the data necessary to parse and execute a command.\n\n2. What are the parameters of the `AppContext` class?\n- The parameters of the `AppContext` class include the CLI application that created the context, the command line arguments passed to `ErgoTool.main`, a console interface to be used during command execution, options parsed from the command line, the command name to execute, command args taken from the command line (excluding command name), tool configuration read from the file, a factory method used to create an `ErgoClient` instance, and parsed and instantiated command parameters.\n\n3. What are some of the methods available in the `AppContext` class?\n- Some of the methods available in the `AppContext` class include `apiUrl`, which returns the URL of the Ergo node API endpoint, `apiKey`, which returns the API key used for Ergo node API authentication, `networkType`, which returns the expected network type (Mainnet or Testnet), `isDryRun`, which returns true if the `DryRunOption` is defined in the command line, and `isPrintJson`, which returns true if the `PrintJsonOption` is defined in the command line.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/scala/org/ergoplatform/appkit/cli/AppContext.md"}}],["13",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/CliApplication.scala)\n\nThe code represents a base class for all CLI (Command Line Interface) applications in the Appkit Commands framework. The purpose of this class is to provide a set of methods and properties that can be used by derived classes to create CLI applications. \n\nThe `CliApplication` class contains several methods that are used to parse command-line arguments, load configuration files, and execute commands. The `commands` method returns an array of `CmdDescriptor` objects that represent the commands supported by the application. The `commandsMap` method returns a map of command names to `CmdDescriptor` objects. \n\nThe `run` method is the main entry point for the application. It takes three arguments: `args`, `console`, and `clientFactory`. The `args` argument is an array of strings that represent the command-line arguments passed to the application. The `console` argument is an instance of the `Console` trait that is used to interact with the user. The `clientFactory` argument is a function that creates an instance of the `ErgoClient` class. \n\nThe `run` method does the following steps:\n1. Parses the command-line arguments using the `CmdLineParser.parseOptions` method.\n2. Loads the configuration file using the `loadConfig` method.\n3. Creates an instance of the `AppContext` class.\n4. Parses the command parameters using the `parseCmd` method.\n5. Executes the command using the `Cmd.run` method.\n\nThe `loadConfig` method loads the `ErgoToolConfig` from a file specified either by the command-line option `--conf` or from the default file location. The `parseCmd` method parses the command parameters from the command line using the `AppContext` class and returns a new instance of the command configured with the parsed parameters. \n\nThe `printUsage` method prints usage help to the console for the given command (if defined). If the command is not defined, then it prints basic usage info about all commands. \n\nIn summary, the `CliApplication` class provides a set of methods and properties that can be used by derived classes to create CLI applications. It handles parsing command-line arguments, loading configuration files, and executing commands. It also provides a set of default commands that can be overridden by derived classes.\n## Questions: \n 1. What is the purpose of the `CliApplication` class?\n- The `CliApplication` class is the base class for all CLI applications in the Appkit Commands framework.\n\n2. What steps does the `run` method perform?\n- The `run` method performs the following steps: \n  1. Parse options from the command line.\n  2. Load the config file.\n  3. Create an `AppContext`.\n  4. Parse command parameters.\n  5. Create and execute the command.\n\n3. What is the purpose of the `printUsage` method?\n- The `printUsage` method prints usage help to the console for a given command (if defined) or basic usage info about all commands if the command is not defined.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/scala/org/ergoplatform/appkit/cli/CliApplication.md"}}],["14",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/CmdLineParser.scala)\n\n# `CmdLineParser` in `ergo-appkit`\n\n`CmdLineParser` is a Scala object that provides a method to parse command line arguments and extract options and parameters. It also provides a method to parse the network type from a string.\n\n## `parseOptions`\n\n`parseOptions` takes a sequence of strings as input, which represents the command line arguments. It returns a tuple of two values: a map of options and their values, and a sequence of parameters.\n\nThe method first creates an empty map to store the options and their values. It then creates a mutable buffer and copies the input sequence into it. This buffer is used to extract options and parameters.\n\nThe method then iterates over the buffer and checks if each argument starts with the `CmdOption.Prefix` string, which is `\"--\"`. If an argument starts with this prefix, it is considered an option. The method then looks up the option in the `CmdOption.options` list, which is a list of predefined options. If the option is found, the method checks if it is a flag or not. If it is a flag, the value is set to `\"true\"`. If it is not a flag, the method checks if there is a value for the option in the next argument. If there is no value, an error is thrown. If there is a value, it is added to the map of options, and the value is removed from the buffer.\n\nIf an argument does not start with the `CmdOption.Prefix` string, it is considered a parameter and is left in the buffer.\n\nThe method returns the map of options and their values, and the remaining parameters in the buffer.\n\n## `parseNetwork`\n\n`parseNetwork` takes a string as input, which represents the network type. It returns a `NetworkType` object, which is an enumeration that represents the network type.\n\nThe method checks if the input string is `\"testnet\"` or `\"mainnet\"`. If it is, it returns the corresponding `NetworkType` object. If it is not, an error is thrown.\n\n## Usage\n\n`CmdLineParser` can be used to parse command line arguments in a Scala application. For example, the following code shows how to use `parseOptions` to parse command line arguments and print the options and parameters:\n\n```scala\nobject MyApp {\n  def main(args: Array[String]): Unit = {\n    val (options, params) = CmdLineParser.parseOptions(args)\n    println(\"Options:\")\n    options.foreach { case (name, value) =>\n      println(s\"$name=$value\")\n    }\n    println(\"Parameters:\")\n    params.foreach { param =>\n      println(param)\n    }\n  }\n}\n```\n\nIf the application is run with the following command line arguments:\n\n```\n--conf myconf.json --verbose param1 param2\n```\n\nThe output will be:\n\n```\nOptions:\nconf=myconf.json\nverbose=true\nParameters:\nparam1\nparam2\n```\n## Questions: \n 1. What is the purpose of this code?\n    \n    This code defines a command line parser for extracting options and parameters from the command line arguments passed to the Ergo Appkit CLI.\n\n2. What is the format of the options that can be passed to this command line parser?\n    \n    The options that can be passed to this command line parser start with `--` and are parsed into name-value pairs. Any option with `CmdOption.isFlag == true` is parsed without a value.\n\n3. What is the purpose of the `parseNetwork` method?\n    \n    The `parseNetwork` method takes a string argument representing the network type and returns the corresponding `NetworkType` enum value. If the input string is not a valid network type, it raises a `usageError`.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/scala/org/ergoplatform/appkit/cli/CmdLineParser.md"}}],["15",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/Console.scala)\n\nThe `Console` class is an abstract interface for console interactions, such as print and read operations. It defines methods for printing a string to the output stream, reading a line from the input stream, and reading a password. The `Console` class is implemented by two concrete classes: `MainConsole` and `TestConsole`.\n\nThe `MainConsole` class is a wrapper around the system console and is intended to be used in the `Application.main` method. It provides implementations for the methods defined in the `Console` class using the `System.console()` method to access the system console.\n\nThe `TestConsole` class is a console implementation intended to be used in tests. It takes a `BufferedReader` and a `PrintStream` as input and provides implementations for the methods defined in the `Console` class using these input and output streams.\n\nThe `Console` object provides utility methods for reading a new password from the console. The `readNewPassword` method takes a number of attempts and a `Console` instance as input, along with a code block that requests the user to enter a new password twice. It then compares the two passwords and returns the password as a `SecretString` if they match. If they do not match, it prompts the user to try again up to the specified number of attempts. If the user fails to enter a valid password within the specified number of attempts, it throws a `UsageException`.\n\nThe `Console` object also provides a convenience method `readNewPassword` that takes two prompts as input and uses the `Console` instance from the `AppContext` to read the passwords.\n\nThe `ConsoleException` class is an exception thrown by the `Console` class when incorrect usage is detected.\n\nOverall, the `Console` class and its implementations provide a way to interact with the console in a standardized way, making it easier to write and test console-based applications. The `readNewPassword` method is a useful utility for securely reading passwords from the console.\n## Questions: \n 1. What is the purpose of the `Console` abstract class?\n- The `Console` abstract class defines an interface for console interactions, including print and read operations.\n\n2. What is the purpose of the `readNewPassword` method in the `Console` object?\n- The `readNewPassword` method in the `Console` object provides a secure way to double-enter a new password, allowing the user multiple attempts before failing with an exception.\n\n3. What is the purpose of the `TestConsole` class?\n- The `TestConsole` class is a console implementation to be used in tests, providing methods for printing and reading input/output streams.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/scala/org/ergoplatform/appkit/cli/Console.md"}}],["16",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/HelpCmd.scala)\n\nThe code provided is a part of the ergo-appkit project and is located in the ergotool package. The purpose of this code is to provide a Help command that can be used to print usage help for a given command name. The Help command is implemented as a case class called HelpCmd, which takes three parameters: toolConf, name, and askedCmd. The toolConf parameter is an instance of ErgoToolConfig, which is used to configure the ErgoTool application. The name parameter is the name of the Help command, which is \"help\". The askedCmd parameter is the name of the command for which usage help should be printed.\n\nThe HelpCmd case class implements the run method, which takes an instance of AppContext as a parameter. The AppContext class provides access to the ErgoTool application context, which includes the list of available commands. The HelpCmd case class uses the commandsMap property of the AppContext class to look up the command with the given name. If the command is found, the printUsage method of the command is called to print the usage help. If the command is not found, an error message is printed.\n\nThe HelpCmd object provides a descriptor and parser for the Help command. The descriptor is an instance of the CmdDescriptor class, which provides information about the command, such as its name, syntax, and description. The parser is implemented as the createCmd method, which takes an instance of AppContext as a parameter and returns an instance of the HelpCmd case class. The createCmd method uses the cmdParameters property of the AppContext class to get the name of the command for which usage help should be printed.\n\nOverall, this code provides a useful Help command that can be used to get usage help for any command in the ErgoTool application. For example, to get usage help for the \"send\" command, the user can run the following command:\n\n```\nergotool help send\n```\n\nThis will print the usage help for the \"send\" command.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a HelpCmd class and a HelpCmd object that provide usage help for a given command name in the ergo-appkit project.\n\n2. What dependencies are required for this code to work?\n- This code requires dependencies from the org.ergoplatform.appkit.cli and org.ergoplatform.appkit.commands packages.\n\n3. How is the usage help printed for a given command name?\n- The run method of the HelpCmd class checks if the given command name exists in the commandsMap of the AppContext object and prints its usage help if it exists. Otherwise, it throws a CmdException with an error message.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/scala/org/ergoplatform/appkit/cli/HelpCmd.md"}}],["17",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/Options.scala)\n\nThe code defines a set of classes and objects that represent command-line interface (CLI) options for the Ergo blockchain platform. The `CmdOption` class represents a single option that can be passed to a command-line tool. Each option has a name, a type, a description, and a flag indicating whether it is a boolean option (i.e., it does not have an associated value). The `ConfigOption`, `DryRunOption`, `PrintJsonOption`, and `LimitListOption` objects are instances of `CmdOption` that represent specific options that can be passed to the Ergo CLI tool.\n\nThe `CmdOption` class has two methods: `cmdText` and `helpString`. The `cmdText` method returns the text of the command line with the name of the option, while the `helpString` method returns a string that is printed for this option in the usage help output.\n\nThe `ConfigOption` object represents an option that specifies the path to a configuration file. The file has JSON content corresponding to the `ErgoToolConfig` class. The `DryRunOption` object represents an option that forces the command to report what will be done by the operation without performing the actual operation. This is useful for commands that perform some real-world effects such as sending a transaction to the blockchain. The `PrintJsonOption` object represents an option that forces commands to print objects as formatted JSON instead of rows in a table. The `LimitListOption` object represents an option that specifies a number of items in the output list.\n\nThe `CmdOption` class and its subclasses are used in the Ergo CLI tool to provide a flexible and extensible way to specify options for commands. For example, the `SendCmd` command might use the `DryRunOption` to allow users to preview the effects of sending a transaction before actually sending it. The `CmdOption` class and its subclasses can be used in other projects that require a CLI tool with extensible options. \n\nExample usage:\n\n```\n$ ergo-cli --conf ergo_tool.json --dry-run\n```\n\nThis command runs the Ergo CLI tool with the `ConfigOption` and `DryRunOption` options. The `--conf` option specifies the path to a configuration file, and the `--dry-run` option forces the command to report what will be done by the operation without performing the actual operation.\n## Questions: \n 1. What is the purpose of the `CmdOption` class?\n- The `CmdOption` class represents a CLI option description that can be used in command line to specify parameters to be used by the command during its operation.\n\n2. What is the difference between a regular option and a flag option?\n- A regular option is given using the syntax `--optionName optionValue`, while a flag option is given using the syntax `--optionName` without an `optionValue` part. If a `CmdOption` instance has `isFlag` set to `true`, then such option doesn't have an `optionValue` part and the option is interpreted as Boolean value (`true` if it is present, `false` otherwise).\n\n3. What are some examples of options supported by the `ergo-appkit` application?\n- Some examples of options supported by the `ergo-appkit` application are `ConfigOption` (string option to specify path to a configuration file), `DryRunOption` (flag option to prevent the command to perform actual operation and instead forces it to report planned actions), `PrintJsonOption` (flag option to force commands to print objects as formatted json instead of rows in table), and `LimitListOption` (specifies a number of items in the output list).","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/scala/org/ergoplatform/appkit/cli/Options.md"}}],["18",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/cli/Utils.scala)\n\n# `Utils` Object in `ergo-appkit`\n\nThe `Utils` object in the `ergo-appkit` project is a collection of utility methods that can be used throughout the project. The purpose of this object is to provide a set of common functions that can be used by other parts of the project to simplify code and reduce duplication.\n\nThe `loggedStep` method is one of the utility methods provided by the `Utils` object. This method takes three parameters: a message to print to the console, a `Console` object to use for printing, and a block of code to execute. The method prints the message to the console, executes the block of code, and then prints the status of the step (either \"Ok\" or \"Error\") to the console.\n\nHere is an example of how the `loggedStep` method might be used in the larger project:\n\n```scala\nimport org.ergoplatform.appkit.cli.Utils\n\nval console = new Console // create a new Console object\nval result = Utils.loggedStep(\"Performing step 1\", console) {\n  // code to execute for step 1\n}\n```\n\nIn this example, the `loggedStep` method is used to execute a block of code and print a message to the console. The result of the block of code is stored in the `result` variable.\n\nOverall, the `Utils` object provides a set of common utility methods that can be used throughout the `ergo-appkit` project to simplify code and reduce duplication. The `loggedStep` method is just one example of the many useful functions provided by this object.\n## Questions: \n 1. What is the purpose of the `Utils` object?\n   - The `Utils` object contains utility methods.\n2. What does the `loggedStep` method do?\n   - The `loggedStep` method prints a step description to the console, performs the step, and then finishes the description with the step status.\n3. What is the input and output of the `loggedStep` method?\n   - The input of the `loggedStep` method is a message string and a console object, and the output is the result of the step.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/scala/org/ergoplatform/appkit/cli/Utils.md"}}],["19",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/scala/org/ergoplatform/appkit/cli)\n\nThe `.autodoc/docs/json/appkit/src/main/scala/org/ergoplatform/appkit/cli` folder contains several Scala files that are part of the Ergo platform's command-line interface (CLI) tools. These files provide a framework for creating CLI applications, parsing command-line arguments, handling console interactions, and defining CLI options.\n\n`AppContext.scala` defines a data class that represents the context in which a command is executed. It encapsulates all the necessary data and provides convenient methods to access and modify it. This class is used extensively throughout the application to pass around the context data between different parts of the application.\n\n`CliApplication.scala` provides a base class for all CLI applications in the Appkit Commands framework. It handles parsing command-line arguments, loading configuration files, and executing commands. Derived classes can use the methods and properties provided by this class to create CLI applications.\n\n`CmdLineParser.scala` is a Scala object that provides methods to parse command line arguments and extract options and parameters. It can be used to parse command line arguments in a Scala application, making it easier to handle user input.\n\n`Console.scala` is an abstract interface for console interactions, such as print and read operations. It has two concrete implementations: `MainConsole` for the system console and `TestConsole` for testing purposes. The `Console` object also provides utility methods for securely reading passwords from the console.\n\n`HelpCmd.scala` provides a Help command that can be used to print usage help for a given command name. It is a useful addition to any CLI application, allowing users to get help on how to use specific commands.\n\n`Options.scala` defines a set of classes and objects that represent CLI options for the Ergo blockchain platform. The `CmdOption` class and its subclasses can be used in other projects that require a CLI tool with extensible options.\n\n`Utils.scala` is a collection of utility methods that can be used throughout the project. One example is the `loggedStep` method, which can be used to execute a block of code and print a message to the console.\n\nHere's an example of how these classes might be used together:\n\n```scala\nimport org.ergoplatform.appkit.cli._\n\nobject MyApp extends CliApplication {\n  def main(args: Array[String]): Unit = {\n    val console = new MainConsole\n    val clientFactory = () => new ErgoClient(...)\n    run(args, console, clientFactory)\n  }\n\n  override def commands: Array[CmdDescriptor] = Array(\n    HelpCmd.descriptor,\n    // other command descriptors\n  )\n}\n```\n\nIn this example, a new CLI application is created by extending the `CliApplication` class. The `main` method initializes a `MainConsole` instance, a `clientFactory`, and calls the `run` method with the command-line arguments. The `commands` method is overridden to include the `HelpCmd` descriptor and other command descriptors.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/scala/org/ergoplatform/appkit/cli/summary.md"}}],["20",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/commands/Commands.scala)\n\nThis code defines classes and traits that are used to implement commands for the ErgoTool application. The `Cmd` abstract class is the base class for all commands that can be executed by ErgoTool. It defines methods that return the current tool configuration parameters, the name of the command, the URL of the Ergo blockchain node used to communicate with the network, the API key used for Ergo node API authentication, and the network type (MAINNET or TESTNET) that ErgoTool is expected to communicate with. It also defines a `run` method that executes the command using the given `AppContext`.\n\nThe `RunWithErgoClient` trait can be used to implement commands that need to communicate with the Ergo blockchain. It extends the `Cmd` abstract class and overrides the `run` method to create an `ErgoClient` instance and call the `runWithClient` method with it.\n\nThe `CmdParameter` case class represents a command parameter descriptor. It contains information such as the parameter name, type, description, default value, and whether it is entered interactively or parsed from the command line.\n\nThe `CmdDescriptor` abstract class is the base class for all command descriptors (usually companion objects). It defines the command name used in the command line, the syntax for the command parameters, and a human-readable description of the command. It also defines a `createCmd` method that creates a new command instance based on the given `AppContext`, and a `parseArgs` method that parses the command line arguments into a sequence of parameter values.\n\nThe `CmdArgParser` abstract class is a parser of the command line string. It defines a `parse` method that parses the given raw string into a value of the parameter type.\n\nThe `CmdArgInput` abstract class is an input handler of `CmdParameter`. It defines an `input` method that is called to input the given parameter.\n\nThe `UsageException` case class is an exception thrown by the ErgoTool application when incorrect usage is detected. It contains an error message and an optional descriptor of the command which was incorrectly used.\n\nThe `ErgoToolException` case class is an exception thrown by the ErgoTool application before or after command execution. It contains an error message and an optional cause.\n\nThe `CmdException` case class is an exception thrown by executing `Cmd.run`, wrapping the cause if needed. It contains an error message, the command that threw the exception, and an optional cause.\n## Questions: \n 1. What is the purpose of the `Cmd` class and its methods?\n- The `Cmd` class is a base class for all commands that can be executed by ErgoTool. Its methods include returning the current tool configuration parameters, returning the name of the command, returning the URL of the Ergo blockchain node used to communicate with the network, and running the command using the given `AppContext`.\n\n2. What is the purpose of the `RunWithErgoClient` trait?\n- The `RunWithErgoClient` trait can be used to implement commands that need to communicate with the Ergo blockchain. It provides a default implementation of the `run` method and declares a new method with an additional `ErgoClient` parameter, which is called from the default implementation.\n\n3. What is the purpose of the `CmdParameter` case class and its fields?\n- The `CmdParameter` case class is a descriptor for a command parameter. Its fields include the parameter name, display name, type, description, default value, interactive input, and argument parser. It is used to specify the syntax for a command and to parse its parameters from the command line.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/scala/org/ergoplatform/appkit/commands/Commands.md"}}],["21",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/appkit/src/main/scala/org/ergoplatform/appkit/commands/package.scala)\n\nThe code above defines a package object called \"commands\" within the \"org.ergoplatform.appkit\" package. This package object contains a single method called \"usageError\". \n\nThe purpose of this method is to report usage errors to the ErgoTool. The ErgoTool is a command-line interface (CLI) tool that allows users to interact with the Ergo blockchain. The \"usageError\" method is designed to be called when the user has provided incorrect or invalid input to the ErgoTool. \n\nThe method takes two parameters: \"msg\" and \"cmdDescOpt\". \"msg\" is a string that contains the error message to be displayed to the user. \"cmdDescOpt\" is an optional parameter that contains a CmdDescriptor object. The CmdDescriptor object provides a description of the command that the user was attempting to execute when the error occurred. \n\nIf the \"usageError\" method is called, it will throw a UsageException. The UsageException is a custom exception that is defined elsewhere in the Ergo appkit project. This exception is designed to be caught by the ErgoTool, which will then display the error message to the user. \n\nHere is an example of how the \"usageError\" method might be used in the ErgoTool:\n\n```\nif (args.length < 2) {\n  commands.usageError(\"Not enough arguments provided.\", Some(cmdDescriptor))\n}\n```\n\nIn this example, the ErgoTool is checking to see if the user has provided enough arguments to a particular command. If not, it calls the \"usageError\" method with an appropriate error message and a CmdDescriptor object that describes the command that the user was attempting to execute.\n## Questions: \n 1. What is the purpose of the `commands` package object?\n   - The `commands` package object likely contains utility functions or constants related to the Ergo platform app kit.\n2. What does the `usageError` function do?\n   - The `usageError` function throws a `UsageException` with a given error message and optional command descriptor.\n3. What is the expected use case for the `usageError` function?\n   - The `usageError` function is likely intended to be used by the ErgoTool to report errors related to incorrect usage of the app kit.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/scala/org/ergoplatform/appkit/commands/package.md"}}],["22",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/scala/org/ergoplatform/appkit/commands)\n\nThe `Commands.scala` file in the `org.ergoplatform.appkit.commands` package is responsible for defining the structure and functionality of commands that can be executed by the ErgoTool application. It provides a set of classes and traits that can be extended or implemented to create custom commands for interacting with the Ergo blockchain.\n\nThe `Cmd` abstract class serves as the base class for all commands in ErgoTool. It provides methods for accessing the tool's configuration parameters, the command name, the Ergo node URL, the API key for authentication, and the network type (MAINNET or TESTNET). The `run` method is responsible for executing the command using the provided `AppContext`.\n\nFor commands that need to communicate with the Ergo blockchain, the `RunWithErgoClient` trait can be used. This trait extends the `Cmd` abstract class and overrides the `run` method to create an `ErgoClient` instance, which is then passed to the `runWithClient` method.\n\nTo define command parameters, the `CmdParameter` case class is used. It contains information about the parameter, such as its name, type, description, default value, and whether it is entered interactively or parsed from the command line.\n\nThe `CmdDescriptor` abstract class serves as the base class for command descriptors, which are usually companion objects. It defines the command name, parameter syntax, and a human-readable description. The `createCmd` method is responsible for creating a new command instance based on the given `AppContext`, while the `parseArgs` method parses command line arguments into a sequence of parameter values.\n\nFor parsing command line strings, the `CmdArgParser` abstract class is provided. It defines a `parse` method that takes a raw string and converts it into a value of the parameter type.\n\nThe `CmdArgInput` abstract class is an input handler for `CmdParameter`. It defines an `input` method that is called to input the given parameter.\n\nIn case of incorrect usage or errors during command execution, the `UsageException`, `ErgoToolException`, and `CmdException` case classes are provided. These exceptions contain error messages, optional command descriptors, and optional causes to help developers identify and handle issues.\n\nHere's an example of how to create a custom command using the provided classes and traits:\n\n```scala\nclass MyCommand extends Cmd with RunWithErgoClient {\n  override def name: String = \"my-command\"\n  override def ergoClient: ErgoClient = ...\n  // Implement the runWithClient method\n  override def runWithClient(ergoClient: ErgoClient, appCtx: AppContext): Unit = {\n    // Your command logic here\n  }\n}\n\nobject MyCommand extends CmdDescriptor {\n  override val name: String = \"my-command\"\n  override val description: String = \"A custom command for ErgoTool\"\n  override val syntax: String = \"my-command <param1> <param2>\"\n\n  override def createCmd(appCtx: AppContext): Cmd = new MyCommand\n  override def parseArgs(args: Seq[String]): Seq[CmdParameter] = ...\n}\n```\n\nIn summary, the `Commands.scala` file provides a framework for creating and executing commands in the ErgoTool application. It offers a set of classes and traits that can be extended or implemented to create custom commands for interacting with the Ergo blockchain, handling command parameters, parsing command line arguments, and managing exceptions.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/scala/org/ergoplatform/appkit/commands/summary.md"}}],["23",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/scala/org/ergoplatform/appkit)\n\nThe `org.ergoplatform.appkit` package provides a set of Scala classes and utilities for interacting with the Ergo blockchain. The main class in this package is `ColdErgoClient`, which allows developers to interact with the Ergo blockchain in a cold environment, where private keys are stored offline. This is useful for performing transactions and other operations on the blockchain without exposing sensitive information to the internet.\n\nExample usage of `ColdErgoClient`:\n\n```scala\nval client = new ColdErgoClient(NetworkType.MAINNET, new BlockchainParameters(\"localhost\", 9052))\nval result = client.execute(ctx => {\n  val wallet = ctx.getWallet\n  val balance = wallet.getBalance\n  balance\n})\nprintln(result)\n```\n\nThe `cli` subfolder contains a set of Scala files for creating command-line interface (CLI) tools for the Ergo platform. These files provide a framework for creating CLI applications, parsing command-line arguments, handling console interactions, and defining CLI options. An example of how to create a custom CLI application using these classes is shown below:\n\n```scala\nimport org.ergoplatform.appkit.cli._\n\nobject MyApp extends CliApplication {\n  def main(args: Array[String]): Unit = {\n    val console = new MainConsole\n    val clientFactory = () => new ErgoClient(...)\n    run(args, console, clientFactory)\n  }\n\n  override def commands: Array[CmdDescriptor] = Array(\n    HelpCmd.descriptor,\n    // other command descriptors\n  )\n}\n```\n\nThe `commands` subfolder contains the `Commands.scala` file, which provides a framework for creating and executing commands in the ErgoTool application. It offers a set of classes and traits that can be extended or implemented to create custom commands for interacting with the Ergo blockchain, handling command parameters, parsing command line arguments, and managing exceptions. An example of how to create a custom command using the provided classes and traits is shown below:\n\n```scala\nclass MyCommand extends Cmd with RunWithErgoClient {\n  override def name: String = \"my-command\"\n  override def ergoClient: ErgoClient = ...\n  // Implement the runWithClient method\n  override def runWithClient(ergoClient: ErgoClient, appCtx: AppContext): Unit = {\n    // Your command logic here\n  }\n}\n\nobject MyCommand extends CmdDescriptor {\n  override val name: String = \"my-command\"\n  override val description: String = \"A custom command for ErgoTool\"\n  override val syntax: String = \"my-command <param1> <param2>\"\n\n  override def createCmd(appCtx: AppContext): Cmd = new MyCommand\n  override def parseArgs(args: Seq[String]): Seq[CmdParameter] = ...\n}\n```\n\nIn summary, the `org.ergoplatform.appkit` package and its subfolders provide a set of Scala classes and utilities for interacting with the Ergo blockchain, creating CLI tools, and defining custom commands. These classes can be used in larger projects to perform transactions and other operations on the Ergo blockchain, as well as to create custom CLI applications and commands for interacting with the blockchain.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/scala/org/ergoplatform/appkit/summary.md"}}],["24",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/scala/org/ergoplatform)\n\nThe `org.ergoplatform.appkit` package provides a set of Scala classes and utilities for interacting with the Ergo blockchain. The main class in this package is `ColdErgoClient`, which allows developers to interact with the Ergo blockchain in a cold environment, where private keys are stored offline. This is useful for performing transactions and other operations on the blockchain without exposing sensitive information to the internet.\n\nExample usage of `ColdErgoClient`:\n\n```scala\nval client = new ColdErgoClient(NetworkType.MAINNET, new BlockchainParameters(\"localhost\", 9052))\nval result = client.execute(ctx => {\n  val wallet = ctx.getWallet\n  val balance = wallet.getBalance\n  balance\n})\nprintln(result)\n```\n\nThe `cli` subfolder contains a set of Scala files for creating command-line interface (CLI) tools for the Ergo platform. These files provide a framework for creating CLI applications, parsing command-line arguments, handling console interactions, and defining CLI options. An example of how to create a custom CLI application using these classes is shown below:\n\n```scala\nimport org.ergoplatform.appkit.cli._\n\nobject MyApp extends CliApplication {\n  def main(args: Array[String]): Unit = {\n    val console = new MainConsole\n    val clientFactory = () => new ErgoClient(...)\n    run(args, console, clientFactory)\n  }\n\n  override def commands: Array[CmdDescriptor] = Array(\n    HelpCmd.descriptor,\n    // other command descriptors\n  )\n}\n```\n\nThe `commands` subfolder contains the `Commands.scala` file, which provides a framework for creating and executing commands in the ErgoTool application. It offers a set of classes and traits that can be extended or implemented to create custom commands for interacting with the Ergo blockchain, handling command parameters, parsing command line arguments, and managing exceptions. An example of how to create a custom command using the provided classes and traits is shown below:\n\n```scala\nclass MyCommand extends Cmd with RunWithErgoClient {\n  override def name: String = \"my-command\"\n  override def ergoClient: ErgoClient = ...\n  // Implement the runWithClient method\n  override def runWithClient(ergoClient: ErgoClient, appCtx: AppContext): Unit = {\n    // Your command logic here\n  }\n}\n\nobject MyCommand extends CmdDescriptor {\n  override val name: String = \"my-command\"\n  override val description: String = \"A custom command for ErgoTool\"\n  override val syntax: String = \"my-command <param1> <param2>\"\n\n  override def createCmd(appCtx: AppContext): Cmd = new MyCommand\n  override def parseArgs(args: Seq[String]): Seq[CmdParameter] = ...\n}\n```\n\nIn summary, the `org.ergoplatform.appkit` package and its subfolders provide a set of Scala classes and utilities for interacting with the Ergo blockchain, creating CLI tools, and defining custom commands. These classes can be used in larger projects to perform transactions and other operations on the Ergo blockchain, as well as to create custom CLI applications and commands for interacting with the blockchain.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/scala/org/ergoplatform/summary.md"}}],["25",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/scala/org)\n\nThe `org.ergoplatform.appkit` package provides a set of Scala classes and utilities for interacting with the Ergo blockchain. The main class in this package is `ColdErgoClient`, which allows developers to interact with the Ergo blockchain in a cold environment, where private keys are stored offline. This is useful for performing transactions and other operations on the blockchain without exposing sensitive information to the internet.\n\nExample usage of `ColdErgoClient`:\n\n```scala\nval client = new ColdErgoClient(NetworkType.MAINNET, new BlockchainParameters(\"localhost\", 9052))\nval result = client.execute(ctx => {\n  val wallet = ctx.getWallet\n  val balance = wallet.getBalance\n  balance\n})\nprintln(result)\n```\n\nThe `cli` subfolder contains a set of Scala files for creating command-line interface (CLI) tools for the Ergo platform. These files provide a framework for creating CLI applications, parsing command-line arguments, handling console interactions, and defining CLI options. An example of how to create a custom CLI application using these classes is shown below:\n\n```scala\nimport org.ergoplatform.appkit.cli._\n\nobject MyApp extends CliApplication {\n  def main(args: Array[String]): Unit = {\n    val console = new MainConsole\n    val clientFactory = () => new ErgoClient(...)\n    run(args, console, clientFactory)\n  }\n\n  override def commands: Array[CmdDescriptor] = Array(\n    HelpCmd.descriptor,\n    // other command descriptors\n  )\n}\n```\n\nThe `commands` subfolder contains the `Commands.scala` file, which provides a framework for creating and executing commands in the ErgoTool application. It offers a set of classes and traits that can be extended or implemented to create custom commands for interacting with the Ergo blockchain, handling command parameters, parsing command line arguments, and managing exceptions. An example of how to create a custom command using the provided classes and traits is shown below:\n\n```scala\nclass MyCommand extends Cmd with RunWithErgoClient {\n  override def name: String = \"my-command\"\n  override def ergoClient: ErgoClient = ...\n  // Implement the runWithClient method\n  override def runWithClient(ergoClient: ErgoClient, appCtx: AppContext): Unit = {\n    // Your command logic here\n  }\n}\n\nobject MyCommand extends CmdDescriptor {\n  override val name: String = \"my-command\"\n  override val description: String = \"A custom command for ErgoTool\"\n  override val syntax: String = \"my-command <param1> <param2>\"\n\n  override def createCmd(appCtx: AppContext): Cmd = new MyCommand\n  override def parseArgs(args: Seq[String]): Seq[CmdParameter] = ...\n}\n```\n\nIn summary, the `org.ergoplatform.appkit` package and its subfolders provide a set of Scala classes and utilities for interacting with the Ergo blockchain, creating CLI tools, and defining custom commands. These classes can be used in larger projects to perform transactions and other operations on the Ergo blockchain, as well as to create custom CLI applications and commands for interacting with the blockchain.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/scala/org/summary.md"}}],["26",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main/scala)\n\nThe `.autodoc/docs/json/appkit/src/main/scala` folder contains the `org.ergoplatform.appkit` package, which provides a set of Scala classes and utilities for interacting with the Ergo blockchain. The main class in this package is `ColdErgoClient`, which allows developers to interact with the Ergo blockchain in a cold environment, where private keys are stored offline. This is useful for performing transactions and other operations on the blockchain without exposing sensitive information to the internet.\n\nExample usage of `ColdErgoClient`:\n\n```scala\nval client = new ColdErgoClient(NetworkType.MAINNET, new BlockchainParameters(\"localhost\", 9052))\nval result = client.execute(ctx => {\n  val wallet = ctx.getWallet\n  val balance = wallet.getBalance\n  balance\n})\nprintln(result)\n```\n\nThe `cli` subfolder contains a set of Scala files for creating command-line interface (CLI) tools for the Ergo platform. These files provide a framework for creating CLI applications, parsing command-line arguments, handling console interactions, and defining CLI options. An example of how to create a custom CLI application using these classes is shown below:\n\n```scala\nimport org.ergoplatform.appkit.cli._\n\nobject MyApp extends CliApplication {\n  def main(args: Array[String]): Unit = {\n    val console = new MainConsole\n    val clientFactory = () => new ErgoClient(...)\n    run(args, console, clientFactory)\n  }\n\n  override def commands: Array[CmdDescriptor] = Array(\n    HelpCmd.descriptor,\n    // other command descriptors\n  )\n}\n```\n\nThe `commands` subfolder contains the `Commands.scala` file, which provides a framework for creating and executing commands in the ErgoTool application. It offers a set of classes and traits that can be extended or implemented to create custom commands for interacting with the Ergo blockchain, handling command parameters, parsing command line arguments, and managing exceptions. An example of how to create a custom command using the provided classes and traits is shown below:\n\n```scala\nclass MyCommand extends Cmd with RunWithErgoClient {\n  override def name: String = \"my-command\"\n  override def ergoClient: ErgoClient = ...\n  // Implement the runWithClient method\n  override def runWithClient(ergoClient: ErgoClient, appCtx: AppContext): Unit = {\n    // Your command logic here\n  }\n}\n\nobject MyCommand extends CmdDescriptor {\n  override val name: String = \"my-command\"\n  override val description: String = \"A custom command for ErgoTool\"\n  override val syntax: String = \"my-command <param1> <param2>\"\n\n  override def createCmd(appCtx: AppContext): Cmd = new MyCommand\n  override def parseArgs(args: Seq[String]): Seq[CmdParameter] = ...\n}\n```\n\nIn summary, the `org.ergoplatform.appkit` package and its subfolders provide a set of Scala classes and utilities for interacting with the Ergo blockchain, creating CLI tools, and defining custom commands. These classes can be used in larger projects to perform transactions and other operations on the Ergo blockchain, as well as to create custom CLI applications and commands for interacting with the blockchain.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/scala/summary.md"}}],["27",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src/main)\n\nThe `.autodoc/docs/json/appkit/src/main` folder contains two subfolders, `java` and `scala`, which provide essential classes and utilities for interacting with the Ergo blockchain and creating command-line interface (CLI) tools.\n\nIn the `java` subfolder, the `RestApiErgoClient` class is a key component, as it offers an implementation of the `ErgoClient` interface that communicates with an Ergo node using its REST API. This class simplifies the process of creating and configuring instances of the `ErgoClient` interface, allowing developers to easily interact with the Ergo blockchain and perform various operations. For example, to create an `ErgoClient` instance connected to a Testnet Ergo node, you can use the following code snippet:\n\n```java\nApiConfig apiConfig = new ApiConfig(\"http://localhost:9053\");\nWalletConfig walletConfig = new WalletConfig(\"testnet\", \"password\");\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(apiConfig, walletConfig, NetworkType.TESTNET);\nErgoClient client = RestApiErgoClient.create(nodeConfig);\n```\n\nThe `scala` subfolder contains the `org.ergoplatform.appkit` package, which provides a set of Scala classes and utilities for interacting with the Ergo blockchain. The main class in this package is `ColdErgoClient`, which allows developers to interact with the Ergo blockchain in a cold environment, where private keys are stored offline. This is useful for performing transactions and other operations on the blockchain without exposing sensitive information to the internet.\n\nExample usage of `ColdErgoClient`:\n\n```scala\nval client = new ColdErgoClient(NetworkType.MAINNET, new BlockchainParameters(\"localhost\", 9052))\nval result = client.execute(ctx => {\n  val wallet = ctx.getWallet\n  val balance = wallet.getBalance\n  balance\n})\nprintln(result)\n```\n\nThe `cli` subfolder in the `scala` folder contains a set of Scala files for creating command-line interface (CLI) tools for the Ergo platform. These files provide a framework for creating CLI applications, parsing command-line arguments, handling console interactions, and defining CLI options. An example of how to create a custom CLI application using these classes is shown below:\n\n```scala\nimport org.ergoplatform.appkit.cli._\n\nobject MyApp extends CliApplication {\n  def main(args: Array[String]): Unit = {\n    val console = new MainConsole\n    val clientFactory = () => new ErgoClient(...)\n    run(args, console, clientFactory)\n  }\n\n  override def commands: Array[CmdDescriptor] = Array(\n    HelpCmd.descriptor,\n    // other command descriptors\n  )\n}\n```\n\nIn summary, the `java` and `scala` subfolders in the `.autodoc/docs/json/appkit/src/main` folder provide essential classes and utilities for interacting with the Ergo blockchain, creating CLI tools, and defining custom commands. These classes can be used in larger projects to perform transactions and other operations on the Ergo blockchain, as well as to create custom CLI applications and commands for interacting with the blockchain.","metadata":{"source":".autodoc/docs/markdown/appkit/src/main/summary.md"}}],["28",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit/src)\n\nThe `.autodoc/docs/json/appkit/src` folder contains essential classes and utilities for interacting with the Ergo blockchain and creating command-line interface (CLI) tools. The folder is organized into two subfolders, `java` and `scala`, each providing implementations in their respective languages.\n\nIn the `java` subfolder, the `RestApiErgoClient` class is a key component, as it offers an implementation of the `ErgoClient` interface that communicates with an Ergo node using its REST API. This class simplifies the process of creating and configuring instances of the `ErgoClient` interface, allowing developers to easily interact with the Ergo blockchain and perform various operations. For example, to create an `ErgoClient` instance connected to a Testnet Ergo node, you can use the following code snippet:\n\n```java\nApiConfig apiConfig = new ApiConfig(\"http://localhost:9053\");\nWalletConfig walletConfig = new WalletConfig(\"testnet\", \"password\");\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(apiConfig, walletConfig, NetworkType.TESTNET);\nErgoClient client = RestApiErgoClient.create(nodeConfig);\n```\n\nThe `scala` subfolder contains the `org.ergoplatform.appkit` package, which provides a set of Scala classes and utilities for interacting with the Ergo blockchain. The main class in this package is `ColdErgoClient`, which allows developers to interact with the Ergo blockchain in a cold environment, where private keys are stored offline. This is useful for performing transactions and other operations on the blockchain without exposing sensitive information to the internet.\n\nExample usage of `ColdErgoClient`:\n\n```scala\nval client = new ColdErgoClient(NetworkType.MAINNET, new BlockchainParameters(\"localhost\", 9052))\nval result = client.execute(ctx => {\n  val wallet = ctx.getWallet\n  val balance = wallet.getBalance\n  balance\n})\nprintln(result)\n```\n\nThe `cli` subfolder in the `scala` folder contains a set of Scala files for creating command-line interface (CLI) tools for the Ergo platform. These files provide a framework for creating CLI applications, parsing command-line arguments, handling console interactions, and defining CLI options. An example of how to create a custom CLI application using these classes is shown below:\n\n```scala\nimport org.ergoplatform.appkit.cli._\n\nobject MyApp extends CliApplication {\n  def main(args: Array[String]): Unit = {\n    val console = new MainConsole\n    val clientFactory = () => new ErgoClient(...)\n    run(args, console, clientFactory)\n  }\n\n  override def commands: Array[CmdDescriptor] = Array(\n    HelpCmd.descriptor,\n    // other command descriptors\n  )\n}\n```\n\nIn summary, the `java` and `scala` subfolders in the `.autodoc/docs/json/appkit/src/main` folder provide essential classes and utilities for interacting with the Ergo blockchain, creating CLI tools, and defining custom commands. These classes can be used in larger projects to perform transactions and other operations on the Ergo blockchain, as well as to create custom CLI applications and commands for interacting with the blockchain.","metadata":{"source":".autodoc/docs/markdown/appkit/src/summary.md"}}],["29",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/appkit)\n\nThe `.autodoc/docs/json/appkit` folder contains essential classes and utilities for interacting with the Ergo blockchain and creating command-line interface (CLI) tools. The folder is organized into a `src` subfolder, which is further divided into `java` and `scala` subfolders, each providing implementations in their respective languages.\n\nIn the `java` subfolder, the `RestApiErgoClient` class is a key component, as it offers an implementation of the `ErgoClient` interface that communicates with an Ergo node using its REST API. This class simplifies the process of creating and configuring instances of the `ErgoClient` interface, allowing developers to easily interact with the Ergo blockchain and perform various operations. For example, to create an `ErgoClient` instance connected to a Testnet Ergo node, you can use the following code snippet:\n\n```java\nApiConfig apiConfig = new ApiConfig(\"http://localhost:9053\");\nWalletConfig walletConfig = new WalletConfig(\"testnet\", \"password\");\nErgoNodeConfig nodeConfig = new ErgoNodeConfig(apiConfig, walletConfig, NetworkType.TESTNET);\nErgoClient client = RestApiErgoClient.create(nodeConfig);\n```\n\nThe `scala` subfolder contains the `org.ergoplatform.appkit` package, which provides a set of Scala classes and utilities for interacting with the Ergo blockchain. The main class in this package is `ColdErgoClient`, which allows developers to interact with the Ergo blockchain in a cold environment, where private keys are stored offline. This is useful for performing transactions and other operations on the blockchain without exposing sensitive information to the internet.\n\nExample usage of `ColdErgoClient`:\n\n```scala\nval client = new ColdErgoClient(NetworkType.MAINNET, new BlockchainParameters(\"localhost\", 9052))\nval result = client.execute(ctx => {\n  val wallet = ctx.getWallet\n  val balance = wallet.getBalance\n  balance\n})\nprintln(result)\n```\n\nThe `cli` subfolder in the `scala` folder contains a set of Scala files for creating command-line interface (CLI) tools for the Ergo platform. These files provide a framework for creating CLI applications, parsing command-line arguments, handling console interactions, and defining CLI options. An example of how to create a custom CLI application using these classes is shown below:\n\n```scala\nimport org.ergoplatform.appkit.cli._\n\nobject MyApp extends CliApplication {\n  def main(args: Array[String]): Unit = {\n    val console = new MainConsole\n    val clientFactory = () => new ErgoClient(...)\n    run(args, console, clientFactory)\n  }\n\n  override def commands: Array[CmdDescriptor] = Array(\n    HelpCmd.descriptor,\n    // other command descriptors\n  )\n}\n```\n\nIn summary, the `java` and `scala` subfolders in the `.autodoc/docs/json/appkit/src/main` folder provide essential classes and utilities for interacting with the Ergo blockchain, creating CLI tools, and defining custom commands. These classes can be used in larger projects to perform transactions and other operations on the Ergo blockchain, as well as to create custom CLI applications and commands for interacting with the blockchain.","metadata":{"source":".autodoc/docs/markdown/appkit/summary.md"}}],["30",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/ci/import_gpg.sh)\n\nThis code sets up GPG2 for reading passphrase from parameters. It is used in the larger project to enable secure communication between different components of the system. \n\nThe code first creates a directory called `.gnupg` in the user's home directory and sets its permissions to `700`. It then creates a `gpg.conf` file in the `.gnupg` directory and adds the line `use-agent` to it. This line tells GPG to use the GPG agent for passphrase handling. The code then adds two more lines to the `gpg.conf` file: `pinentry-mode loopback` and `allow-loopback-pinentry`. These lines tell GPG to use a loopback pinentry program for passphrase handling. \n\nNext, the code sets the permissions of all files in the `.gnupg` directory to `600`. This ensures that only the owner of the files can read or write to them. The code then sends the `RELOADAGENT` command to the GPG agent to reload its configuration. \n\nThe code then decodes the GPG signing key from a base64-encoded string stored in an environment variable called `GPG_SIGNING_KEY`. The decoded key is stored in a file called `private.key` in the `.gnupg` directory. Finally, the code imports the key into GPG using the `gpg` command. \n\nThis code is used in the larger project to enable secure communication between different components of the system. For example, it may be used to sign and verify digital signatures on messages exchanged between different components. \n\nExample usage:\n\n```bash\nexport GPG_SIGNING_KEY=base64-encoded-private-key\n./setup-gpg.sh\n```\n## Questions: \n 1. What is the purpose of this script?\n   \n   This script sets up gpg2 for reading passphrase from parameters and imports a private key.\n\n2. What is the significance of the environment variable `GPG_SIGNING_KEY`?\n   \n   The value of the environment variable `GPG_SIGNING_KEY` is a base64-encoded private key that was previously exported and stored as a GitHub repository secret.\n\n3. Why is `pinentry-mode loopback` added to `gpg.conf`?\n   \n   `pinentry-mode loopback` is added to `gpg.conf` to allow GPG to read the passphrase from the command line instead of prompting the user for it in a GUI window.","metadata":{"source":".autodoc/docs/markdown/ci/import_gpg.md"}}],["31",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/ci)\n\nThe `import_gpg.sh` script in the `ergo-appkit` project is responsible for setting up GPG2 for reading passphrase from parameters, which is essential for secure communication between different components of the system. The script performs several tasks to achieve this goal, as detailed below.\n\nFirst, the script creates a directory called `.gnupg` in the user's home directory and sets its permissions to `700`. This ensures that only the owner of the directory can access its contents. Next, it creates a `gpg.conf` file in the `.gnupg` directory and adds the line `use-agent` to it. This line instructs GPG to use the GPG agent for passphrase handling.\n\nThe script then adds two more lines to the `gpg.conf` file: `pinentry-mode loopback` and `allow-loopback-pinentry`. These lines tell GPG to use a loopback pinentry program for passphrase handling, which allows GPG to read the passphrase from parameters instead of prompting the user for input.\n\nAfter configuring GPG, the script sets the permissions of all files in the `.gnupg` directory to `600`, ensuring that only the owner of the files can read or write to them. It then sends the `RELOADAGENT` command to the GPG agent to reload its configuration, ensuring that the changes made to the `gpg.conf` file take effect.\n\nFinally, the script decodes the GPG signing key from a base64-encoded string stored in an environment variable called `GPG_SIGNING_KEY`. The decoded key is stored in a file called `private.key` in the `.gnupg` directory. The script then imports the key into GPG using the `gpg` command.\n\nThis script is crucial for enabling secure communication between different components of the `ergo-appkit` project. For example, it may be used to sign and verify digital signatures on messages exchanged between different components, ensuring the integrity and authenticity of the messages.\n\nTo use this script, you would first need to export your GPG signing key as a base64-encoded string and set it as the value of the `GPG_SIGNING_KEY` environment variable. Then, you can run the script as follows:\n\n```bash\nexport GPG_SIGNING_KEY=base64-encoded-private-key\n./import_gpg.sh\n```\n\nThis will set up GPG2 for reading passphrase from parameters and import your GPG signing key, allowing you to securely communicate with other components of the `ergo-appkit` project.","metadata":{"source":".autodoc/docs/markdown/ci/summary.md"}}],["32",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/Address.java)\n\nThe `Address` class in the `ergo-appkit` project provides a set of methods for working with Ergo addresses. An Ergo address is a string representation of an ErgoTree, which is a script that defines the conditions under which a transaction output can be spent. The `Address` class provides methods for creating, parsing, and manipulating Ergo addresses.\n\nThe `Address` class has a constructor that takes an `ErgoAddress` object and initializes the instance variables `_address`, `_base58String`, and `_addrBytes`. The `_address` variable is the original `ErgoAddress` object, `_base58String` is the base58-encoded string representation of the address, and `_addrBytes` is the byte array representation of the address.\n\nThe `Address` class provides methods for extracting information from an Ergo address. The `getNetworkType()` method returns the `NetworkType` of the address (either `MAINNET` or `TESTNET`). The `isMainnet()` method returns `true` if the address is from the mainnet, and `false` otherwise. The `isP2PK()` method returns `true` if the address is a Pay-to-Public-Key (P2PK) address, and `false` otherwise. The `isP2S()` method returns `true` if the address is a Pay-to-Script (P2S) address, and `false` otherwise.\n\nThe `Address` class also provides methods for extracting the public key from a P2PK address. The `asP2PK()` method returns the underlying `P2PKAddress` object, and the `getPublicKey()` method returns the `DLogProtocol.ProveDlog` object representing the public key. The `getPublicKeyGE()` method returns the `GroupElement` object representing the public key.\n\nThe `Address` class provides methods for converting an Ergo address to an `ErgoContract` object and to a byte array representation of the ErgoTree's proposition bytes. The `toErgoContract()` method returns an `ErgoContract` object representing the address, and the `toPropositionBytes()` method returns the byte array representation of the ErgoTree's proposition bytes.\n\nThe `Address` class also provides methods for creating an `Address` object from a base58-encoded string, from an ErgoTree proposition bytes, and from a mnemonic phrase. The `create()` method creates an `Address` object from a base58-encoded string. The `fromPropositionBytes()` method creates an `Address` object from an ErgoTree proposition bytes. The `fromMnemonic()` method creates an `Address` object from a mnemonic phrase. The `createEip3Address()` method creates an `Address` object from an extended public key using the EIP-3 derivation path.\n\nOverall, the `Address` class provides a set of methods for working with Ergo addresses, including methods for extracting information from an address, converting an address to an `ErgoContract` object or a byte array representation of the ErgoTree's proposition bytes, and creating an `Address` object from various inputs.\n## Questions: \n 1. What is the purpose of the `Address` class?\n- The `Address` class is used to represent an Ergo address and provides methods to extract information from it.\n\n2. What types of Ergo addresses can be represented by the `Address` class?\n- The `Address` class can represent Pay-To-Public-Key (P2PK) and Pay-To-Script (P2S) Ergo addresses.\n\n3. How can an `Address` instance be created from a mnemonic phrase?\n- An `Address` instance can be created from a mnemonic phrase using the `fromMnemonic` method, which takes the network type, mnemonic phrase, and optional password as arguments.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/Address.md"}}],["33",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/AppkitProvingInterpreter.scala)\n\nThe `AppkitProvingInterpreter` class in the `ergo-appkit` project is responsible for holding secrets and signing transactions (i.e., generating proofs). It takes a list of secret keys, dLogInputs, dhtInputs, and ErgoLikeParameters as input. The class extends the `ErgoLikeInterpreter` and `ProverInterpreter` classes.\n\nThe `sign` method takes an unsigned transaction, boxes to spend, data boxes, state context, base cost, and tokens to burn as input. It reduces and signs the transaction, returning a signed transaction and the cost of the transaction. The `reduceTransaction` method takes an unsigned transaction, boxes to spend, data boxes, state context, base cost, and tokens to burn as input. It reduces the inputs of the given unsigned transaction to provable sigma propositions using the given context and returns a new reduced transaction with all inputs reduced and the cost of this transaction.\n\nThe `signReduced` method takes a reduced transaction and base cost as input. It generates spending proofs for each input so that the resulting transaction can be submitted to the blockchain. The `reduce` method takes a script environment, ErgoTree, and context as input. It reduces the given ErgoTree in the given context to a sigma proposition and returns a `ReducedInputData` object containing enough data to sign a transaction without context.\n\nThe `proveReduced` method generates a proof (signature) for the given message using the secrets of the prover. It takes a reduced input, message, and hints bag as input and returns a `ProverResult`.\n\nThe `TokenBalanceException` class is thrown during transaction signing when input tokens are not balanced with output tokens. The `ReducedInputData` class represents data necessary to sign an input of an unsigned transaction. The `ReducedErgoLikeTransaction` class represents a reduced transaction, i.e., an unsigned transaction where each unsigned input is augmented with `ReducedInputData`.\n\nThe `ReducedErgoLikeTransactionSerializer` object is responsible for serializing and deserializing `ReducedErgoLikeTransaction` instances.\n## Questions: \n 1. **Question**: What is the purpose of the `AppkitProvingInterpreter` class?\n   **Answer**: The `AppkitProvingInterpreter` class is responsible for holding secrets and signing transactions (i.e., generating proofs) using those secrets. It takes a list of secret keys, dLogInputs, dhtInputs, and ErgoLikeParameters as input and provides methods to reduce and sign transactions.\n\n2. **Question**: What is the `TokenBalanceException` and when is it thrown?\n   **Answer**: The `TokenBalanceException` is an exception that is thrown during transaction signing when the input tokens are not balanced with the output tokens. It contains information about the token balance difference that caused the error.\n\n3. **Question**: What is the purpose of the `ReducedErgoLikeTransaction` case class?\n   **Answer**: The `ReducedErgoLikeTransaction` case class represents a \"reduced\" transaction, which is an unsigned transaction where each unsigned input is augmented with `ReducedInputData` containing a script reduction result. After an unsigned transaction is reduced, it can be signed without context, allowing it to be serialized and transferred, for example, to a Cold Wallet and signed in an environment where secrets are known.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/AppkitProvingInterpreter.md"}}],["34",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/Bip32Serialization.java)\n\nThe `Bip32Serialization` class provides methods to serialize and deserialize keys according to the BIP-32 standard. This standard defines a hierarchical deterministic wallet structure that allows for the creation of a tree of keys derived from a single seed. This structure is commonly used in cryptocurrency wallets to generate and manage multiple addresses.\n\nThe `serializeExtendedPublicKeyToHex` method takes an `ExtendedSecretKey` object and a `NetworkType` enum as input, and returns a hex-encoded string representing the serialized key. The `serializeExtendedPublicKeyBip32` method performs the same serialization but returns a byte array instead of a string. Both methods use the `eip3DerivationParent` method from the `JavaHelpers` class to derive the parent key of the given master key, which is used to calculate the key's fingerprint and chain code.\n\nThe `parseExtendedPublicKeyFromHex` method takes a hex-encoded string and a `NetworkType` enum as input, and returns an `ExtendedPublicKey` object. This method decodes the hex string into a byte array and passes it to the `parseExtendedPublicKey` method, which performs the deserialization and returns the `ExtendedPublicKey` object.\n\nThe `parseExtendedPublicKey` method takes a byte array and a `NetworkType` enum as input, and returns an `ExtendedPublicKey` object. This method checks that the byte array has the correct length and starts with the expected version bytes, and then constructs and returns the `ExtendedPublicKey` object.\n\nOverall, the `Bip32Serialization` class provides a convenient way to serialize and deserialize keys according to the BIP-32 standard, which is useful for generating and managing multiple addresses in cryptocurrency wallets. Here is an example of how to use these methods:\n\n```\nExtendedSecretKey masterKey = ...; // obtain master key\nNetworkType networkType = NetworkType.MAINNET; // or NetworkType.TESTNET\nString serializedKey = Bip32Serialization.serializeExtendedPublicKeyToHex(masterKey, networkType);\nExtendedPublicKey publicKey = Bip32Serialization.parseExtendedPublicKeyFromHex(serializedKey, networkType);\n```\n## Questions: \n 1. What is the purpose of this code?\n    \n    This code provides methods to serialize and deserialize keys according to the BIP-32 standard for use in address derivation.\n\n2. What is the significance of the `eip3ParentPath` variable?\n    \n    The `eip3ParentPath` variable is used to derive the parent key of the given master key, which is necessary for calculating the fingerprint of the key.\n\n3. What is the difference between `serializeExtendedPublicKeyToHex` and `serializeExtendedPublicKeyBip32` methods?\n    \n    `serializeExtendedPublicKeyToHex` serializes the given master key to a BIP-32 compliant byte array and returns it as a hex-encoded string, while `serializeExtendedPublicKeyBip32` returns the byte array directly.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/Bip32Serialization.md"}}],["35",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/BoxAttachment.java)\n\nThe `BoxAttachment` interface represents an attachment according to EIP-29. It defines methods to get the type of the attachment, the raw value type, the full ErgoValue for the attachment, and an array of registers to use with OutboxBuilder. The `Type` enum defines the different types of attachments, including `MULTI_ATTACHMENT`, `PLAIN_TEXT`, and `UNDEFINED`. \n\nThis code is likely used in the larger project to handle attachments in Ergo transactions. Ergo is a blockchain platform that allows for complex smart contracts, and attachments can be used to include additional data in a transaction. The `BoxAttachment` interface provides a way to interact with these attachments in a standardized way. \n\nFor example, if a developer wanted to create a new attachment type, they could implement the `BoxAttachment` interface and define their own `Type` enum value. They could then use the `getType()` and `getTypeRawValue()` methods to get information about the attachment type, and the `getErgoValue()` method to get the full ErgoValue for the attachment. \n\nOverall, the `BoxAttachment` interface provides a way to work with attachments in Ergo transactions in a standardized way, making it easier for developers to create and use different types of attachments.\n## Questions: \n 1. What is the purpose of this code?\n   - This code defines an interface for representing an attachment according to EIP-29, which includes methods for getting the type, raw value type, ErgoValue, and Outbox registers for the attachment.\n\n2. What is the significance of the MAGIC_BYTES constant?\n   - The MAGIC_BYTES constant is a byte array with the values 0x50, 0x52, and 0x50, which may be used to identify the attachment as being in the correct format.\n\n3. What is the purpose of the Type enum and its methods?\n   - The Type enum defines the possible types of attachments, including MULTI_ATTACHMENT, PLAIN_TEXT, and UNDEFINED. Its methods include toTypeRawValue(), which returns the raw int constant for the attachment type according to EIP-29, and fromTypeRawValue(), which returns the Type object for a given attachment type raw value according to EIP-29.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/BoxAttachment.md"}}],["36",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/BoxAttachmentGeneric.java)\n\nThe `BoxAttachmentGeneric` class is a superclass that represents an attachment according to EIP-29. It is used as a base class for all actual attachment types, as well as representing unknown types. The class has two fields: `attachmentType` and `attachmentContent`. The `attachmentType` field is an integer that represents the type of the attachment, while the `attachmentContent` field is a byte array that contains the content of the attachment.\n\nThe class implements the `BoxAttachment` interface, which defines methods for getting the type of the attachment, getting the raw value of the attachment type, getting the Ergo value of the attachment, and getting the outbox registers for the attachment.\n\nThe `getType()` method returns the type of the attachment as a `Type` object. The `getTypeRawValue()` method returns the raw value of the attachment type as an integer. The `getErgoValue()` method returns the Ergo value of the attachment as an `ErgoValue` object. The `getOutboxRegistersForAttachment()` method returns an array of `ErgoValue` objects that represent the outbox registers for the attachment.\n\nThe class also has a static method `createFromErgoValue()` that creates an attachment object from an Ergo value. The method takes an `ErgoValue` object as a parameter and returns an object representing the attachment. The method first checks that the `ErgoValue` object is of the correct type, then extracts the attachment type and content from the `ErgoValue` object, and finally creates an attachment object of the appropriate type.\n\nOverall, the `BoxAttachmentGeneric` class provides a base implementation for attachments according to EIP-29. It can be extended to create specific attachment types, and can be used to create attachment objects from Ergo values.\n## Questions: \n 1. What is the purpose of this code and what problem does it solve?\n- This code defines a superclass for all attachment types according to EIP-29, which represents unknown types as well. It provides methods to get the attachment type, create an ErgoValue object, and create an attachment object from an ErgoValue object.\n\n2. What are the parameters of the `BoxAttachmentGeneric` constructor and what do they represent?\n- The `BoxAttachmentGeneric` constructor takes two parameters: `attachmentType` (an integer) and `attachmentContent` (a byte array). They represent the type of the attachment and the content of the attachment, respectively.\n\n3. What is the purpose of the `createFromErgoValue` method and what does it return?\n- The `createFromErgoValue` method takes an ErgoValue object as a parameter and returns an object representing the attachment. It checks if the ErgoValue object is of the correct format, extracts the attachment type and content, and creates an attachment object based on the type.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/BoxAttachmentGeneric.md"}}],["37",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/BoxAttachmentMulti.java)\n\nThe `BoxAttachmentMulti` class is a subclass of `BoxAttachmentGeneric` and represents an attachment containing a list of other attachments. This class is used to create and manipulate multi-attachments in the Ergo blockchain. \n\nThe `BoxAttachmentMulti` class has a constructor that takes an array of tuples as an argument. Each tuple contains an integer and a collection of bytes. The constructor validates that the argument is of the correct type and then sets the `attachmentList` field to the provided array of tuples.\n\nThe `BoxAttachmentMulti` class also has a `getAttachment` method that takes an integer as an argument and returns the attachment at that index in the `attachmentList`. Additionally, there is a `getAttachmentCount` method that returns the number of attachments in the `attachmentList`.\n\nFinally, the `BoxAttachmentMulti` class has a static `buildForList` method that takes a list of `BoxAttachment` objects as an argument and returns a new `BoxAttachmentMulti` object. This method creates an array of tuples from the provided list of attachments and then creates a new `BoxAttachmentMulti` object with the array of tuples as the `attachmentList`.\n\nHere is an example of how to use the `BoxAttachmentMulti` class to create a multi-attachment:\n\n```\nList<BoxAttachment> attachments = new ArrayList<>();\nattachments.add(new BoxAttachment(\"attachment1\".getBytes()));\nattachments.add(new BoxAttachment(\"attachment2\".getBytes()));\nBoxAttachmentMulti multiAttachment = BoxAttachmentMulti.buildForList(attachments);\n```\n\nIn this example, we create a list of two `BoxAttachment` objects and then use the `buildForList` method to create a new `BoxAttachmentMulti` object. The resulting `multiAttachment` object contains both attachments and can be attached to a transaction in the Ergo blockchain.\n## Questions: \n 1. What is the purpose of this code and what problem does it solve?\n- This code defines a class called `BoxAttachmentMulti` that represents a multi-attachment box in the Ergo blockchain. It allows for the creation and retrieval of multiple attachments in a single box.\n\n2. What is the format of the attachment content that this code expects?\n- The attachment content needs to be in the format of a collection of pairs, where each pair consists of an integer and a collection of bytes.\n\n3. How can a developer create a new instance of `BoxAttachmentMulti`?\n- A developer can use the `buildForList` method, which takes a list of `BoxAttachment` objects and returns a new `BoxAttachmentMulti` instance that contains all of the attachments in the list.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/BoxAttachmentMulti.md"}}],["38",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/BoxAttachmentPlainText.java)\n\nThe `BoxAttachmentPlainText` class is a part of the `ergo-appkit` project and is used to represent an attachment containing a simple text. This class extends the `BoxAttachmentGeneric` class and adds a `text` field to store the content of the attachment as a string.\n\nThe constructor of this class takes an array of bytes as input, which represents the content of the attachment. It then calls the constructor of the `BoxAttachmentGeneric` class with the attachment type set to `Type.PLAIN_TEXT` and the attachment content set to the input byte array. The `text` field is then initialized by converting the input byte array to a string using the UTF-8 character set.\n\nThe `getText()` method simply returns the `text` field, which contains the content of the attachment as a string.\n\nThe `buildForText()` method is a static factory method that takes a string as input and returns a new instance of the `BoxAttachmentPlainText` class with the attachment content set to the input string. This method first converts the input string to a byte array using the UTF-8 character set and then calls the constructor of the `BoxAttachmentPlainText` class with the byte array as input.\n\nThis class can be used in the larger project to represent attachments containing simple text. For example, if the project needs to attach a message to a transaction, it can create a new instance of the `BoxAttachmentPlainText` class with the message content as input and add it to the transaction's outputs. The `getText()` method can then be used to retrieve the message content from the attachment.\n## Questions: \n 1. What is the purpose of this code?\n   This code defines a class called `BoxAttachmentPlainText` which represents an attachment containing a simple text.\n\n2. What is the difference between `BoxAttachmentPlainText` and `BoxAttachmentGeneric`?\n   `BoxAttachmentPlainText` is a subclass of `BoxAttachmentGeneric` and adds a `text` field and a `getText()` method to represent plain text attachments specifically.\n\n3. How can I create a new instance of `BoxAttachmentPlainText`?\n   You can use the `buildForText()` method, which takes a `String` parameter and returns a new instance of `BoxAttachmentPlainText` with the UTF-8 encoded bytes of the text as the attachment content.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/BoxAttachmentPlainText.md"}}],["39",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/Constants.java)\n\nThe `Constants` class in the `ergo-appkit` project is a simple implementation of a `LinkedHashMap` that is used to store values of named constants for the ErgoScript compiler. The class extends the `LinkedHashMap` class, which means that it inherits all of the methods and properties of the `LinkedHashMap` class. \n\nThe purpose of this class is to provide a convenient way to store and retrieve named constants that can be used in ErgoScript code. The values stored in the `Constants` object can be any object that can be converted to an ErgoScript value. This includes basic data types such as integers, strings, and booleans, as well as more complex objects such as arrays and maps.\n\nOne potential use case for the `Constants` class is in the development of smart contracts for the Ergo blockchain. Smart contracts often require the use of constants that are used throughout the contract code. By storing these constants in a `Constants` object, developers can easily access and modify these values as needed.\n\nHere is an example of how the `Constants` class might be used in a smart contract:\n\n```\nimport org.ergoplatform.appkit.Constants;\n\npublic class MySmartContract {\n  private Constants constants;\n\n  public MySmartContract() {\n    constants = new Constants();\n    constants.put(\"MY_CONSTANT\", 42);\n  }\n\n  public int getMyConstant() {\n    return (int) constants.get(\"MY_CONSTANT\");\n  }\n}\n```\n\nIn this example, a new `Constants` object is created and a constant named `MY_CONSTANT` is added with a value of `42`. The `getMyConstant` method retrieves the value of `MY_CONSTANT` from the `Constants` object and returns it as an integer.\n\nOverall, the `Constants` class provides a simple and convenient way to store and retrieve named constants in ErgoScript code.\n## Questions: \n 1. What is the purpose of this class?\n   \n   This class is used to store values of named constants for ErgoScript compiler.\n\n2. What type of objects can be stored as values in this class?\n   \n   Any objects that are convertible to ErgoScript values can be stored as values in this class.\n\n3. Is there any specific method or class that can be used to convert objects to ErgoScript values?\n   \n   Yes, the `liftAny` method of `SigmaBuilder` can be used to convert any object to an ErgoScript value.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/Constants.md"}}],["40",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/ContextVar.java)\n\nThe `ContextVar` class represents a context variable binding, where an identifier is bound to a value. The identifier is a byte value in the range of 0 to 127, and the value can be of various types, including byte, short, int, long, boolean, BigInteger, ECPoint, GroupElement, SigmaBoolean, AvlTreeData, ErgoBox, and byte array. \n\nThis class is used to attach a context variable binding to each input box of an unsigned transaction. The context variable binding can be used in the context of a smart contract to store and retrieve values. The `ContextVar` class is used in conjunction with the `ContextExtension` class from the `sigmastate.interpreter` package. \n\nThe `ContextVar` class provides methods to get the identifier and value of a context variable binding. It also provides static factory methods to create a `ContextVar` instance with a specific type of value. \n\nFor example, to create a `ContextVar` instance with a boolean value, you can use the following code:\n\n```\nContextVar contextVar = ContextVar.of((byte) 1, true);\n```\n\nThis creates a context variable binding with an identifier of 1 and a boolean value of true. \n\nOverall, the `ContextVar` class provides a way to store and retrieve context variable bindings in the context of a smart contract. It is a useful tool for developers working on the `ergo-appkit` project to build smart contracts on the Ergo blockchain.\n## Questions: \n 1. What is the purpose of this class and how is it used in the Ergo platform?\n   \n   This class represents a context variable binding (id -> value) that can be attached to each input box of the unsigned transaction in the Ergo platform. It is used to store and retrieve values associated with a specific input box.\n\n2. What is the significance of the `ErgoValue` class and how is it used in this code?\n   \n   The `ErgoValue` class is used to represent the value of the context variable in this code. It is a generic class that can hold values of different types, such as integers, booleans, byte arrays, etc. The `ContextVar` class uses this class to store the value associated with a specific context variable.\n\n3. What are some examples of the types of values that can be stored in a `ContextVar` object?\n   \n   Some examples of the types of values that can be stored in a `ContextVar` object include integers, booleans, byte arrays, `ECPoint` objects, `GroupElement` objects, `Values.SigmaBoolean` objects, `AvlTreeData` objects, and `ErgoBox` objects.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/ContextVar.md"}}],["41",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/Eip4Token.java)\n\nThe `Eip4Token` class represents an EIP-4 compliant token, which is a standard for tokens on the Ergo blockchain. This class extends the `ErgoToken` class and adds additional fields and methods specific to EIP-4 tokens. \n\nThe required EIP-4 fields from R4, R5, and R6 are stored as private fields in the class: `name`, `description`, and `decimals`. The optional fields R7, R8, and R9 are stored as `ErgoValue` objects, which can hold any type of Ergo data. \n\nThe class provides several constructors for creating an `Eip4Token` object. The first constructor takes the required fields as well as the optional fields as `ErgoValue` objects. The second constructor takes only the required fields as strings. The third constructor takes all fields as arguments. \n\nThe class provides several methods for accessing the token's fields. `getTokenName()`, `getTokenDescription()`, and `getDecimals()` return the values of the required fields. `getAmountFormatted()` returns the token amount taking decimals into account. `getAssetType()` returns the type of asset this token represents, which is an enum value of `AssetType`. \n\nThe class also provides several methods for working with the optional fields. `getR7ByteArrayOrNull()` returns the byte content of register R7, or `null` if not set. `isNftAssetType()` returns `true` if this is an NFT token asset type according to EIP-4. `getNftContentHash()` returns the SHA256 content hash for NFT types, or `null` for non-NFT types. `getNftContentLink()` and `getNftCoverImageLink()` return the content link and cover image link for NFT types if available, otherwise `null`. \n\nFinally, the class provides several methods for getting the values of the token's registers for use in creating a token minting box. `getMintingBoxR4()`, `getMintingBoxR5()`, and `getMintingBoxR6()` return the values of registers R4, R5, and R6 as `ErgoValue` objects. `getMintingBoxR7()`, `getMintingBoxR8()`, and `getMintingBoxR9()` return the values of registers R7, R8, and R9 as `ErgoValue` objects, or `null` if not needed. \n\nOverall, the `Eip4Token` class provides a convenient way to work with EIP-4 compliant tokens on the Ergo blockchain. It can be used in conjunction with the `Eip4TokenBuilder` class to create and manage tokens.\n## Questions: \n 1. What is the purpose of this code?\n- This code represents an EIP-4 compliant token and provides methods to retrieve information about the token, such as its name, description, and decimals.\n\n2. What is the significance of the optional fields r7, r8, and r9?\n- These fields represent the contents of registers 7, 8, and 9, respectively, as specified in the EIP-4 specification. They are optional and can be null.\n\n3. What is the purpose of the AssetType enum?\n- The AssetType enum represents the different types of assets that an EIP-4 compliant token can optionally represent. It provides a method to retrieve the magic bytes associated with each asset type.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/Eip4Token.md"}}],["42",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/ErgoAuthUtils.java)\n\nThe `ErgoAuthUtils` class is a utility class that provides a method for verifying an ErgoAuthResponse. ErgoAuth is a protocol for authentication and authorization on the Ergo blockchain. The `verifyResponse` method takes in four parameters: `sigmaProp`, `originalMessage`, `signedMessage`, and `signature`. \n\nThe `sigmaProp` parameter is a Sigma proposition that needs to be fulfilled for signing the message. The `originalMessage` parameter is the original message sent in the ErgoAuthRequest and needs to be contained in the `signedMessage`. The `signedMessage` parameter is the message signed by the client. Finally, the `signature` parameter is the signature for the `signedMessage`.\n\nThe `verifyResponse` method first checks if the `signedMessage` contains the `originalMessage`. If it does not, the method returns `false` indicating that the verification has failed. If the `signedMessage` contains the `originalMessage`, the method calls the `verifySignature` method from the `Signature` class to verify the signature. The `verifySignature` method takes in three parameters: `sigmaProp`, `signedMessage`, and `signature`. The `signedMessage` is converted to a byte array using the UTF-8 character set before being passed to the `verifySignature` method.\n\nThis utility class can be used in the larger ErgoAuth protocol implementation to verify the authenticity of a response from a client. For example, if a client sends a request to access a resource on the Ergo blockchain, the server can respond with an ErgoAuthResponse that includes a signed message. The client can then use the `verifyResponse` method to verify the authenticity of the response before accessing the requested resource.\n\nExample usage:\n\n```\nSigmaProp sigmaProp = new SigmaProp(\"pk:3f5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d\");\nString originalMessage = \"Access granted to resource X\";\nString signedMessage = \"Access granted to resource X, signed by client\";\nbyte[] signature = // client's signature for signedMessage\n\nboolean isVerified = ErgoAuthUtils.verifyResponse(sigmaProp, originalMessage, signedMessage, signature);\nif (isVerified) {\n    // access resource X\n} else {\n    // authentication failed\n}\n```\n## Questions: \n 1. What is EIP-28 ErgoAuth and how does it relate to this code?\n- EIP-28 ErgoAuth is not explained in this code, but this code provides helper utilities for it.\n2. What is the purpose of the `verifyResponse` method and how is it used?\n- The `verifyResponse` method takes in a Sigma proposition, an original message, a signed message, and a signature, and returns a boolean indicating whether verification is successful. It is likely used to verify the authenticity of a message sent by a client.\n3. What is the format of the signature parameter in the `verifyResponse` method?\n- The signature parameter is a byte array, but it is not explained what format the signature should be in or how it is generated.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/ErgoAuthUtils.md"}}],["43",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/ErgoClientException.java)\n\nThe code above defines a custom exception class called `ErgoClientException`. This class extends the `RuntimeException` class, which means that it is an unchecked exception. This exception is typically thrown from the library code of the `ergo-appkit` project.\n\nThe purpose of this exception is to provide a way for the library code to handle and propagate errors that occur during runtime. When an error occurs, the root cause exception is caught and wrapped in an instance of `ErgoClientException`. This allows the library code to provide more meaningful error messages to the user, while still preserving the original exception information.\n\nHere is an example of how this exception might be used in the larger project:\n\n```java\ntry {\n    // some code that may throw an exception\n} catch (Exception e) {\n    throw new ErgoClientException(\"An error occurred while performing some operation\", e);\n}\n```\n\nIn this example, the `try` block contains some code that may throw an exception. If an exception is thrown, it is caught in the `catch` block. The `ErgoClientException` is then thrown, with the original exception passed as the cause. This allows the user to see a more descriptive error message, while still being able to access the original exception information if needed.\n\nOverall, the `ErgoClientException` class is an important part of the error handling mechanism in the `ergo-appkit` project. It allows the library code to handle and propagate errors in a more meaningful way, which can help users to diagnose and fix issues more easily.\n## Questions: \n 1. What is the purpose of the `ErgoClientException` class?\n    \n    The `ErgoClientException` class is an exception class that is typically thrown from the library code of the `ergoplatform.appkit` project. It is used to wrap root cause exceptions that are caught by the library code.\n\n2. When would an instance of `ErgoClientException` be thrown?\n    \n    An instance of `ErgoClientException` would be thrown when an error occurs in the library code of the `ergoplatform.appkit` project and a root cause exception is caught and wrapped in this class.\n\n3. What parameters does the constructor of `ErgoClientException` take?\n    \n    The constructor of `ErgoClientException` takes two parameters: a `String` message and a `Throwable` cause. The message parameter is used to provide a description of the exception, while the cause parameter is used to specify the root cause exception that triggered the `ErgoClientException`.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/ErgoClientException.md"}}],["44",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/ErgoContract.java)\n\nThe code above defines an interface called `ErgoContract` which represents an ErgoScript contract. An ErgoScript contract is a program that defines the rules for spending a UTXO (unspent transaction output) on the Ergo blockchain. The `ErgoContract` interface provides methods to access the information needed to compile an ErgoScript contract into an `ErgoTree` object, which can be used to create a transaction output on the Ergo blockchain.\n\nThe `ErgoContract` interface has five methods. The `getConstants()` method returns a `Constants` object that contains the named constants used in the contract. The `getErgoScript()` method returns the source code of the ErgoScript contract as a string. The `substConstant(String name, Object value)` method creates a new contract by substituting the constant with the given name with a new value. The `getErgoTree()` method returns the `ErgoTree` object that represents the compiled contract. Finally, the `toAddress()` method returns the base58 encoded address that represents the contract.\n\nThe `ErgoContract` interface is used in the larger `ergo-appkit` project to represent ErgoScript contracts. Developers can use this interface to create, modify, and compile ErgoScript contracts. For example, a developer could create a new contract by implementing the `ErgoContract` interface and providing the necessary information, such as the source code and named constants. The developer could then use the `getErgoTree()` method to compile the contract into an `ErgoTree` object, which can be used to create a transaction output on the Ergo blockchain.\n\nHere is an example of how the `ErgoContract` interface could be used to create a new contract:\n\n```\n// Define named constants\nConstants constants = new ConstantsBuilder()\n    .item(\"maxAge\", 100)\n    .item(\"minAge\", 50)\n    .build();\n\n// Define source code\nString ergoScript = \"HEIGHT < maxAge && HEIGHT > minAge\";\n\n// Create new contract\nErgoContract contract = new MyErgoContract(constants, ergoScript);\n\n// Compile contract into ErgoTree\nValues.ErgoTree ergoTree = contract.getErgoTree();\n\n// Get contract address\nAddress address = contract.toAddress();\n```\n\nIn this example, we define two named constants (`maxAge` and `minAge`) and a source code that checks if the current block height is between `maxAge` and `minAge`. We then create a new contract by implementing the `ErgoContract` interface and passing in the constants and source code. We can then compile the contract into an `ErgoTree` object and get the contract address.\n## Questions: \n 1. What is the purpose of the `ErgoContract` interface?\n- The `ErgoContract` interface represents an ErgoScript contract using source code and named constants, and provides methods to retrieve information about the contract and create new instances with substituted constants.\n\n2. What is the `getErgoTree()` method used for?\n- The `getErgoTree()` method returns the underlying `Values.ErgoTree` used by the contract, which can be used to execute the contract on the Ergo blockchain.\n\n3. How does the `toAddress()` method work?\n- The `toAddress()` method returns the base58 encoded address that represents the contract, which can be used to send Ergs (the native currency of the Ergo blockchain) to the contract or to execute the contract via a transaction on the blockchain.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/ErgoContract.md"}}],["45",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/ErgoId.java)\n\nThe `ErgoId` class in the `org.ergoplatform.appkit` package is used to represent the identifier of an Ergo object that wraps a byte array, typically a 256-bit hash. The purpose of this class is to provide a way to compare and manipulate these identifiers in the context of the larger Ergo platform.\n\nThe class has a single constructor that takes a byte array as an argument and assigns it to a private field `_idBytes`. The `getBytes()` method returns the underlying byte array, while the `toString()` method returns a string representation of the identifier using Base16 encoding. The `create()` method is a static factory method that takes a Base16 string and returns a new `ErgoId` instance.\n\nThe `hashCode()` and `equals()` methods are overridden to support equality of `ErgoId` instances. The `hashCode()` method returns the hash code of the underlying byte array using the `Arrays.hashCode()` method. The `equals()` method first checks if the argument is null or the same instance, and then checks if it is an instance of `ErgoId` and has the same byte array as the current instance.\n\nOverall, the `ErgoId` class provides a simple and efficient way to represent and compare identifiers of Ergo objects in the larger Ergo platform. Here is an example of how it can be used:\n\n```\nbyte[] idBytes = new byte[] {0x01, 0x23, 0x45, 0x67};\nErgoId id1 = new ErgoId(idBytes);\nErgoId id2 = ErgoId.create(\"01234567\");\nassert id1.equals(id2);\n```\n## Questions: \n 1. What is the purpose of the ErgoId class?\n    \n    Answer: The ErgoId class is an identifier of an Ergo object that wraps a byte array, usually a 256-bit hash, and supports equality.\n\n2. How does the ErgoId class handle equality?\n    \n    Answer: The ErgoId class overrides the equals() method to compare the byte arrays of two ErgoId objects for equality, and the hashCode() method to return the hash code of the byte array.\n\n3. What is the purpose of the create() method in the ErgoId class?\n    \n    Answer: The create() method is a static factory method that creates a new ErgoId object from a string representation of the id using Base16 encoding.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/ErgoId.md"}}],["46",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/ErgoToken.java)\n\nThe `ErgoToken` class represents an Ergo token (also known as an asset) paired with its value. It is used to store information about a token, such as its ID and value, and can be used as a key for maps and sets. \n\nThe class has three constructors, each of which takes an ID and a value. The first constructor takes an `ErgoId` object and a `long` value, the second constructor takes a byte array and a `long` value, and the third constructor takes a string and a `long` value. The `ErgoId` object represents the ID of the token, which is a unique identifier for the token on the Ergo blockchain. The `long` value represents the value of the token, which is the number of tokens that are being represented.\n\nThe class has two getter methods, `getId()` and `getValue()`, which return the ID and value of the token, respectively.\n\nThe class also overrides three methods: `hashCode()`, `equals()`, and `toString()`. The `hashCode()` method returns a hash code for the `ErgoToken` object based on the hash codes of its ID and value. The `equals()` method checks if the given object is an `ErgoToken` object and if its ID and value are equal to the ID and value of the current object. The `toString()` method returns a string representation of the `ErgoToken` object in the format \"ErgoToken(ID, value)\".\n\nThis class is likely used in the larger `ergo-appkit` project to represent Ergo tokens and their values in various contexts, such as in transactions or in token-related queries to the Ergo blockchain. For example, the `ErgoToken` class may be used to represent the tokens being transferred in a transaction, or to represent the tokens held by a particular Ergo address. \n\nHere is an example of how the `ErgoToken` class might be used to create a new token object:\n\n```\nErgoId tokenId = new ErgoId(\"1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\");\nlong tokenValue = 1000000;\nErgoToken token = new ErgoToken(tokenId, tokenValue);\n```\n## Questions: \n 1. What is the purpose of the `ErgoToken` class?\n    \n    The `ErgoToken` class represents an ergo token (or asset) paired with its value, and implements equality. It can be used as keys for maps and sets.\n\n2. What are the parameters of the `ErgoToken` constructor?\n    \n    The `ErgoToken` constructor takes an `ErgoId` object and a `long` value as parameters. It also has two overloaded constructors that take a `byte[]` or a `String` as the first parameter and a `long` value as the second parameter.\n\n3. How does the `ErgoToken` class implement equality?\n    \n    The `ErgoToken` class overrides the `hashCode()` and `equals()` methods to implement equality. Two `ErgoToken` objects are considered equal if their `ErgoId` and `long` value are equal.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/ErgoToken.md"}}],["47",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/ErgoTreeTemplate.java)\n\n# ErgoTreeTemplate\n\nThe `ErgoTreeTemplate` class represents an ErgoTree instance with placeholders. Each placeholder has an index and type and can be substituted with a constant of the appropriate type. This class is part of the `ergo-appkit` project.\n\n## Purpose\n\nThe purpose of this class is to provide a way to create an ErgoTree template with placeholders that can be substituted with constants of the appropriate type. The template can be used to create new ErgoTrees with new values for all parameters of the template.\n\n## Usage\n\nTo use this class, you can create an instance of `ErgoTreeTemplate` from an `ErgoTree` instance using the `fromErgoTree` method. You can also create an instance from an `ErgoTree` byte array using the `fromErgoTreeBytes` method.\n\n```java\nValues.ErgoTree ergoTree = ...;\nErgoTreeTemplate template = ErgoTreeTemplate.fromErgoTree(ergoTree);\n```\n\nYou can specify which ErgoTree constants will be used as template parameters using the `withParameterPositions` method. This method takes an array of zero-based indexes in the `ErgoTree.constants` array which can be substituted as parameters using the `applyParameters` method.\n\n```java\nint[] positions = {0, 1};\ntemplate.withParameterPositions(positions);\n```\n\nYou can get the serialized bytes of the template using the `getBytes` method. You can also get the template bytes encoded as a Base16 string using the `getEncodedBytes` method.\n\n```java\nbyte[] bytes = template.getBytes();\nString encodedBytes = template.getEncodedBytes();\n```\n\nYou can get the number of parameters in the template using the `getParameterCount` method. You can also get the types of all template parameters using the `getParameterTypes` method.\n\n```java\nint count = template.getParameterCount();\nList<ErgoType<?>> types = template.getParameterTypes();\n```\n\nYou can get the value of a parameter using the `getParameterValue` method. This method takes a 0-based index of the parameter in the range of [0, getParameterCount()).\n\n```java\nErgoValue<?> value = template.getParameterValue(0);\n```\n\nYou can create a new ErgoTree with new values for all parameters of the template using the `applyParameters` method. This method takes an array of new values for all parameters.\n\n```java\nErgoValue<?>[] newValues = {value1, value2};\nValues.ErgoTree newTree = template.applyParameters(newValues);\n```\n\n## Conclusion\n\nThe `ErgoTreeTemplate` class provides a way to create an ErgoTree template with placeholders that can be substituted with constants of the appropriate type. The template can be used to create new ErgoTrees with new values for all parameters of the template.\n## Questions: \n 1. What is the purpose of the `ErgoTreeTemplate` class?\n- The `ErgoTreeTemplate` class represents an ErgoTree template with placeholders that can be substituted with a constant of the appropriate type.\n\n2. What is the purpose of the `withParameterPositions` method?\n- The `withParameterPositions` method specifies which ErgoTree constants will be used as template parameters by taking zero-based indexes in `ErgoTree.constants` array which can be substituted as parameters using the `applyParameters` method.\n\n3. What is the purpose of the `applyParameters` method?\n- The `applyParameters` method creates a new ErgoTree with new values for all parameters of this template by replacing all its parameters with the new values.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/ErgoTreeTemplate.md"}}],["48",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/ErgoType.java)\n\nThe `ErgoType` class is a Java-friendly wrapper around the `RType` type descriptor in the ErgoScript language. It provides a runtime representation of ErgoScript types, which can be used to create instances of these types and perform operations on them. \n\nThe class contains a set of static methods that create instances of `ErgoType` for various ErgoScript types, such as `Byte`, `Short`, `Integer`, `Long`, `Boolean`, `BigInt`, `Unit`, `GroupElement`, `SigmaProp`, `AvlTree`, `Box`, `Header`, and `PreHeader`. These methods return pre-defined instances of `ErgoType` for each type, which can be used to create instances of these types and perform operations on them. \n\nFor example, to create an instance of the `Box` type, you can use the `boxType()` method:\n\n```\nErgoType<Box> boxType = ErgoType.boxType();\n```\n\nThe class also provides two additional static methods: `pairType()` and `collType()`. The `pairType()` method creates an instance of `ErgoType` for a tuple of two types, while the `collType()` method creates an instance of `ErgoType` for a collection of a specific type. \n\nFor example, to create an instance of `ErgoType` for a tuple of `Int` and `Boolean` types, you can use the `pairType()` method:\n\n```\nErgoType<Integer> intType = ErgoType.integerType();\nErgoType<Boolean> boolType = ErgoType.booleanType();\nErgoType<Tuple2<Integer, Boolean>> pairType = ErgoType.pairType(intType, boolType);\n```\n\nOverall, the `ErgoType` class provides a convenient way to work with ErgoScript types in Java code. It allows developers to create instances of ErgoScript types and perform operations on them without having to deal with the low-level details of the ErgoScript language.\n## Questions: \n 1. What is the purpose of the `ErgoType` class?\n- The `ErgoType` class is a Java-friendly wrapper around the `RType` type descriptor, which represents the runtime representation of ErgoScript types.\n\n2. What are some examples of ErgoScript types that can be represented by an `ErgoType` instance?\n- Examples of ErgoScript types that can be represented by an `ErgoType` instance include `Byte`, `Short`, `Integer`, `Long`, `Boolean`, `BigInt`, `Unit`, `GroupElement`, `SigmaProp`, `AvlTree`, `Box`, `Header`, and `PreHeader`.\n\n3. How can a developer create a new `ErgoType` instance for a custom type?\n- A developer can create a new `ErgoType` instance for a custom type by calling the `ofRType` static method and passing in an `RType` instance that represents the custom type.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/ErgoType.md"}}],["49",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/ErgoValue.java)\n\nThe `ErgoValue` class is a representation of any valid value of the ErgoScript language. It is equipped with an `ErgoType` descriptor that describes the type of the value. This class provides methods to encode the value as a Base16 hex string, get the value and type, and create new instances of `ErgoValue` for different types of values.\n\nThe `toHex()` method transforms the value into a `Values.ConstantNode` of sigma, serializes the constant into a byte array using `sigmastate.serialization.ConstantSerializer`, and encodes the bytes using Base16 encoder into a string. This method is useful for serialization and transmission of ErgoScript values.\n\nThe `of()` methods create new instances of `ErgoValue` for different types of values. For example, `of(byte value)` creates an `ErgoValue` instance for a byte value, `of(short value)` creates an instance for a short value, and so on. There are also methods for creating instances of `ErgoValue` for `BigInt`, `GroupElement`, `SigmaProp`, `AvlTree`, `Box`, and collections of values.\n\nThe `fromHex(String hex)` method creates an `ErgoValue` instance from a hex-encoded serialized byte array of Constant values. This method is useful for deserialization of ErgoScript values.\n\nOverall, the `ErgoValue` class is an important part of the ErgoScript language and provides a convenient way to represent and manipulate ErgoScript values in Java. It can be used in the larger project to serialize and deserialize ErgoScript values, create new instances of ErgoScript values, and manipulate ErgoScript values in various ways.\n## Questions: \n 1. What is the purpose of the `ErgoValue` class?\n- The `ErgoValue` class is used to represent any valid value of ErgoScript language and comes equipped with an `ErgoType` descriptor.\n\n2. What is the `toHex()` method used for?\n- The `toHex()` method is used to encode an `ErgoValue` as a Base16 hex string. It transforms the value into a `Values.ConstantNode` of sigma, serializes the constant into a byte array using `sigmastate.serialization.ConstantSerializer`, and encodes the bytes using Base16 encoder into a string.\n\n3. How can an `ErgoValue` be created from hex encoded serialized bytes of Constant values?\n- An `ErgoValue` can be created from hex encoded serialized bytes of Constant values by using the `fromHex()` method. The method takes a string obtained as hex encoding of serialized `ConstantNode` and returns a new deserialized `ErgoValue` instance.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/ErgoValue.md"}}],["50",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/ExtendedInputBox.scala)\n\nThe `ExtendedInputBox` class is a data structure that represents an input box in the Ergo blockchain. An input box is an ErgoBox that is used as an input to a transaction. The `ExtendedInputBox` class pairs an `ErgoBox` instance with a set of context variables, which are necessary to satisfy the box's guarding proposition. The context variables are stored in a `ContextExtension` object.\n\nThe `ExtendedInputBox` class has two properties: `box` and `extension`. The `box` property is an instance of the `ErgoBox` class, which represents the input box. The `extension` property is a set of context variables that are necessary to satisfy the box's guarding proposition. The `extension` property is stored in a `ContextExtension` object.\n\nThe `ExtendedInputBox` class has one method: `toUnsignedInput`. This method returns an `UnsignedInput` object, which represents the input box as an unsigned input in a transaction. The `UnsignedInput` object is created using the input box's ID and the context variables stored in the `ContextExtension` object.\n\nThis class is used in the larger Ergo blockchain project to represent input boxes in transactions. It allows developers to easily pair an input box with the necessary context variables and create an unsigned input for a transaction. Here is an example of how this class might be used in a transaction:\n\n```scala\nval inputBox = new ErgoBox(...)\nval contextVars = new ContextExtension(...)\nval extendedInputBox = ExtendedInputBox(inputBox, contextVars)\nval unsignedInput = extendedInputBox.toUnsignedInput\n```\n\nIn this example, a new `ErgoBox` object is created to represent the input box. A new `ContextExtension` object is also created to store the necessary context variables. The `ExtendedInputBox` class is then used to pair the input box with the context variables. Finally, the `toUnsignedInput` method is called to create an unsigned input for the transaction.\n## Questions: \n 1. What is the purpose of the `ExtendedInputBox` class?\n   - The `ExtendedInputBox` class represents an input `ErgoBox` paired with context variables necessary to satisfy the box's guarding proposition in a transaction.\n2. What is the `toUnsignedInput` method used for?\n   - The `toUnsignedInput` method is used to convert an `ExtendedInputBox` instance into an `UnsignedInput` instance, which is used in a signed transaction.\n3. What is the significance of the `extension` parameter in the `ExtendedInputBox` constructor?\n   - The `extension` parameter represents a set of context variables necessary to satisfy the box's guarding proposition, and is also saved in the corresponding `Input` instance of the signed transaction.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/ExtendedInputBox.md"}}],["51",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/InputBoxesSelectionException.java)\n\nThe `InputBoxesSelectionException` class is a custom exception that can be thrown in the `ergo-appkit` project. It extends the `RuntimeException` class, which means that it is an unchecked exception that does not need to be declared in a method's throws clause. \n\nThis class has four nested classes that extend `InputBoxesSelectionException`. Each of these nested classes represents a specific type of error that can occur during the selection of input boxes for a transaction. \n\nThe `InputBoxLimitExceededException` is thrown when the maximum number of input boxes has been set, but it does not cover the amount of ERG and/or tokens to be sent. This exception contains information about the remaining amount of ERG and tokens, as well as the box limit.\n\nThe `NotEnoughCoinsForChangeException` is thrown when a change box is needed, but the ERG amount in all input boxes is not enough to create the change box.\n\nThe `NotEnoughErgsException` is thrown when the required amount of ERG was not found in all available input boxes. This exception contains information about the balance found in the input boxes.\n\nThe `NotEnoughTokensException` is thrown when the required amount of a specific token was not found in all available input boxes. This exception contains information about the token balances found in the input boxes.\n\nThese exceptions can be used to handle errors that occur during the selection of input boxes for a transaction. For example, if the `NotEnoughErgsException` is thrown, the application can inform the user that they do not have enough ERG to complete the transaction and prompt them to add more funds to their wallet. \n\nHere is an example of how the `NotEnoughErgsException` can be caught and handled:\n\n```\ntry {\n    // code that selects input boxes for a transaction\n} catch (InputBoxesSelectionException e) {\n    if (e instanceof NotEnoughErgsException) {\n        NotEnoughErgsException ex = (NotEnoughErgsException) e;\n        System.out.println(\"Not enough ERG to complete transaction. Balance found: \" + ex.balanceFound);\n        // prompt user to add more funds to their wallet\n    } else {\n        // handle other types of exceptions\n    }\n}\n```\n## Questions: \n 1. What is the purpose of the `InputBoxesSelectionException` class?\n    \n    The `InputBoxesSelectionException` class is a custom exception that is thrown when there is an error in selecting input boxes for a transaction.\n\n2. What are the different types of exceptions that can be thrown by this class and when are they thrown?\n    \n    The different types of exceptions that can be thrown by this class are `InputBoxLimitExceededException`, `NotEnoughCoinsForChangeException`, `NotEnoughErgsException`, and `NotEnoughTokensException`. They are thrown in different scenarios such as when the maximum amount of input boxes is exceeded, when there are not enough coins to create a change box, when there are not enough ERG or tokens in the available boxes, etc.\n\n3. What are the variables that can be accessed from the `InputBoxLimitExceededException` and `NotEnoughTokensException` classes?\n    \n    The `InputBoxLimitExceededException` class has three variables that can be accessed: `remainingAmount`, `remainingTokens`, and `boxLimit`. The `NotEnoughTokensException` class has one variable that can be accessed: `tokenBalances`.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/InputBoxesSelectionException.md"}}],["52",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/JavaHelpers.scala)\n\nThe code in this file is part of the Ergo Appkit library, which provides a set of utilities and abstractions for building Ergo applications. The main focus of this code is to define isomorphisms between different types, which are used for type-safe conversions between Java and Scala data types, as well as between Ergo representations and generated API representations.\n\nThe `Iso` trait is the main abstraction for isomorphisms, with methods `to` and `from` for converting between types A and B. There are also utility classes and objects for composing and inverting isomorphisms, such as `InverseIso`, `ComposeIso`, and the `Iso` object itself.\n\nThe code also provides a set of implicit isomorphisms for common data types, such as `jbyteToByte`, `jshortToShort`, `jintToInt`, `jlongToLong`, and `jboolToBool`. These isomorphisms are used to convert between Java and Scala primitive types.\n\nAdditionally, the code defines isomorphisms for more complex types, such as Ergo tokens, Ergo types, and Ergo values. These isomorphisms are used to convert between Ergo platform-specific types and their corresponding API representations.\n\nSome utility functions and implicit classes are provided for working with Ergo data types, such as `StringExtensions`, `UniversalConverter`, and `JavaHelpers`. These utilities include functions for decoding base16 strings, creating Ergo addresses, compiling ErgoScript code, and working with Ergo tokens and registers.\n\nOverall, this code serves as a foundation for building Ergo applications by providing type-safe conversions and utilities for working with Ergo data types and representations.\n## Questions: \n 1. **What is the purpose of the `Iso` class and its subclasses?**\n\n   The `Iso` class represents isomorphisms between two types `A` and `B`. It is used to define type-full conversions between different data types, such as conversions between Java and Scala data types or between Ergo representations and generated API representations. The subclasses `InverseIso` and `ComposeIso` provide functionality for inverting and composing isomorphisms, respectively.\n\n2. **How does the `JavaHelpers` object help with conversions between Java and Scala data types?**\n\n   The `JavaHelpers` object provides implicit classes and methods to facilitate conversions between Java and Scala data types. It includes methods for converting between Java Lists and Scala IndexedSeq or Coll, as well as methods for converting between different numeric types, strings, and other data structures.\n\n3. **What is the purpose of the `extractAssets` method in the `JavaHelpers` object?**\n\n   The `extractAssets` method takes a set of boxes (ErgoBoxCandidate instances) as input and extracts a mapping of assets to their total amount. It checks the amounts of assets in the boxes, ensuring that they are positive, and then summarizes and groups their corresponding amounts. The method returns a tuple containing the mapping from asset id to total balance and the total number of assets.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/JavaHelpers.md"}}],["53",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/Mnemonic.java)\n\nThe `Mnemonic` class in the `ergo-appkit` project is used to generate and validate BIP39 mnemonic sentences. A BIP39 mnemonic sentence is a list of words that can be used to generate a seed for a cryptocurrency wallet. The seed can then be used to generate private keys for the wallet. \n\nThe `Mnemonic` class has several methods that can be used to generate and validate BIP39 mnemonic sentences. The `generate` method generates a new mnemonic sentence with the given language identifier and strength parameters. The `generateEnglishMnemonic` method generates a new mnemonic sentence using English words and default strength parameters. The `checkEnglishMnemonic` method can be used to validate a given mnemonic sentence. The `toEntropy` method converts a mnemonic word list to the original entropy value. The `toSeed` method generates a seed from the mnemonic sentence and password.\n\nThe `Mnemonic` class has two constructors. The first constructor takes a phrase and password as arguments. The second constructor takes a `SecretString` phrase and password as arguments. Both constructors create a new `Mnemonic` instance with the given phrase and password.\n\nThe `Mnemonic` class has two getter methods, `getPhrase` and `getPassword`, that return the secret mnemonic phrase and password stored in the `Mnemonic` instance.\n\nOverall, the `Mnemonic` class is an important part of the `ergo-appkit` project as it provides a way to generate and validate BIP39 mnemonic sentences. These sentences are used to generate seeds for cryptocurrency wallets, which are then used to generate private keys for the wallets.\n## Questions: \n 1. What is the purpose of this code?\n- This code provides a class for generating and validating BIP39 mnemonic sentences.\n\n2. What is the significance of the `DEFAULT_STRENGTH` constant?\n- `DEFAULT_STRENGTH` is the default number of bits used for the strength of mnemonic security.\n\n3. What is the purpose of the `toEntropy` method?\n- The `toEntropy` method converts a mnemonic word list to its original entropy value, which can be used to validate a given mnemonic sentence.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/Mnemonic.md"}}],["54",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/MnemonicValidationException.java)\n\nThe `MnemonicValidationException` class is a custom exception class that is used to handle errors that may occur during the validation of a mnemonic phrase. A mnemonic phrase is a sequence of words that can be used to generate a cryptographic key. This class is part of the `ergo-appkit` project and is used to validate the mnemonic phrases used in the project.\n\nThe `MnemonicValidationException` class extends the `Exception` class, which is the base class for all exceptions in Java. It has two constructors, one with no arguments and one that takes a message string as an argument. The message string is used to provide additional information about the exception.\n\nThe `MnemonicValidationException` class also has three nested classes that extend it: `MnemonicEmptyException`, `MnemonicWrongListSizeException`, and `MnemonicChecksumException`. These classes are used to handle specific types of errors that may occur during the validation of a mnemonic phrase.\n\nThe `MnemonicEmptyException` class is thrown when an argument to the `MnemonicCode` is empty. The `MnemonicWrongListSizeException` class is thrown when an argument to the `MnemonicCode` is of the wrong list size. The `MnemonicChecksumException` class is thrown when a list of `MnemonicCode` words fails the checksum check.\n\nThe `MnemonicWordException` class is also a nested class that extends `MnemonicValidationException`. It is thrown when a word is encountered that is not in the `MnemonicCode`'s word list. This class contains a `badWord` field that contains the word that was not found in the word list.\n\nOverall, the `MnemonicValidationException` class is an important part of the `ergo-appkit` project as it provides a way to handle errors that may occur during the validation of a mnemonic phrase. By using this class, developers can ensure that their code is robust and can handle errors gracefully. Here is an example of how this class can be used:\n\n```\ntry {\n    Mnemonic.checkEnglishMnemonic(mnemonicWords);\n} catch (MnemonicValidationException e) {\n    // Handle the exception here\n}\n```\n## Questions: \n 1. What is the purpose of this code?\n    \n    This code defines a set of exceptions that can be raised when validating a mnemonic phrase in the Ergo Platform appkit.\n\n2. What are the different types of exceptions that can be raised?\n    \n    There are four different types of exceptions that can be raised: `MnemonicEmptyException`, `MnemonicWrongListSizeException`, `MnemonicChecksumException`, and `MnemonicWordException`.\n\n3. What information is contained in the `MnemonicWordException` exception?\n    \n    The `MnemonicWordException` exception contains the word that was not found in the word list that is being used to validate the mnemonic phrase.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/MnemonicValidationException.md"}}],["55",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/NetworkType.java)\n\nThe code defines an enumeration called `NetworkType` that represents the different network types defined by the Ergo specification of `ErgoAddress`. The `ErgoAddress` class is used to represent an address on the Ergo blockchain. The `NetworkType` enumeration has two values: `MAINNET` and `TESTNET`, which represent the mainnet and testnet networks respectively.\n\nEach value in the enumeration has two fields: `networkPrefix` and `verboseName`. The `networkPrefix` field is a byte code that is used in Ergo addresses to identify the network type. The `verboseName` field is a string that provides a human-readable name for the network type as reported by the Node API.\n\nThe `NetworkType` enumeration also has a constructor that takes two arguments: `networkPrefix` and `verboseName`. This constructor is used to initialize the fields of each value in the enumeration.\n\nFinally, the `NetworkType` enumeration has a static method called `fromValue` that takes a string argument and returns the corresponding `NetworkType` value. This method is used to convert a string representation of a network type to the corresponding `NetworkType` value.\n\nThis code is used in the larger project to provide a way to represent the different network types supported by the Ergo blockchain. It allows developers to specify the network type when working with Ergo addresses and to convert between string representations of network types and the corresponding `NetworkType` values. For example, a developer could use the `fromValue` method to convert a string representation of a network type to the corresponding `NetworkType` value, and then use the `networkPrefix` field of the `NetworkType` value to construct an `ErgoAddress` object with the correct network prefix.\n## Questions: \n 1. What is the purpose of this code?\n   - This code defines an enumeration of network types for the Ergo blockchain and provides methods for converting between the network type's verbose name and its network prefix code used in Ergo addresses.\n\n2. What are the possible values for the `NetworkType` enumeration?\n   - The possible values are `MAINNET` and `TESTNET`, which correspond to the mainnet and testnet network types, respectively.\n\n3. How can a developer use this code in their project?\n   - A developer can use this code to interact with the Ergo blockchain by creating and manipulating Ergo addresses. They can also use the `fromValue` method to convert a verbose network name to its corresponding `NetworkType` value.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/NetworkType.md"}}],["56",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/Parameters.java)\n\nThe `Parameters` class in the `ergo-appkit` project contains a set of global parameters that are used by the Appkit library. These parameters are constants that are used throughout the project to ensure consistency and to simplify the code.\n\nThe first set of parameters, `MinerRewardDelay_Mainnet` and `MinerRewardDelay_Testnet`, are used to determine the number of blocks a miner must wait before they can spend the block reward. This is a part of the Ergo protocol and cannot be changed.\n\nThe second parameter, `OneErg`, is used to define the conversion rate between Erg and NanoErg. One Erg is equal to 10^9 NanoErg.\n\nThe third parameter, `MinFee`, is the minimum transaction fee in NanoErgs as defined by the Ergo protocol. This value is used to ensure that transactions are processed correctly and that the network is not overloaded with low-value transactions.\n\nThe fourth parameter, `MinChangeValue`, is the minimum value for a change output. If the computed change is less than this value, it is added to the fee and the change output is not added to the transaction. This helps to prevent dust outputs and ensures that transactions are processed efficiently.\n\nThe fifth parameter, `ColdClientMaxBlockCost`, is the maximum block cost for a cold client. This value is used to limit the amount of resources that a cold client can use when processing blocks.\n\nThe final parameter, `ColdClientBlockVersion`, is the activated version for a cold client. This value is used to ensure that the cold client is using the correct version of the Ergo protocol.\n\nOverall, the `Parameters` class provides a set of constants that are used throughout the `ergo-appkit` project to ensure consistency and to simplify the code. These parameters are an important part of the Ergo protocol and are used to ensure that transactions are processed correctly and efficiently.\n## Questions: \n 1. What is the purpose of this Parameters class?\n- The Parameters class contains global parameters used by the Appkit library.\n\n2. What is the significance of the MinerRewardDelay_Mainnet and MinerRewardDelay_Testnet variables?\n- These variables represent the number of blocks a miner should wait before being able to spend block rewards on the mainnet and testnet, respectively.\n\n3. What is the purpose of the MinChangeValue variable?\n- The MinChangeValue variable represents the minimum value for a change output in a transaction. If the computed change is less than this value, it is added to the fee and the change output is not added to the transaction.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/Parameters.md"}}],["57",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/ScalaHelpers.java)\n\nThe `ScalaHelpers` class in the `ergo-appkit` project provides a set of helper methods for converting between Scala and Java data types. Specifically, the `collByteToByteArray` method converts a `Coll<Byte>` type (defined in Scala) into a `byte[]` array (defined in Java). \n\nThe reason for this method is that directly calling Scala code from Java is not possible due to a compile error that expects a `Coll<Object>` type instead of the `Coll<Byte>` type defined in Scala. To work around this issue, the `byteColl` parameter is recast to a `Coll` type, which introduces a compiler warning. By defining this conversion method in a single place, it avoids having to repeat this workaround throughout the project.\n\nThis method can be used in the larger project to convert between `Coll<Byte>` and `byte[]` types as needed. For example, if a Scala method returns a `Coll<Byte>` type and a Java method requires a `byte[]` array, this method can be used to perform the conversion. \n\nHere is an example usage of the `collByteToByteArray` method:\n\n```\nimport org.ergoplatform.appkit.ScalaHelpers;\nimport special.collection.Coll;\n\n// create a Coll<Byte> object\nColl<Byte> byteColl = Colls.fromArray(new Byte[]{1, 2, 3});\n\n// convert Coll<Byte> to byte[] array\nbyte[] byteArray = ScalaHelpers.collByteToByteArray(byteColl);\n```\n\nIn this example, a `Coll<Byte>` object is created with three bytes. The `collByteToByteArray` method is then called with this object as the parameter, and the resulting `byte[]` array is stored in the `byteArray` variable. \n\nOverall, the `ScalaHelpers` class provides a useful set of conversion methods for working with Scala and Java data types in the `ergo-appkit` project.\n## Questions: \n 1. What is the purpose of the `ScalaHelpers` class?\n    \n    The `ScalaHelpers` class contains a set of Scala/Java conversion helper methods that need to be written in Java.\n\n2. Why is there a need for the `collByteToByteArray` method?\n    \n    The `collByteToByteArray` method is needed to convert `Coll<Byte>` type into `byte[]` Bytearray. Directly calling Scala code is not possible due to compile error, so a recast is introduced which introduces a compiler warning.\n\n3. What is the role of the `JavaHelpers$.MODULE$` in the `collByteToByteArray` method?\n    \n    The `JavaHelpers$.MODULE$` is used to call the `collToByteArray` method defined in the `JavaHelpers` class. It is necessary to use this syntax because `JavaHelpers` is a Scala object, not a Java class.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/ScalaHelpers.md"}}],["58",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/SecretStorage.java)\n\nThe `SecretStorage` class in the `ergo-appkit` project provides a way to store a mnemonic phrase in an encrypted file that can be accessed using a password. The class provides methods to lock and unlock the storage, get the underlying storage file, get the extended secret key, and get the address for a given network type. \n\nThe `SecretStorage` class has a constructor that takes a `JsonSecretStorage` object as a parameter. The `JsonSecretStorage` class is responsible for storing and retrieving the encrypted mnemonic phrase. The `SecretStorage` class provides a layer of abstraction over the `JsonSecretStorage` class, making it easier to use in the larger project.\n\nThe `SecretStorage` class provides two methods to unlock the storage: `unlock(SecretString encryptionPass)` and `unlock(String encryptionPass)`. Both methods take an encryption password as a parameter. The `SecretString` class is used to represent a string that should be kept secret. The `unlock(SecretString encryptionPass)` method calls the `unlock` method of the `JsonSecretStorage` object with the `SecretString` object converted to an `Interface4JSecretString` object. The `unlock(String encryptionPass)` method calls the `unlock(SecretString encryptionPass)` method with a `SecretString` object created from the string parameter.\n\nThe `SecretStorage` class provides two static methods to create a new `SecretStorage` object: `createFromMnemonicIn` and `loadFrom`. The `createFromMnemonicIn` method initializes the storage with the seed derived from an existing mnemonic phrase. The method takes the secret directory, the mnemonic phrase, the encryption password, and a boolean flag indicating whether to use the incorrect(previous) BIP32 derivation. The `loadFrom` method loads an existing `SecretStorage` object from a file.\n\nHere is an example of how to use the `SecretStorage` class to unlock the storage and get the address for the testnet:\n\n```\nSecretStorage secretStorage = SecretStorage.loadFrom(\"secret-storage.json\");\nsecretStorage.unlock(\"my-password\");\nAddress address = secretStorage.getAddressFor(NetworkType.TESTNET);\n```\n\nIn this example, the `loadFrom` method is used to load the `SecretStorage` object from the `secret-storage.json` file. The `unlock` method is called with the password \"my-password\" to unlock the storage. The `getAddressFor` method is called with the `NetworkType.TESTNET` parameter to get the address for the testnet.\n## Questions: \n 1. What is the purpose of this code?\n- This code provides encrypted storage of a mnemonic phrase in a file that can be accessed using a password.\n\n2. What dependencies does this code have?\n- This code has dependencies on the Ergo Platform library, Scala runtime, and sigmastate.basics.\n\n3. What methods are available for unlocking the secret storage?\n- There are two methods available for unlocking the secret storage: one that takes a `SecretString` object and another that takes a `String` object.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/SecretStorage.md"}}],["59",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/SecretString.java)\n\nThe `SecretString` class is a utility class that provides a secure way to store and manipulate secret data in memory. It encapsulates a secret array of characters (`char[]`) and provides methods to create, manipulate, and erase the data. The class is designed to be more secure and safe than using `char[]` directly.\n\nThe `SecretString` class has a private final field `_data` that holds the secret data. The class provides a constructor that takes a `char[]` as input and initializes the `_data` field. The class also provides a method to extract the secret characters as an array.\n\nThe `SecretString` class provides a method to erase the secret characters stored in the instance so that they are no longer in memory. The `erase()` method fills the `_data` array with spaces (`' '`) to overwrite the secret data. This method is useful when the secret data is no longer needed and should not be leaked to the garbage collector.\n\nThe `SecretString` class provides methods to create new instances of `SecretString`. The `create(char[] data)` method creates a new instance wrapping the given characters. The `create(String s)` method creates a new instance by copying characters from the given `String`. The `empty()` method creates a new instance with an empty sequence of characters.\n\nThe `SecretString` class provides a method `toStringUnsecure()` that returns an unsecured `String` with secret characters. The secret characters are copied to the new `String` instance and cannot be erased in memory. So they leak to the garbage collector and may remain in memory until overwritten by new data. The usage of this method is discouraged, and the method is provided solely to interact with legacy code that keeps secret characters in `String`.\n\nThe `SecretString` class provides an implementation of the `hashCode()` and `equals()` methods. The `equals()` method compares the `_data` field of two `SecretString` instances and returns `true` if they are equal. The `hashCode()` method returns the hash code of the `_data` field.\n\nOverall, the `SecretString` class provides a secure way to store and manipulate secret data in memory. It is useful in situations where sensitive data needs to be protected from unauthorized access or leaks. The class can be used in the larger project to store and manipulate sensitive data such as passwords, private keys, and other secret information.\n## Questions: \n 1. What is the purpose of the `SecretString` class?\n- The `SecretString` class encapsulates a secret array of characters with proper equality and provides methods to create new instances, extract secret characters, erase secret characters, and check for equality.\n\n2. How does the `SecretString` class ensure security and safety?\n- The `SecretString` class ensures security and safety by not copying the secret data outside of the instance, erasing secret characters stored in the instance so that they are no longer in memory, and providing a more secure and safe way to handle secret data than using char[] directly.\n\n3. What is the purpose of the `toStringUnsecure()` method?\n- The `toStringUnsecure()` method returns an unsecured String with secret characters, which are copied to the new String instance and cannot be erased in memory, so they may leak to GC and remain in memory until overwritten by new data. The method is provided solely to interact with legacy code which keeps secret characters in String.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/SecretString.md"}}],["60",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/SelectTokensHelper.java)\n\nThe `SelectTokensHelper` class is a utility class that helps to keep track of the amount of tokens that need to be spent and the tokens that have already been covered by boxes. It is used to determine which boxes need to be selected and if a change box is needed. \n\nThe class has a constructor that takes an iterable of `ErgoToken` objects, which represent the tokens that need to be spent. The constructor initializes a `HashMap` called `tokensLeft` that maps the token ID to the amount of tokens left to spend. It also initializes a boolean variable called `changeBoxNeeded` to false.\n\nThe class has several methods that can be used to interact with the `tokensLeft` map. The `areTokensNeeded` method takes an iterable of `ErgoToken` objects and checks if the given tokens are needed to fulfill the tokens to spend. It returns a boolean value indicating whether the found tokens were needed to fill the tokens left.\n\nThe `useTokens` method takes an iterable of `ErgoToken` objects and marks the given tokens as selected, subtracting the amount values from the remaining amount of tokens needed to fulfill the initial tokens to spend. It also keeps track if a change box is needed in case too many tokens were selected. The method returns the `SelectTokensHelper` object itself, allowing for method chaining.\n\nThe `areTokensCovered` method checks if the currently selected tokens can fulfill the initial tokens to spend. It returns a boolean value indicating whether the tokens are covered.\n\nThe `getRemainingTokenList` method returns a list of `ErgoToken` objects representing the tokens that still need to be spent.\n\nThe `isChangeBoxNeeded` method returns a boolean value indicating whether a change box is needed. This is the case if more tokens were selected than needed to spend.\n\nOverall, the `SelectTokensHelper` class provides a convenient way to keep track of tokens that need to be spent and tokens that have already been covered by boxes. It can be used in the larger project to facilitate the selection of boxes and the creation of change boxes. \n\nExample usage:\n\n```\nList<ErgoToken> tokensToSpend = new ArrayList<>();\ntokensToSpend.add(new ErgoToken(\"token1\", 10));\ntokensToSpend.add(new ErgoToken(\"token2\", 5));\n\nSelectTokensHelper helper = new SelectTokensHelper(tokensToSpend);\n\nList<ErgoToken> foundTokens = new ArrayList<>();\nfoundTokens.add(new ErgoToken(\"token1\", 5));\nfoundTokens.add(new ErgoToken(\"token2\", 5));\n\nboolean tokensNeeded = helper.areTokensNeeded(foundTokens); // returns false\n\nhelper.useTokens(foundTokens);\n\nboolean tokensCovered = helper.areTokensCovered(); // returns true\n\nList<ErgoToken> remainingTokens = helper.getRemainingTokenList(); // returns empty list\n\nboolean changeBoxNeeded = helper.isChangeBoxNeeded(); // returns false\n```\n## Questions: \n 1. What is the purpose of the `SelectTokensHelper` class?\n- The `SelectTokensHelper` class is a helper class used to keep track of the amount of tokens to spend and tokens already covered by boxes. It is used to determine if more and which boxes need to be selected, and if a change box is needed.\n\n2. What methods are available in the `SelectTokensHelper` class?\n- The `SelectTokensHelper` class has several methods available, including `areTokensNeeded()`, `useTokens()`, `areTokensCovered()`, `getRemainingTokenList()`, and `isChangeBoxNeeded()`.\n\n3. What is the purpose of the `areTokensNeeded()` method?\n- The `areTokensNeeded()` method checks if the given tokens are needed to fulfill the tokens to spend. It returns a boolean value indicating whether the found tokens were needed to fill the tokens left.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/SelectTokensHelper.md"}}],["61",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/SigmaProp.java)\n\nThe `SigmaProp` class in the `ergo-appkit` project represents a proposition that can be proven and verified by a sigma protocol. It contains a `sigmaBoolean` field which is a `Values.SigmaBoolean` object. The class provides methods to serialize and deserialize the `SigmaProp` object, as well as to create an `Address` object from it.\n\nThe `SigmaProp` class has two constructors. The first one takes a `Values.SigmaBoolean` object as an argument and initializes the `sigmaBoolean` field. The second constructor takes a `special.sigma.SigmaProp` object as an argument and converts it to a `Values.SigmaBoolean` object using the `JavaHelpers.SigmaDsl().toSigmaBoolean()` method before initializing the `sigmaBoolean` field.\n\nThe `toBytes()` method serializes the `SigmaProp` object by converting the `sigmaBoolean` field to a byte array using the `Iso.isoSigmaBooleanToByteArray().to()` method.\n\nThe `toAddress(NetworkType networkType)` method creates an `Address` object from the `SigmaProp` object. It takes a `NetworkType` object as an argument and returns an `Address` object that represents the `SigmaProp` object on the specified network.\n\nThe `parseFromBytes(byte[] serializedBytes)` method deserializes a `SigmaProp` object from a byte array. It takes a byte array as an argument and returns a new `SigmaProp` object that is equal to the one that was serialized with the `toBytes()` method.\n\nThe `createFromAddress(Address address)` method creates a new `SigmaProp` object from an `Address` object. It takes an `Address` object as an argument and returns a new `SigmaProp` object that represents the `SigmaBoolean` object of the `Address` object.\n\nOverall, the `SigmaProp` class provides functionality for working with sigma protocols and their propositions in the `ergo-appkit` project. It can be used to serialize and deserialize `SigmaProp` objects, as well as to create `Address` objects from them. Here is an example of how to use the `SigmaProp` class to create an `Address` object:\n\n```\nSigmaProp sigmaProp = new SigmaProp(sigmaBoolean);\nAddress address = sigmaProp.toAddress(NetworkType.MAINNET);\n```\n## Questions: \n 1. What is the purpose of the `SigmaProp` class?\n    \n    The `SigmaProp` class represents a proposition that can be proven and verified by a sigma protocol.\n\n2. What is the `toAddress` method used for?\n    \n    The `toAddress` method returns an `Address` object that corresponds to the `SigmaProp` object, based on the specified `NetworkType`.\n\n3. What is the difference between the two constructors for `SigmaProp`?\n    \n    The first constructor takes a `Values.SigmaBoolean` object as a parameter, while the second constructor takes a `special.sigma.SigmaProp` object and converts it to a `Values.SigmaBoolean` object using `JavaHelpers.SigmaDsl().toSigmaBoolean()`.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/SigmaProp.md"}}],["62",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/SigmaPropInterpreter.scala)\n\n## Code Explanation: SigmaPropInterpreter\n\nThe `SigmaPropInterpreter` is a simple light-weight interpreter that is a part of the `ergo-appkit` project. It is designed to verify sigma-protocol propositions, specifically the `SigmaProp` type. \n\nThe `SigmaPropInterpreter` is an object that extends the `Interpreter` trait. It defines a type `CTX` that is an alias for `InterpreterContext`. The `Interpreter` trait is a part of the `sigmastate.interpreter` package and provides a framework for interpreting ErgoScript code. \n\nThe `SigmaPropInterpreter` is a simplified version of the `Interpreter` that does not require an `IRContext` and hence cannot perform script reduction. However, it can still verify sigma-protocol propositions. Sigma-protocol is a type of zero-knowledge proof that allows one party to prove to another party that they know a secret without revealing the secret itself. \n\nThis object can be used in the larger `ergo-appkit` project to verify sigma-protocol propositions. For example, if a user wants to verify a sigma-protocol proposition in their ErgoScript code, they can use the `SigmaPropInterpreter` object to do so. \n\nHere is an example of how the `SigmaPropInterpreter` object can be used:\n\n```scala\nimport org.ergoplatform.appkit.SigmaPropInterpreter\nimport sigmastate.Values.SigmaPropValue\n\nval sigmaProp: SigmaPropValue = ???\nval context: InterpreterContext = ???\n\nval result = SigmaPropInterpreter.verify(sigmaProp, context)\n```\n\nIn this example, the `SigmaPropInterpreter` object is used to verify a `SigmaPropValue` object. The `verify` method takes in the `SigmaPropValue` object and an `InterpreterContext` object as parameters and returns a boolean value indicating whether the proposition is valid or not. \n\nOverall, the `SigmaPropInterpreter` object provides a simple and lightweight way to verify sigma-protocol propositions in ErgoScript code without the need for an `IRContext`.\n## Questions: \n 1. What is the purpose of the `SigmaPropInterpreter` object?\n   \n   The `SigmaPropInterpreter` object is a simple light-weight interpreter that can verify sigma-protocol propositions but cannot perform script reduction. \n\n2. What is the significance of the `CTX` type in the `SigmaPropInterpreter` object?\n   \n   The `CTX` type in the `SigmaPropInterpreter` object is an alias for `InterpreterContext`, which is the context type used by the interpreter.\n\n3. What is the relationship between the `SigmaPropInterpreter` object and the `Interpreter` trait?\n   \n   The `SigmaPropInterpreter` object extends the `Interpreter` trait, which means that it inherits all the methods and properties defined in the trait.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/SigmaPropInterpreter.md"}}],["63",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/Signature.java)\n\nThe `Signature` class in the `ergo-appkit` project provides a method for verifying a signature on an arbitrary message for a given public key. The purpose of this class is to provide a simple and convenient way to verify signatures in the context of the Ergo blockchain.\n\nThe `verifySignature` method takes three parameters: a `SigmaProp` object representing the sigma proposition the message should be signed with, a byte array representing the message to be verified, and another byte array representing the signature for the message. The method returns a boolean value indicating whether the signature is valid or not.\n\nThe `SigmaPropInterpreter.verifySignature` method is called internally by the `verifySignature` method to perform the actual signature verification. This method takes four parameters: a `SigmaBoolean` object representing the sigma proposition, a byte array representing the message, a byte array representing the signature, and a `Context` object representing the context in which the signature is being verified. In this case, the `Context` parameter is set to `null`, indicating that no additional context is required for the signature verification.\n\nThis class can be used in a variety of contexts within the Ergo blockchain, such as verifying signatures on transactions or validating signatures on smart contracts. Here is an example of how this class might be used to verify a signature on a transaction:\n\n```java\n// create a new Signature object\nSignature signature = new Signature();\n\n// create a new SigmaProp object representing the sigma proposition\nSigmaProp sigmaProp = new SigmaProp(\"pk:G2Q4jJ3JLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJLJ\n## Questions: \n 1. What is the purpose of the `Signature` class?\n    \n    The `Signature` class provides a static method `verifySignature` that verifies a signature on a given message for a given public key.\n\n2. Why is the constructor of the `Signature` class private?\n    \n    The constructor of the `Signature` class is made private to prevent instantiation of the class. This is because the class only provides a static method and does not need to be instantiated.\n\n3. What is the `SigmaProp` parameter in the `verifySignature` method?\n    \n    The `SigmaProp` parameter in the `verifySignature` method is the Sigma proposition that the message should be signed with. It is used to verify the signature on the message.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/Signature.md"}}],["64",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/impl/ErgoScriptContract.java)\n\nThe `ErgoScriptContract` class is a part of the `ergo-appkit` project and implements the `ErgoContract` interface. It represents a smart contract on the Ergo blockchain and provides methods to interact with it. \n\nThe class has three private fields: `_constants`, `_code`, and `_networkType`. `_constants` is an instance of the `Constants` class, which contains a map of constant values used in the contract. `_code` is a string that represents the ErgoScript code of the contract. `_networkType` is an instance of the `NetworkType` enum, which specifies the network type (Mainnet or Testnet) of the contract.\n\nThe class provides a public constructor that takes three parameters: `constants`, `code`, and `networkType`. It creates a new instance of the `ErgoScriptContract` class with the given parameters.\n\nThe class also provides several methods that implement the methods of the `ErgoContract` interface. The `getConstants()` method returns the `_constants` field. The `getErgoScript()` method returns the `_code` field.\n\nThe `substConstant(String name, Object value)` method creates a new instance of the `Constants` class with the same values as `_constants`, but with the value of the constant with the given `name` replaced with the given `value`. It then creates a new instance of the `ErgoScriptContract` class with the new `Constants` instance, the same `_code` value, and the same `_networkType` value.\n\nThe `getErgoTree()` method compiles the `_code` value into an `ErgoTree` instance using the `JavaHelpers.compile()` method. It takes the `_constants` instance, the `_code` value, and the network prefix of the `_networkType` instance as parameters. It then returns the resulting `ErgoTree` instance.\n\nThe `toAddress()` method returns an `Address` instance that represents the address of the contract on the Ergo blockchain. It does this by calling the `Address.fromErgoTree()` method with the `ErgoTree` instance returned by the `getErgoTree()` method and the `_networkType` instance as parameters.\n\nOverall, the `ErgoScriptContract` class provides a convenient way to create and interact with smart contracts on the Ergo blockchain. It allows developers to specify the constant values and ErgoScript code of the contract, and provides methods to compile the code, get the contract address, and replace constant values.\n## Questions: \n 1. What is the purpose of this code and what problem does it solve?\n- This code defines a class called `ErgoScriptContract` which implements the `ErgoContract` interface. It provides methods for creating and manipulating ErgoScript contracts, which are used in the Ergo blockchain to define transaction outputs and conditions for spending them.\n\n2. What are the input parameters for creating a new instance of `ErgoScriptContract`?\n- A new instance of `ErgoScriptContract` can be created by calling the static `create` method and passing in three parameters: a `Constants` object, a `String` containing the ErgoScript code, and a `NetworkType` object representing the network type (Mainnet, Testnet, or Regtest).\n\n3. What is the purpose of the `substConstant` method and how does it work?\n- The `substConstant` method takes in a `String` name and an `Object` value, and returns a new instance of `ErgoScriptContract` with the specified constant replaced by the new value. It works by cloning the original `Constants` object, replacing the specified constant, and creating a new `ErgoScriptContract` instance with the updated `Constants` object and the same ErgoScript code and network type.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/impl/ErgoScriptContract.md"}}],["65",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/impl/ErgoTreeContract.java)\n\nThe `ErgoTreeContract` class is a part of the `ergo-appkit` project and implements the `ErgoContract` interface. It represents a smart contract on the Ergo blockchain and provides methods to interact with it. \n\nThe class has two instance variables: `_ergoTree` of type `Values.ErgoTree` and `_networkType` of type `NetworkType`. The `_ergoTree` variable represents the ErgoTree of the smart contract, which is a serialized form of the contract script. The `_networkType` variable represents the network type on which the contract is deployed, either `MAINNET` or `TESTNET`.\n\nThe class provides four methods that are required by the `ErgoContract` interface. The `getConstants()` method returns the constants used in the contract, but it is not implemented in this class and throws a `RuntimeException`. The `getErgoScript()` method returns the serialized script of the contract, but it is also not implemented and throws a `RuntimeException`. The `substConstant(String name, Object value)` method substitutes a constant value in the contract script, but it is not implemented and throws a `RuntimeException`. The `getErgoTree()` method returns the `_ergoTree` instance variable, which represents the serialized script of the contract.\n\nThe `toAddress()` method returns the `Address` object of the contract. It uses the `_ergoTree` and `_networkType` instance variables to create an `Address` object using the `fromErgoTree()` method of the `Address` class.\n\nThis class can be used to represent a smart contract on the Ergo blockchain and to interact with it. It provides a way to get the serialized script of the contract and its constants, and to get the `Address` object of the contract. The `Address` object can be used to send Ergs or tokens to the contract, or to call its methods. \n\nExample usage:\n\n```\nValues.ErgoTree ergoTree = ... // get the serialized script of the contract\nNetworkType networkType = NetworkType.MAINNET; // set the network type\nErgoTreeContract contract = new ErgoTreeContract(ergoTree, networkType); // create a contract object\nAddress address = contract.toAddress(); // get the address of the contract\n```\n## Questions: \n 1. What is the purpose of the `ErgoTreeContract` class?\n    \n    The `ErgoTreeContract` class is an implementation of the `ErgoContract` interface and represents a contract defined by an ErgoTree.\n\n2. What is the significance of the `NetworkType` parameter in the constructor?\n    \n    The `NetworkType` parameter specifies the network type (Mainnet or Testnet) for which the contract is intended.\n\n3. What is the purpose of the `substConstant` method?\n    \n    The `substConstant` method is intended to substitute a named constant in the contract with a new value. However, this method is not implemented and currently throws a `RuntimeException`.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/impl/ErgoTreeContract.md"}}],["66",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/common/src/main/java/org/ergoplatform/appkit/impl)\n\nThe `.autodoc/docs/json/common/src/main/java/org/ergoplatform/appkit/impl` folder contains two Java classes, `ErgoScriptContract` and `ErgoTreeContract`, which are part of the `ergo-appkit` project. Both classes implement the `ErgoContract` interface and represent smart contracts on the Ergo blockchain, providing methods to interact with them.\n\n`ErgoScriptContract` allows developers to create and interact with smart contracts by specifying constant values and ErgoScript code. It provides methods to compile the code, get the contract address, and replace constant values. For example:\n\n```java\nConstants constants = ... // define constants\nString code = ... // define ErgoScript code\nNetworkType networkType = NetworkType.MAINNET; // set the network type\nErgoScriptContract contract = new ErgoScriptContract(constants, code, networkType); // create a contract object\nAddress address = contract.toAddress(); // get the address of the contract\n```\n\n`ErgoTreeContract` represents a smart contract on the Ergo blockchain using the serialized script (ErgoTree) of the contract. It provides a way to get the contract's `Address` object, which can be used to send Ergs or tokens to the contract or call its methods. However, it does not implement methods for getting constants or the ErgoScript code. Example usage:\n\n```java\nValues.ErgoTree ergoTree = ... // get the serialized script of the contract\nNetworkType networkType = NetworkType.MAINNET; // set the network type\nErgoTreeContract contract = new ErgoTreeContract(ergoTree, networkType); // create a contract object\nAddress address = contract.toAddress(); // get the address of the contract\n```\n\nBoth classes provide a convenient way to interact with smart contracts on the Ergo blockchain. Developers can choose the appropriate class based on their requirements, whether they need to work with ErgoScript code and constants (`ErgoScriptContract`) or directly with the serialized script (`ErgoTreeContract`). These classes can be used in conjunction with other parts of the `ergo-appkit` project to build and deploy smart contracts, send transactions, and interact with the Ergo blockchain.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/impl/summary.md"}}],["67",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/scalaapi/ErgoValueBuilder.scala)\n\nThe `ErgoValueBuilder` object is a helper builder that simplifies the construction of `ErgoValue` instances. `ErgoValue` is a class that represents a value in the Ergo blockchain, and it is used extensively throughout the Ergo appkit project. \n\nThe `buildFor` method takes two type parameters, `S` and `J`, which represent the Scala type and the corresponding Java type, respectively. The method also takes a value of type `S` and an isomorphism `iso` that maps `S` to `J`. The isomorphism is used to convert the Scala value to the corresponding Java value. \n\nThe method then constructs an `ErgoValue` instance of the Java type `J` that corresponds to the Scala type `S`. The `of` method of the `ErgoValue` class is used to create the instance, and it takes two arguments: the Java value and the Java class of the value. \n\nThis code is useful because it simplifies the creation of `ErgoValue` instances, which are used extensively throughout the Ergo appkit project. Instead of manually creating `ErgoValue` instances, developers can use the `ErgoValueBuilder` to construct them easily. \n\nHere is an example of how the `ErgoValueBuilder` can be used:\n\n```scala\nimport org.ergoplatform.appkit.scalaapi.ErgoValueBuilder\nimport org.ergoplatform.appkit.{ErgoTree, ErgoValue}\n\n// Define a Scala value\nval myValue: List[(Byte, List[Int])] = List((1.toByte, List(1, 2, 3)), (2.toByte, List(4, 5, 6)))\n\n// Define an isomorphism that maps the Scala value to the corresponding Java value\nimplicit val myIso = new Iso[List[(Byte, List[Int])], java.util.List[java.util.List[java.lang.Integer]]] {\n  override def toJava(s: List[(Byte, List[Int])]): java.util.List[java.util.List[java.lang.Integer]] = {\n    s.map { case (b, l) => l.map(Integer.valueOf).asJava }.asJava\n  }\n}\n\n// Use the ErgoValueBuilder to construct an ErgoValue instance\nval ergoValue: ErgoValue[java.util.List[java.util.List[java.lang.Integer]]] = ErgoValueBuilder.buildFor(myValue)\n```\n\nIn this example, the `myValue` variable is a Scala list of tuples, where each tuple contains a byte and a list of integers. The `myIso` variable is an isomorphism that maps the Scala list of tuples to a Java list of lists of integers. The `ErgoValueBuilder.buildFor` method is then used to construct an `ErgoValue` instance of the Java type `java.util.List[java.util.List[java.lang.Integer]]`.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a helper builder called `ErgoValueBuilder` that can be used to easily construct `ErgoValue` instances from Scala types supported by ErgoScript and ErgoTree.\n\n2. What is the input and output of the `buildFor` method?\n- The `buildFor` method takes a value of a Scala type supported by ErgoScript and an isomorphism that projects the given Scala type to the corresponding Java type. It returns an `ErgoValue` instance of the Java type that corresponds to the Scala type.\n\n3. How does the `buildFor` method convert the input value to an `ErgoValue` instance?\n- The `buildFor` method first uses the provided isomorphism to convert the input value to the corresponding Java type. It then creates an `ErgoValue` instance from the Java value and the Java type obtained from the isomorphism.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/scalaapi/ErgoValueBuilder.md"}}],["68",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/scalaapi/Extensions.scala)\n\nThe `Extensions` object in the `org.ergoplatform.appkit.scalaapi` package provides a set of extension methods for the `Coll` and `CollBuilder` classes. These methods are used to perform various operations on collections, such as partitioning, grouping, and reducing. \n\nThe `CollOps` extension class provides several methods for partitioning a collection based on a predicate, converting a collection to a map, summing the elements of a collection, and grouping elements of a collection by a discriminator function. The `mapReduce` method applies a mapping function to each element of the collection, groups the elements by key, and reduces each group using a reduction function. The `groupByProjecting` method is similar to `groupBy`, but it also applies a projection function to each element of the collection before grouping. \n\nThe `PairCollOps` extension class provides methods for mapping the first and second components of a collection of pairs, reducing a collection of pairs by key, summing a collection of pairs by key, and grouping a collection of pairs by key. \n\nThe `CollBuilderOps` extension class provides a method for performing an outer join operation between two collections. It also provides a method for constructing a collection of pairs from a map.\n\nThese extension methods can be used to simplify the code for working with collections in the Ergo Appkit project. For example, the `groupBy` method can be used to group UTXOs by their ErgoTree, which is useful for building transactions. The `mapReduce` method can be used to compute the total value of a collection of UTXOs. The `outerJoin` method can be used to join two collections of UTXOs based on their ErgoTree and perform some operation on the resulting pairs.\n## Questions: \n 1. What is the purpose of the `Extensions` object?\n- The `Extensions` object provides extension methods for the `Coll` type, which is a collection type used in the project. \n\n2. What does the `sum` method do?\n- The `sum` method calculates the sum of the elements in a collection using the `Numeric` typeclass. If the collection is empty, it returns the zero value of the `Numeric` type.\n\n3. What is the difference between `groupBy` and `groupByProjecting`?\n- `groupBy` partitions a collection into a map of collections according to a discriminator function, where the keys of the map are the results of applying the discriminator function to the elements of the collection. `groupByProjecting` is similar, but it also applies a projection function to each element of the collection before grouping. The resulting map has keys that are the results of applying the discriminator function, and values that are collections of the projected values.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/scalaapi/Extensions.md"}}],["69",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/scalaapi/Iso.scala)\n\nThe `Iso` class and its related classes define an isomorphism between Scala and Java types. An isomorphism is a bi-directional mapping between two types that preserves their structure. The `Iso` class is abstract and has two type parameters, `S` and `J`, which represent the Scala and Java types, respectively. The class has four methods: `scalaType`, `javaType`, `toJava`, and `toScala`. The `scalaType` and `javaType` methods return the type descriptors for the corresponding types. The `toJava` method converts a value of type `S` to a value of type `J`, and the `toScala` method converts a value of type `J` to a value of type `S`.\n\nThe `Iso` class has several subclasses that implement specific isomorphisms. The `IdentityIso` class is a subclass that implements an isomorphism between a type and itself. The `PrimIso` class is a subclass that implements an isomorphism between a primitive Scala type and its corresponding Java wrapper type. The `PairIso` class is a subclass that implements an isomorphism between a Scala pair type and a Java pair type. The `CollIso` class is a subclass that implements an isomorphism between a Scala collection type and a Java collection type.\n\nThe `Iso` object contains several implicit isomorphisms between Scala and Java types. These isomorphisms are used to convert values between the two languages. For example, the `isoByte` isomorphism converts a Scala `Byte` value to a Java `Byte` value, and the `isoColl` isomorphism converts a Scala collection of type `Coll[S]` to a Java collection of type `Coll[J]`.\n\nThe `Iso` class and its related classes are used throughout the `ergo-appkit` project to convert values between Scala and Java types. This is particularly useful when working with the Ergo blockchain, which uses a Java-based scripting language called Sigma. The `Iso` class allows developers to work with Scala types in their code and then convert them to Java types when interacting with the Ergo blockchain.\n## Questions: \n 1. What is the purpose of the `Iso` class and its subclasses?\n- The `Iso` class and its subclasses define isomorphisms between Scala and Java types, allowing for conversion between the two.\n\n2. What is the purpose of the `IsoLowPriority` class and its implicit values?\n- The `IsoLowPriority` class and its implicit values provide fallback isomorphisms for types that do not have a more specific isomorphism defined.\n\n3. What is the purpose of the `CollIso` class and its `toJava` and `toScala` methods?\n- The `CollIso` class defines an isomorphism between `Coll` collections of Scala and Java types, and its `toJava` and `toScala` methods allow for conversion between the two.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/scalaapi/Iso.md"}}],["70",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/scalaapi/Utils.scala)\n\nThe `Utils` object provides several utility functions that can be used across the `ergo-appkit` project. \n\nThe `outerJoin` function performs an outer join operation between two maps, `left` and `right`. It takes three projection functions as arguments: `l`, `r`, and `inner`. The `l` function is executed for each element of the `left` map, the `r` function is executed for each element of the `right` map, and the `inner` function is executed for matching items `(K, L)` and `(K, R)` with the same `K`. The function returns a map of `(K, O)` pairs, where each key comes from either the `left` or `right` map and values are produced by the projections. \n\nHere is an example of how to use the `outerJoin` function:\n\n```scala\nval left = Map(\"a\" -> 1, \"b\" -> 2)\nval right = Map(\"b\" -> 3, \"c\" -> 4)\n\nval result = Utils.outerJoin(left, right)(\n  (k, l) => l + 1, \n  (k, r) => r * 2, \n  (k, l, r) => l + r\n)\n\n// result: Map(\"a\" -> 2, \"b\" -> 5, \"c\" -> 8)\n```\n\nThe `mapReduce` function is a performance-optimized deterministic mapReduce primitive. It takes an array `arr` to be mapped to `(K, V)` pairs, a mapper function `m`, and a value reduction function `r`. The function returns a pair of arrays `(keys, values)`, where keys appear in order of their first production by `m` and for each `i => values(i)` corresponds to `keys(i)`. \n\nHere is an example of how to use the `mapReduce` function:\n\n```scala\nval arr = Array(1, 2, 3, 4, 5)\n\nval (keys, values) = Utils.mapReduce(arr, \n  (a: Int) => (a % 2, a), \n  (a: (Int, Int)) => a._1 + a._2\n)\n\n// keys: Array(1, 0)\n// values: Array(9, 6)\n```\n\nThe `mapToArrays` function converts a `Map` to a tuple of arrays, where the first array contains all keys of the map and the second array contains all values of the map. \n\nHere is an example of how to use the `mapToArrays` function:\n\n```scala\nval m = Map(\"a\" -> 1, \"b\" -> 2, \"c\" -> 3)\n\nval (keys, values) = Utils.mapToArrays(m)\n\n// keys: Array(\"a\", \"b\", \"c\")\n// values: Array(1, 2, 3)\n```\n\nThe `IntegralFromExactIntegral` class can adapt an `ExactIntegral` instance to be used where `Integral` is required. It implements the `Integral` trait and provides implementations for all of its methods. \n\nHere is an example of how to use the `IntegralFromExactIntegral` class:\n\n```scala\nimport scalan.math.Rational\n\nval ei = new ExactIntegral[Rational] {\n  override def plus(x: Rational, y: Rational): Rational = x + y\n  override def minus(x: Rational, y: Rational): Rational = x - y\n  override def times(x: Rational, y: Rational): Rational = x * y\n  override def negate(x: Rational): Rational = -x\n  override def fromInt(x: Int): Rational = Rational(x)\n  override def toInt(x: Rational): Int = x.toInt\n  override def toLong(x: Rational): Long = x.toLong\n  override def toFloat(x: Rational): Float = x.toFloat\n  override def toDouble(x: Rational): Double = x.toDouble\n  override def compare(x: Rational, y: Rational): Int = x.compare(y)\n  override def divisionRemainder(x: Rational, y: Rational): Rational = x % y\n  override def quot(x: Rational, y: Rational): Rational = x / y\n}\n\nval integral = new Utils.IntegralFromExactIntegral(ei)\n\nval a = Rational(3, 4)\nval b = Rational(1, 2)\n\nval sum = integral.plus(a, b) // Rational(5, 4)\n```\n## Questions: \n 1. What does the `outerJoin` function do and how is it used?\n- The `outerJoin` function performs an outer join operation between two maps, with optional projection functions for each map and a third projection function for matching items. It returns a map of (K, O) pairs. It can be used to combine data from two maps based on a common key.\n2. What is the purpose of the `mapReduce` function and how is it different from a regular `map` and `reduce` operation?\n- The `mapReduce` function is a performance-optimized deterministic mapReduce primitive that takes an array and applies a mapper function to produce (K, V) pairs, then reduces the values for each key using a value reduction function. It returns a pair of arrays (keys, values) where keys appear in order of their first production by the mapper function. It is different from a regular `map` and `reduce` operation because it guarantees the order of the keys and values in the output.\n3. What is the purpose of the `IntegralFromExactIntegral` class and how is it used?\n- The `IntegralFromExactIntegral` class can adapt an `ExactIntegral` instance to be used where `Integral` is required. It provides implementations for all `Integral` methods using the corresponding methods from `ExactIntegral`. It can be used to convert between different numeric types with different precision and rounding behavior.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/scalaapi/Utils.md"}}],["71",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/common/src/main/java/org/ergoplatform/appkit/scalaapi/package.scala)\n\nThe code above defines a package object called `scalaapi` which contains implicit instances of `ErgoType` for various types. `ErgoType` is a type class that provides a way to serialize and deserialize types used in ErgoScript, the scripting language used in the Ergo blockchain. \n\nThe purpose of this code is to provide a convenient way for developers to use ErgoScript types in their Scala code. By defining these implicit instances, developers can pass values of these types to ErgoScript functions without having to manually serialize and deserialize them. \n\nFor example, if a developer wants to pass a `Long` value to an ErgoScript function, they can simply pass the value directly and the `scalaLongType` implicit instance will handle the serialization and deserialization. \n\n```scala\nval longValue: Long = 1234567890L\nval ergoScriptFunction: ErgoContext => Long => Boolean = ???\nval result: Boolean = ergoScriptFunction(ergoContext)(longValue)\n```\n\nThis code is part of the larger `ergo-appkit` project, which provides a set of tools and libraries for building applications on the Ergo blockchain. By providing these implicit instances, the `ergo-appkit` project makes it easier for developers to work with ErgoScript types in their Scala code, which can help to reduce the amount of boilerplate code needed and improve the overall developer experience.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines global instances of `ErgoType` for various Java and Scala types used in the Ergo platform.\n\n2. What is the `ErgoType` class and how is it used?\n- The `ErgoType` class is used to represent the type of a value in the Ergo platform. It is used to define implicit instances of `ErgoType` for various types in this code.\n\n3. What is the significance of the `sigma` package and its types used in this code?\n- The `sigma` package contains types used in the ErgoScript language, which is used to write smart contracts on the Ergo platform. The `sigma` types used in this code represent various components of a transaction or block in the Ergo blockchain.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/scalaapi/package.md"}}],["72",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/common/src/main/java/org/ergoplatform/appkit/scalaapi)\n\nThe `.autodoc/docs/json/common/src/main/java/org/ergoplatform/appkit/scalaapi` folder contains utility classes and objects that facilitate the interaction between Scala and Java types in the Ergo Appkit project. These utilities are particularly useful when working with the Ergo blockchain, which uses a Java-based scripting language called Sigma.\n\n`ErgoValueBuilder.scala` provides a helper builder for constructing `ErgoValue` instances, which represent values in the Ergo blockchain. The `buildFor` method simplifies the creation of `ErgoValue` instances by taking a Scala value, an isomorphism, and converting the value to its corresponding Java type. For example:\n\n```scala\nval ergoValue: ErgoValue[java.util.List[java.util.List[java.lang.Integer]]] = ErgoValueBuilder.buildFor(myValue)\n```\n\n`Extensions.scala` offers extension methods for the `Coll` and `CollBuilder` classes, simplifying operations like partitioning, grouping, and reducing. For instance, the `groupBy` method can be used to group UTXOs by their ErgoTree, which is useful for building transactions.\n\n`Iso.scala` defines an isomorphism between Scala and Java types, allowing developers to work with Scala types in their code and convert them to Java types when interacting with the Ergo blockchain. The `Iso` class has several subclasses that implement specific isomorphisms, such as `IdentityIso`, `PrimIso`, `PairIso`, and `CollIso`.\n\n`Utils.scala` provides utility functions that can be used across the Ergo Appkit project. The `outerJoin` function performs an outer join operation between two maps, while the `mapReduce` function is a performance-optimized deterministic mapReduce primitive. The `mapToArrays` function converts a `Map` to a tuple of arrays. The `IntegralFromExactIntegral` class adapts an `ExactIntegral` instance to be used where `Integral` is required.\n\nIn summary, this folder contains utility classes and objects that simplify the interaction between Scala and Java types, as well as provide useful functions for working with collections and maps. These utilities are essential for developers working with the Ergo blockchain and the Ergo Appkit project.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/appkit/scalaapi/summary.md"}}],["73",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/common/src/main/java/org/ergoplatform)\n\nIn the `org.ergoplatform` package, you will find essential classes and interfaces that are used throughout the Ergo Appkit project. These classes provide the foundation for working with Ergo blockchain data structures and transactions.\n\nHere is a brief overview of the key classes in this package:\n\n1. **ErgoAddress**: This class represents an Ergo address, which is a unique identifier for a user or a contract on the Ergo blockchain. It provides methods to create and validate Ergo addresses, as well as to convert them to different formats (e.g., Base58, Hex, or ErgoTree).\n\n   Example usage:\n   ```java\n   ErgoAddress address = ErgoAddress.fromBase58(\"9f4QF8AD1nQ3nJahQVkM6c8S22pZ5pG5sgz\");\n   ```\n\n2. **ErgoBox**: This class represents an Ergo box, which is a fundamental data structure in Ergo that holds tokens, registers, and an ErgoTree script. ErgoBox provides methods to create and manipulate Ergo boxes, as well as to serialize and deserialize them.\n\n   Example usage:\n   ```java\n   ErgoBox box = new ErgoBox(value, ergoTree, tokens, additionalRegisters, creationHeight);\n   ```\n\n3. **ErgoId**: This class represents an Ergo box identifier, which is a unique identifier for an Ergo box on the Ergo blockchain. It provides methods to create and validate Ergo box identifiers, as well as to convert them to different formats (e.g., Base58, Hex).\n\n   Example usage:\n   ```java\n   ErgoId id = ErgoId.fromBase58(\"21Lt8D5Zk5WNNM5s6Q9zPQJqKf5MpbCb6xcvU9C6VkL8v5JLa1L\");\n   ```\n\n4. **ErgoTree**: This class represents an ErgoTree script, which is a program that defines the spending conditions for an Ergo box. ErgoTree provides methods to create and manipulate ErgoTree scripts, as well as to serialize and deserialize them.\n\n   Example usage:\n   ```java\n   ErgoTree tree = ErgoTree.fromBytes(byteArray);\n   ```\n\n5. **ErgoValue**: This class represents a value in the Ergo blockchain, such as a token amount or a register value. It provides methods to create and manipulate Ergo values, as well as to serialize and deserialize them.\n\n   Example usage:\n   ```java\n   ErgoValue<Long> value = ErgoValue.of(1000000000L);\n   ```\n\nThese classes are essential for working with Ergo blockchain data structures and transactions. They provide the foundation for creating, validating, and manipulating Ergo addresses, boxes, identifiers, scripts, and values. By using these classes, developers can easily interact with the Ergo blockchain and build powerful applications on top of it.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/ergoplatform/summary.md"}}],["74",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/common/src/main/java/org)\n\nIn the `org.ergoplatform` package, you will find essential classes and interfaces that are used throughout the Ergo Appkit project. These classes provide the foundation for working with Ergo blockchain data structures and transactions.\n\nHere is a brief overview of the key classes in this package:\n\n1. **ErgoAddress**: This class represents an Ergo address, which is a unique identifier for a user or a contract on the Ergo blockchain. It provides methods to create and validate Ergo addresses, as well as to convert them to different formats (e.g., Base58, Hex, or ErgoTree).\n\n   Example usage:\n   ```java\n   ErgoAddress address = ErgoAddress.fromBase58(\"9f4QF8AD1nQ3nJahQVkM6c8S22pZ5pG5sgz\");\n   ```\n\n2. **ErgoBox**: This class represents an Ergo box, which is a fundamental data structure in Ergo that holds tokens, registers, and an ErgoTree script. ErgoBox provides methods to create and manipulate Ergo boxes, as well as to serialize and deserialize them.\n\n   Example usage:\n   ```java\n   ErgoBox box = new ErgoBox(value, ergoTree, tokens, additionalRegisters, creationHeight);\n   ```\n\n3. **ErgoId**: This class represents an Ergo box identifier, which is a unique identifier for an Ergo box on the Ergo blockchain. It provides methods to create and validate Ergo box identifiers, as well as to convert them to different formats (e.g., Base58, Hex).\n\n   Example usage:\n   ```java\n   ErgoId id = ErgoId.fromBase58(\"21Lt8D5Zk5WNNM5s6Q9zPQJqKf5MpbCb6xcvU9C6VkL8v5JLa1L\");\n   ```\n\n4. **ErgoTree**: This class represents an ErgoTree script, which is a program that defines the spending conditions for an Ergo box. ErgoTree provides methods to create and manipulate ErgoTree scripts, as well as to serialize and deserialize them.\n\n   Example usage:\n   ```java\n   ErgoTree tree = ErgoTree.fromBytes(byteArray);\n   ```\n\n5. **ErgoValue**: This class represents a value in the Ergo blockchain, such as a token amount or a register value. It provides methods to create and manipulate Ergo values, as well as to serialize and deserialize them.\n\n   Example usage:\n   ```java\n   ErgoValue<Long> value = ErgoValue.of(1000000000L);\n   ```\n\nThese classes are essential for working with Ergo blockchain data structures and transactions. They provide the foundation for creating, validating, and manipulating Ergo addresses, boxes, identifiers, scripts, and values. By using these classes, developers can easily interact with the Ergo blockchain and build powerful applications on top of it.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/org/summary.md"}}],["75",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/common/src/main/java)\n\nThe `.autodoc/docs/json/common/src/main/java` folder contains essential classes and interfaces for the Ergo Appkit project, specifically within the `org.ergoplatform` package. These classes provide the foundation for working with Ergo blockchain data structures and transactions, enabling developers to easily interact with the Ergo blockchain and build powerful applications on top of it.\n\nKey classes in this package include:\n\n1. **ErgoAddress**: Represents a unique identifier for a user or a contract on the Ergo blockchain. It provides methods to create and validate Ergo addresses, as well as to convert them to different formats (e.g., Base58, Hex, or ErgoTree).\n\n   Example usage:\n   ```java\n   ErgoAddress address = ErgoAddress.fromBase58(\"9f4QF8AD1nQ3nJahQVkM6c8S22pZ5pG5sgz\");\n   ```\n\n2. **ErgoBox**: Represents a fundamental data structure in Ergo that holds tokens, registers, and an ErgoTree script. ErgoBox provides methods to create and manipulate Ergo boxes, as well as to serialize and deserialize them.\n\n   Example usage:\n   ```java\n   ErgoBox box = new ErgoBox(value, ergoTree, tokens, additionalRegisters, creationHeight);\n   ```\n\n3. **ErgoId**: Represents a unique identifier for an Ergo box on the Ergo blockchain. It provides methods to create and validate Ergo box identifiers, as well as to convert them to different formats (e.g., Base58, Hex).\n\n   Example usage:\n   ```java\n   ErgoId id = ErgoId.fromBase58(\"21Lt8D5Zk5WNNM5s6Q9zPQJqKf5MpbCb6xcvU9C6VkL8v5JLa1L\");\n   ```\n\n4. **ErgoTree**: Represents an ErgoTree script, a program that defines the spending conditions for an Ergo box. ErgoTree provides methods to create and manipulate ErgoTree scripts, as well as to serialize and deserialize them.\n\n   Example usage:\n   ```java\n   ErgoTree tree = ErgoTree.fromBytes(byteArray);\n   ```\n\n5. **ErgoValue**: Represents a value in the Ergo blockchain, such as a token amount or a register value. It provides methods to create and manipulate Ergo values, as well as to serialize and deserialize them.\n\n   Example usage:\n   ```java\n   ErgoValue<Long> value = ErgoValue.of(1000000000L);\n   ```\n\nThese classes are essential for working with Ergo blockchain data structures and transactions. They provide the foundation for creating, validating, and manipulating Ergo addresses, boxes, identifiers, scripts, and values. By using these classes, developers can easily interact with the Ergo blockchain and build powerful applications on top of it.","metadata":{"source":".autodoc/docs/markdown/common/src/main/java/summary.md"}}],["76",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/common/src/main)\n\nThe `.autodoc/docs/json/common/src/main` folder contains essential classes and interfaces for the Ergo Appkit project, specifically within the `org.ergoplatform` package. These classes provide the foundation for working with Ergo blockchain data structures and transactions, enabling developers to easily interact with the Ergo blockchain and build powerful applications on top of it.\n\nKey classes in this package include:\n\n1. **ErgoAddress**: Represents a unique identifier for a user or a contract on the Ergo blockchain. It provides methods to create and validate Ergo addresses, as well as to convert them to different formats (e.g., Base58, Hex, or ErgoTree).\n\n   Example usage:\n   ```java\n   ErgoAddress address = ErgoAddress.fromBase58(\"9f4QF8AD1nQ3nJahQVkM6c8S22pZ5pG5sgz\");\n   ```\n\n2. **ErgoBox**: Represents a fundamental data structure in Ergo that holds tokens, registers, and an ErgoTree script. ErgoBox provides methods to create and manipulate Ergo boxes, as well as to serialize and deserialize them.\n\n   Example usage:\n   ```java\n   ErgoBox box = new ErgoBox(value, ergoTree, tokens, additionalRegisters, creationHeight);\n   ```\n\n3. **ErgoId**: Represents a unique identifier for an Ergo box on the Ergo blockchain. It provides methods to create and validate Ergo box identifiers, as well as to convert them to different formats (e.g., Base58, Hex).\n\n   Example usage:\n   ```java\n   ErgoId id = ErgoId.fromBase58(\"21Lt8D5Zk5WNNM5s6Q9zPQJqKf5MpbCb6xcvU9C6VkL8v5JLa1L\");\n   ```\n\n4. **ErgoTree**: Represents an ErgoTree script, a program that defines the spending conditions for an Ergo box. ErgoTree provides methods to create and manipulate ErgoTree scripts, as well as to serialize and deserialize them.\n\n   Example usage:\n   ```java\n   ErgoTree tree = ErgoTree.fromBytes(byteArray);\n   ```\n\n5. **ErgoValue**: Represents a value in the Ergo blockchain, such as a token amount or a register value. It provides methods to create and manipulate Ergo values, as well as to serialize and deserialize them.\n\n   Example usage:\n   ```java\n   ErgoValue<Long> value = ErgoValue.of(1000000000L);\n   ```\n\nThese classes are essential for working with Ergo blockchain data structures and transactions. They provide the foundation for creating, validating, and manipulating Ergo addresses, boxes, identifiers, scripts, and values. By using these classes, developers can easily interact with the Ergo blockchain and build powerful applications on top of it.","metadata":{"source":".autodoc/docs/markdown/common/src/main/summary.md"}}],["77",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/common/src)\n\nThe `.autodoc/docs/json/common/src` folder contains essential classes and interfaces for the Ergo Appkit project, specifically within the `org.ergoplatform` package. These classes provide the foundation for working with Ergo blockchain data structures and transactions, enabling developers to easily interact with the Ergo blockchain and build powerful applications on top of it.\n\nKey classes in this package include:\n\n1. **ErgoAddress**: Represents a unique identifier for a user or a contract on the Ergo blockchain. It provides methods to create and validate Ergo addresses, as well as to convert them to different formats (e.g., Base58, Hex, or ErgoTree).\n\n   Example usage:\n   ```java\n   ErgoAddress address = ErgoAddress.fromBase58(\"9f4QF8AD1nQ3nJahQVkM6c8S22pZ5pG5sgz\");\n   ```\n\n2. **ErgoBox**: Represents a fundamental data structure in Ergo that holds tokens, registers, and an ErgoTree script. ErgoBox provides methods to create and manipulate Ergo boxes, as well as to serialize and deserialize them.\n\n   Example usage:\n   ```java\n   ErgoBox box = new ErgoBox(value, ergoTree, tokens, additionalRegisters, creationHeight);\n   ```\n\n3. **ErgoId**: Represents a unique identifier for an Ergo box on the Ergo blockchain. It provides methods to create and validate Ergo box identifiers, as well as to convert them to different formats (e.g., Base58, Hex).\n\n   Example usage:\n   ```java\n   ErgoId id = ErgoId.fromBase58(\"21Lt8D5Zk5WNNM5s6Q9zPQJqKf5MpbCb6xcvU9C6VkL8v5JLa1L\");\n   ```\n\n4. **ErgoTree**: Represents an ErgoTree script, a program that defines the spending conditions for an Ergo box. ErgoTree provides methods to create and manipulate ErgoTree scripts, as well as to serialize and deserialize them.\n\n   Example usage:\n   ```java\n   ErgoTree tree = ErgoTree.fromBytes(byteArray);\n   ```\n\n5. **ErgoValue**: Represents a value in the Ergo blockchain, such as a token amount or a register value. It provides methods to create and manipulate Ergo values, as well as to serialize and deserialize them.\n\n   Example usage:\n   ```java\n   ErgoValue<Long> value = ErgoValue.of(1000000000L);\n   ```\n\nThese classes are essential for working with Ergo blockchain data structures and transactions. They provide the foundation for creating, validating, and manipulating Ergo addresses, boxes, identifiers, scripts, and values. By using these classes, developers can easily interact with the Ergo blockchain and build powerful applications on top of it.","metadata":{"source":".autodoc/docs/markdown/common/src/summary.md"}}],["78",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/common)\n\nThe `.autodoc/docs/json/common` folder contains essential classes and interfaces for the Ergo Appkit project, specifically within the `org.ergoplatform` package. These classes provide the foundation for working with Ergo blockchain data structures and transactions, enabling developers to easily interact with the Ergo blockchain and build powerful applications on top of it.\n\nKey classes in this package include:\n\n1. **ErgoAddress**: Represents a unique identifier for a user or a contract on the Ergo blockchain. It provides methods to create and validate Ergo addresses, as well as to convert them to different formats (e.g., Base58, Hex, or ErgoTree).\n\n   Example usage:\n   ```java\n   ErgoAddress address = ErgoAddress.fromBase58(\"9f4QF8AD1nQ3nJahQVkM6c8S22pZ5pG5sgz\");\n   ```\n\n2. **ErgoBox**: Represents a fundamental data structure in Ergo that holds tokens, registers, and an ErgoTree script. ErgoBox provides methods to create and manipulate Ergo boxes, as well as to serialize and deserialize them.\n\n   Example usage:\n   ```java\n   ErgoBox box = new ErgoBox(value, ergoTree, tokens, additionalRegisters, creationHeight);\n   ```\n\n3. **ErgoId**: Represents a unique identifier for an Ergo box on the Ergo blockchain. It provides methods to create and validate Ergo box identifiers, as well as to convert them to different formats (e.g., Base58, Hex).\n\n   Example usage:\n   ```java\n   ErgoId id = ErgoId.fromBase58(\"21Lt8D5Zk5WNNM5s6Q9zPQJqKf5MpbCb6xcvU9C6VkL8v5JLa1L\");\n   ```\n\n4. **ErgoTree**: Represents an ErgoTree script, a program that defines the spending conditions for an Ergo box. ErgoTree provides methods to create and manipulate ErgoTree scripts, as well as to serialize and deserialize them.\n\n   Example usage:\n   ```java\n   ErgoTree tree = ErgoTree.fromBytes(byteArray);\n   ```\n\n5. **ErgoValue**: Represents a value in the Ergo blockchain, such as a token amount or a register value. It provides methods to create and manipulate Ergo values, as well as to serialize and deserialize them.\n\n   Example usage:\n   ```java\n   ErgoValue<Long> value = ErgoValue.of(1000000000L);\n   ```\n\nThese classes are essential for working with Ergo blockchain data structures and transactions. They provide the foundation for creating, validating, and manipulating Ergo addresses, boxes, identifiers, scripts, and values. By using these classes, developers can easily interact with the Ergo blockchain and build powerful applications on top of it.","metadata":{"source":".autodoc/docs/markdown/common/summary.md"}}],["79",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/ergotool.json)\n\nThis code is a configuration file for the ergo-appkit project. It contains a JSON object with two main sections: \"node\" and \"parameters\". \n\nThe \"node\" section contains information about the Ergo node API, wallet, and network type. The \"apiUrl\" field specifies the URL of the Ergo node API, which is used to interact with the Ergo blockchain. The \"apiKey\" field is used to authenticate requests to the API. The \"wallet\" section contains a mnemonic phrase, password, and mnemonic password, which are used to access the wallet associated with the Ergo node. Finally, the \"networkType\" field specifies whether the Ergo node is running on the mainnet or testnet.\n\nThe \"parameters\" section contains additional configuration options for the Ergo node. In this case, there is only one parameter specified: \"newBoxSpendingDelay\". This parameter specifies the number of blocks that must be mined before a newly created box can be spent.\n\nThis configuration file is used by the Ergo appkit project to connect to the Ergo blockchain and perform various operations, such as creating and spending boxes. The information in the \"node\" section is used to authenticate and connect to the Ergo node API, while the \"parameters\" section is used to configure various aspects of the Ergo node's behavior.\n\nHere is an example of how this configuration file might be used in the Ergo appkit project:\n\n```javascript\nconst fs = require('fs');\nconst config = JSON.parse(fs.readFileSync('ergo-config.json'));\n\n// Connect to Ergo node API\nconst nodeApi = new ErgoNodeApi(config.node.nodeApi.apiUrl, config.node.nodeApi.apiKey);\n\n// Create a new box with a spending delay\nconst newBox = new ErgoBox({\n  value: 1000000,\n  ergoTree: '0000000000000000000000000000000000000000000000000000000000000000',\n  creationHeight: nodeApi.getCurrentHeight(),\n  assets: [],\n  additionalRegisters: {},\n  transactionId: '',\n  boxId: '',\n  spendingProof: undefined,\n  creationProof: undefined,\n  spendingDelay: parseInt(config.parameters.newBoxSpendingDelay)\n});\n\n// Sign and submit transaction spending the new box\nconst tx = new ErgoTransaction();\ntx.addInput(new ErgoTransactionInput(newBox.boxId));\ntx.addOutput(new ErgoTransactionOutput({\n  value: 500000,\n  ergoTree: '0000000000000000000000000000000000000000000000000000000000000000',\n  creationHeight: nodeApi.getCurrentHeight(),\n  assets: [],\n  additionalRegisters: {}\n}));\ntx.sign(new ErgoProver(config.node.wallet.mnemonic, config.node.wallet.password, config.node.wallet.mnemonicPassword));\nnodeApi.submitTransaction(tx);\n```\n## Questions: \n 1. What is the purpose of this code file in the ergo-appkit project?\n- This code file contains configuration settings for the node and wallet in the ergo-appkit project.\n\n2. What is the significance of the \"apiUrl\" and \"apiKey\" values in the \"nodeApi\" object?\n- The \"apiUrl\" value specifies the URL for the Ergo node API, while the \"apiKey\" value is used for authentication and authorization to access the API.\n\n3. What does the \"newBoxSpendingDelay\" parameter in the \"parameters\" object do?\n- The \"newBoxSpendingDelay\" parameter specifies the number of blocks that must be mined before a newly created box can be spent.","metadata":{"source":".autodoc/docs/markdown/ergotool.md"}}],["80",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/CollectionFormats.java)\n\nThe `CollectionFormats` class in the `ergo-appkit` project provides a set of classes for formatting collections of strings into various formats. These formats include CSV, SSV, TSV, and PIPES. \n\nThe `CSVParams`, `SSVParams`, `TSVParams`, and `PIPESParams` classes are all subclasses of the `CollectionFormats` class. Each of these subclasses has a `toString()` method that formats the list of strings into the corresponding format. \n\nThe `CSVParams` class formats the list of strings into a comma-separated value format. The `SSVParams` class formats the list of strings into a space-separated value format. The `TSVParams` class formats the list of strings into a tab-separated value format. The `PIPESParams` class formats the list of strings into a pipe-separated value format. \n\nEach of these subclasses has three constructors: a default constructor, a constructor that takes a list of strings, and a constructor that takes a variable number of string arguments. The `getParams()` and `setParams()` methods are used to get and set the list of strings that will be formatted. \n\nThis code can be used in the larger project to format collections of strings into various formats for use in different parts of the application. For example, if the application needs to output data in a CSV format, the `CSVParams` class can be used to format the data. Similarly, if the application needs to output data in a different format, such as a space-separated value format, the `SSVParams` class can be used. \n\nHere is an example of how the `CSVParams` class can be used to format a list of strings:\n\n```\nList<String> params = Arrays.asList(\"param1\", \"param2\", \"param3\");\nCSVParams csvParams = new CSVParams(params);\nString formattedParams = csvParams.toString();\n```\n\nIn this example, a list of strings is created and passed to the `CSVParams` constructor. The `toString()` method is then called on the `csvParams` object to format the list of strings into a CSV format. The resulting string, `formattedParams`, can then be used in the application as needed.\n## Questions: \n 1. What is the purpose of the `CollectionFormats` class?\n    \n    `CollectionFormats` is a class that contains several nested classes that define different formats for collections of strings.\n\n2. What are the differences between the `CSVParams`, `SSVParams`, `TSVParams`, and `PIPESParams` classes?\n    \n    Each of these classes extends the `CSVParams` class and overrides the `toString()` method to define a different delimiter for joining the list of strings. `SSVParams` uses a space delimiter, `TSVParams` uses a tab delimiter, and `PIPESParams` uses a pipe delimiter.\n\n3. What is the purpose of the `StringUtil` class?\n    \n    The `StringUtil` class is not included in this code snippet, so a smart developer might wonder what it does and where it is defined. It is likely a utility class that provides string manipulation methods, such as `join()`, which is used in the `toString()` methods of the nested classes to join the list of strings with a delimiter.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/CollectionFormats.md"}}],["81",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/DefaultApi.java)\n\nThe `DefaultApi` interface in the `org.ergoplatform.explorer.client` package provides a set of methods for interacting with the Ergo blockchain explorer API. This interface is used to fetch various types of data from the Ergo blockchain, such as balances, transactions, blocks, and tokens.\n\nFor example, the `getApiV1AddressesP1BalanceConfirmed` method retrieves the confirmed balance of a given address with an optional minimum number of confirmations. Similarly, the `getApiV1AddressesP1Transactions` method fetches the transactions associated with a specific address, with optional parameters for pagination and concise output.\n\nThe interface also provides methods for fetching data related to blocks, such as `getApiV1Blocks` which retrieves a list of blocks with optional pagination and sorting parameters, and `getApiV1BlocksP1` which fetches the summary of a specific block.\n\nToken-related methods include `getApiV1Tokens` which retrieves a list of tokens with optional pagination, sorting, and filtering parameters, and `getApiV1TokensP1` which fetches the information of a specific token.\n\nAdditionally, there are methods for searching and filtering data, such as `postApiV1BoxesSearch` which allows searching for boxes based on a `BoxQuery` object, and `getApiV1TransactionsByinputsscripttemplatehashP1` which fetches transactions based on an input script template hash.\n\nOverall, the `DefaultApi` interface serves as a bridge between the Ergo blockchain explorer API and the ergo-appkit project, allowing developers to easily fetch and interact with data from the Ergo blockchain.\n## Questions: \n 1. **Question**: What is the purpose of the `DefaultApi` interface?\n   **Answer**: The `DefaultApi` interface defines the API endpoints and their corresponding methods for interacting with the Ergo Explorer API. It uses Retrofit2 library to make HTTP requests and handle responses.\n\n2. **Question**: How are the API endpoints defined in the `DefaultApi` interface?\n   **Answer**: The API endpoints are defined using Retrofit2 annotations such as `@GET`, `@POST`, and `@Headers`. These annotations specify the HTTP method, the endpoint URL, and any additional headers required for the request.\n\n3. **Question**: How are the query parameters and path parameters handled in the `DefaultApi` interface methods?\n   **Answer**: The query parameters and path parameters are handled using Retrofit2 annotations such as `@retrofit2.http.Path`, `@retrofit2.http.Query`, and `@retrofit2.http.Body`. These annotations are used to define the parameters in the method signature and map them to the corresponding parts of the API endpoint URL or request body.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/DefaultApi.md"}}],["82",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/ExplorerApiClient.java)\n\nThe `ExplorerApiClient` class is a wrapper around the Retrofit library that provides a convenient way to interact with a RESTful API. It is designed to be used in the Ergo AppKit project. \n\nThe class has several methods that allow the user to configure the Retrofit instance, such as `createDefaultAdapter()`, which sets up the default configuration for the Retrofit instance, and `createService()`, which creates a service interface for the API. \n\nThe `setDateFormat()`, `setSqlDateFormat()`, `setOffsetDateTimeFormat()`, and `setLocalDateFormat()` methods allow the user to set the date format for the JSON responses. \n\nThe `configureFromOkclient()` and `configureFromOkClientBuilder()` methods allow the user to configure the Retrofit instance using an existing `OkHttpClient` instance or builder. \n\nThe `GsonCustomConverterFactory` class is a custom converter factory that extends the `Converter.Factory` class. It is used to handle the case where the deserialization fails due to a `JsonParseException` and the expected type is `String`. In this case, the `GsonResponseBodyConverterToString` class is used to return the body string. \n\nOverall, the `ExplorerApiClient` class provides a convenient way to interact with a RESTful API using the Retrofit library. It is designed to be used in the Ergo AppKit project and provides several methods to configure the Retrofit instance. The `GsonCustomConverterFactory` class is a custom converter factory that handles the case where the deserialization fails due to a `JsonParseException` and the expected type is `String`.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `ExplorerApiClient` that provides methods for creating a Retrofit service and configuring its adapter and HTTP client.\n\n2. What external libraries or dependencies does this code use?\n- This code uses the following external libraries: `com.google.gson`, `okhttp3`, `retrofit2`, `retrofit2.converter.gson`, and `retrofit2.converter.scalars`.\n\n3. What is the purpose of the `GsonCustomConverterFactory` class?\n- The `GsonCustomConverterFactory` class is a custom implementation of the `Converter.Factory` interface that provides a way to convert response bodies to a specified type, including handling the case where deserialization fails due to a `JsonParseException` and the expected type is `String`.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/ExplorerApiClient.md"}}],["83",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/JSON.java)\n\nThe `JSON` class in the `ergo-appkit` project is responsible for creating and configuring a `Gson` object, which is a Java library used for serializing and deserializing Java objects to and from JSON. The `Gson` object is used throughout the project to convert JSON responses from the Ergo Explorer API into Java objects that can be used by the application.\n\nThe `JSON` class contains several nested classes that extend `TypeAdapter` and are used to customize the serialization and deserialization of specific Java types. For example, the `OffsetDateTimeTypeAdapter` class is used to serialize and deserialize `OffsetDateTime` objects, while the `SqlDateTypeAdapter` class is used to serialize and deserialize `java.sql.Date` objects.\n\nThe `JSON` class also contains several methods that can be used to customize the behavior of the `Gson` object. For example, the `setDateFormat` method can be used to set the date format used by the `DateTypeAdapter`, while the `setOffsetDateTimeFormat` method can be used to set the date format used by the `OffsetDateTimeTypeAdapter`.\n\nOverall, the `JSON` class is an important part of the `ergo-appkit` project, as it provides a way to convert JSON responses from the Ergo Explorer API into Java objects that can be used by the application. By customizing the behavior of the `Gson` object, developers can ensure that the JSON responses are correctly serialized and deserialized, and that the resulting Java objects are consistent with the application's data model.\n## Questions: \n 1. What is the purpose of this code?\n- This code is a Gson-based JSON serialization/deserialization utility for Java that provides custom type adapters for various date/time formats.\n\n2. What external libraries or dependencies does this code rely on?\n- This code relies on the Gson and GsonFire libraries.\n\n3. What is the purpose of the `OffsetDateTimeTypeAdapter` and `LocalDateTypeAdapter` classes?\n- The `OffsetDateTimeTypeAdapter` and `LocalDateTypeAdapter` classes are Gson type adapters for the JSR310 `OffsetDateTime` and `LocalDate` types, respectively, that allow for custom formatting of these types during serialization and deserialization.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/JSON.md"}}],["84",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/StringUtil.java)\n\nThe `StringUtil` class in the `ergo-appkit` project provides two utility methods for working with arrays of strings. \n\nThe first method, `containsIgnoreCase`, takes an array of strings and a value to search for. It returns a boolean indicating whether the value is present in the array, using a case-insensitive comparison. If the value is null and there is a null element in the array, the method returns true. This method can be useful for checking if a particular string value is present in an array, regardless of case.\n\nHere is an example usage of the `containsIgnoreCase` method:\n\n```\nString[] fruits = {\"apple\", \"banana\", \"orange\"};\nboolean containsApple = StringUtil.containsIgnoreCase(fruits, \"APPLE\");\n// containsApple is true\n```\n\nThe second method, `join`, takes an array of strings and a separator string. It returns a single string that is the concatenation of all the elements in the array, separated by the given separator. This method can be useful for constructing a comma-separated list of values, for example.\n\nHere is an example usage of the `join` method:\n\n```\nString[] names = {\"Alice\", \"Bob\", \"Charlie\"};\nString commaSeparatedNames = StringUtil.join(names, \", \");\n// commaSeparatedNames is \"Alice, Bob, Charlie\"\n```\n\nOverall, the `StringUtil` class provides simple but useful utility methods for working with arrays of strings. These methods can be used throughout the `ergo-appkit` project to simplify string manipulation tasks.\n## Questions: \n 1. What is the purpose of this code?\n- This code provides utility methods for string manipulation, specifically for checking if an array contains a value (case-insensitive) and joining an array of strings with a separator.\n\n2. Are there any external dependencies for this code?\n- The code mentions that the `join` method might be replaced by a utility method from `commons-lang` or `guava` if either of those libraries is added as a dependency.\n\n3. Can the methods in this code be modified?\n- The code explicitly states that it is auto-generated by the Swagger code generator program and should not be edited manually. However, it is not clear if the methods themselves can be modified or overridden in a subclass.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/StringUtil.md"}}],["85",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/auth/ApiKeyAuth.java)\n\nThe `ApiKeyAuth` class is responsible for adding an API key to HTTP requests made by the Ergo Explorer client. It implements the `Interceptor` interface from the OkHttp library, which allows it to intercept and modify HTTP requests and responses.\n\nThe class takes two parameters in its constructor: `location` and `paramName`. `location` specifies where the API key should be added - either as a query parameter or a header. `paramName` specifies the name of the query parameter or header that should contain the API key.\n\nThe API key itself is stored in the `apiKey` field, which can be set using the `setApiKey` method. The `getApiKey` method can be used to retrieve the current API key.\n\nThe `intercept` method is where the actual interception and modification of requests happens. It first retrieves the original request using the `chain.request()` method. If the `location` is set to \"query\", it adds the API key as a query parameter to the request URL. If the `location` is set to \"header\", it adds the API key as a header to the request.\n\nThe modified request is then returned using `chain.proceed(request)`, which sends the request to the server and returns the server's response.\n\nThis class can be used in the larger Ergo Explorer project to ensure that all requests made by the client include the necessary API key. For example, if the Ergo Explorer client needs to make a request to the Ergo blockchain API, it can use an instance of `ApiKeyAuth` to add the API key to the request. Here's an example of how this might be done:\n\n```\nApiKeyAuth apiKeyAuth = new ApiKeyAuth(\"header\", \"X-Api-Key\");\napiKeyAuth.setApiKey(\"my-api-key\");\n\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(apiKeyAuth)\n        .build();\n\nRequest request = new Request.Builder()\n        .url(\"https://api.ergoplatform.com\")\n        .build();\n\nResponse response = client.newCall(request).execute();\n```\n## Questions: \n 1. What is the purpose of this code?\n    \n    This code defines a class called `ApiKeyAuth` that implements the `Interceptor` interface from the OkHttp library. It is used to add an API key to HTTP requests either as a query parameter or a header.\n\n2. What parameters does the `ApiKeyAuth` constructor take?\n    \n    The `ApiKeyAuth` constructor takes two parameters: `location` and `paramName`. `location` specifies whether the API key should be added as a query parameter or a header, and `paramName` is the name of the query parameter or header that the API key should be added to.\n\n3. What does the `intercept` method do?\n    \n    The `intercept` method is called by OkHttp when an HTTP request is made. It checks the `location` parameter to determine whether the API key should be added as a query parameter or a header, and then modifies the request accordingly. If the `location` is \"query\", it adds the API key as a query parameter to the request URL. If the `location` is \"header\", it adds the API key as a header to the request.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/auth/ApiKeyAuth.md"}}],["86",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/auth/HttpBasicAuth.java)\n\nThe `HttpBasicAuth` class in the `org.ergoplatform.explorer.client.auth` package is responsible for adding HTTP Basic Authentication headers to outgoing requests made by an `OkHttpClient` instance. This class implements the `Interceptor` interface from the OkHttp library, which allows it to intercept and modify requests and responses.\n\nThe class has three instance variables: `username`, `password`, and `credentials`. The `username` and `password` variables store the username and password for the Basic Authentication header, respectively. The `credentials` variable is a convenience method for setting both the `username` and `password` at once.\n\nThe `intercept` method is the main method of the class and is called by OkHttp whenever a request is made. It first retrieves the original request from the `Chain` object passed as a parameter. If the request already has an Authorization header, the method does nothing and simply returns the original request. If the request does not have an Authorization header, the method creates a new request with the Authorization header added using the `Credentials.basic` method from OkHttp. This method takes the `username` and `password` instance variables and returns a string in the format \"Basic [base64-encoded username:password]\". The new request is then returned using the `chain.proceed` method.\n\nThis class can be used in conjunction with an `OkHttpClient` instance to add Basic Authentication headers to all outgoing requests. For example:\n\n```\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(new HttpBasicAuth())\n        .build();\n\nRequest request = new Request.Builder()\n        .url(\"https://example.com/api\")\n        .build();\n\nResponse response = client.newCall(request).execute();\n```\n\nIn this example, the `HttpBasicAuth` instance is added as an interceptor to the `OkHttpClient` instance. This means that all requests made using this client will have the Basic Authentication header added automatically. The `Request` object is then created as usual and passed to the `OkHttpClient` instance to execute the request.\n## Questions: \n 1. What is the purpose of this code?\n   This code defines a class called `HttpBasicAuth` that implements the `Interceptor` interface from the OkHttp library. It adds HTTP Basic authentication credentials to outgoing requests if they don't already have them.\n\n2. How is the username and password set for this HTTP Basic authentication?\n   The username and password can be set separately using the `setUsername` and `setPassword` methods, or together using the `setCredentials` method.\n\n3. What happens if a request already has an authorization header?\n   If a request already has an authorization header (e.g. for Basic auth), the `intercept` method does nothing and simply proceeds with the request as-is.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/auth/HttpBasicAuth.md"}}],["87",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/java-client-generated/src/main/java/org/ergoplatform/explorer/client/auth)\n\nThe `org.ergoplatform.explorer.client.auth` package contains two classes, `ApiKeyAuth` and `HttpBasicAuth`, which are responsible for adding authentication information to HTTP requests made by the Ergo Explorer client. Both classes implement the `Interceptor` interface from the OkHttp library, allowing them to intercept and modify HTTP requests and responses.\n\n`ApiKeyAuth` is used to add an API key to requests. It takes two parameters in its constructor: `location` and `paramName`. `location` specifies where the API key should be added - either as a query parameter or a header. `paramName` specifies the name of the query parameter or header that should contain the API key. The API key itself is stored in the `apiKey` field, which can be set using the `setApiKey` method. The `intercept` method adds the API key to the request based on the `location` value.\n\nExample usage:\n\n```java\nApiKeyAuth apiKeyAuth = new ApiKeyAuth(\"header\", \"X-Api-Key\");\napiKeyAuth.setApiKey(\"my-api-key\");\n\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(apiKeyAuth)\n        .build();\n\nRequest request = new Request.Builder()\n        .url(\"https://api.ergoplatform.com\")\n        .build();\n\nResponse response = client.newCall(request).execute();\n```\n\n`HttpBasicAuth` is used to add HTTP Basic Authentication headers to requests. It has three instance variables: `username`, `password`, and `credentials`. The `intercept` method retrieves the original request and checks if it already has an Authorization header. If not, it creates a new request with the Authorization header added using the `Credentials.basic` method from OkHttp, which takes the `username` and `password` instance variables and returns a string in the format \"Basic [base64-encoded username:password]\". The new request is then returned using the `chain.proceed` method.\n\nExample usage:\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(new HttpBasicAuth())\n        .build();\n\nRequest request = new Request.Builder()\n        .url(\"https://example.com/api\")\n        .build();\n\nResponse response = client.newCall(request).execute();\n```\n\nIn summary, the `org.ergoplatform.explorer.client.auth` package provides two classes for adding authentication information to HTTP requests made by the Ergo Explorer client. These classes can be used in conjunction with an `OkHttpClient` instance to ensure that all requests include the necessary authentication information.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/auth/summary.md"}}],["88",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/AdditionalRegister.java)\n\nThis code defines a Java class called `AdditionalRegister` which represents an additional register of a box in the Ergo blockchain. The class has three fields: `serializedValue`, `sigmaType`, and `renderedValue`, all of which are strings. \n\nThe purpose of this class is to provide a standardized way of representing additional registers in the Ergo Explorer API. The `serializedValue` field contains the serialized value of the register, while the `sigmaType` field specifies the type of the register (e.g. \"CollByte\", \"CollInt\", etc.). The `renderedValue` field contains a human-readable representation of the register value.\n\nThis class is used in the larger Ergo Explorer project to represent additional registers of boxes in the Ergo blockchain. For example, when retrieving information about a particular box, the Ergo Explorer API may return an `AdditionalRegister` object for each additional register associated with the box.\n\nHere is an example of how this class might be used in Java code:\n\n```\nAdditionalRegister register = new AdditionalRegister();\nregister.serializedValue = \"0123456789abcdef\";\nregister.sigmaType = \"CollByte\";\nregister.renderedValue = \"[1, 35, 69, 103, 137, 171, 205, 239]\";\n\nSystem.out.println(register.serializedValue);\n// Output: 0123456789abcdef\n\nSystem.out.println(register.sigmaType);\n// Output: CollByte\n\nSystem.out.println(register.renderedValue);\n// Output: [1, 35, 69, 103, 137, 171, 205, 239]\n```\n\nIn this example, we create a new `AdditionalRegister` object and set its fields to some example values. We then print out the values of each field using the `println` method.\n## Questions: \n 1. What is the purpose of this code and what does it do?\n   This code defines a Java class called `AdditionalRegister` with three properties: `serializedValue`, `sigmaType`, and `renderedValue`. It also includes methods for `equals`, `hashCode`, and `toString`.\n\n2. What is the expected input and output of this code?\n   This code does not have any input or output as it only defines a Java class. It can be used as a data model for other parts of the project.\n\n3. What is the significance of the `SerializedName` annotation in this code?\n   The `SerializedName` annotation is used to specify the name of the JSON property that corresponds to a Java field or property when serializing and deserializing JSON. In this case, it is used to map the JSON properties to the Java properties of the `AdditionalRegister` class.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/AdditionalRegister.md"}}],["89",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/AdditionalRegisters.java)\n\nThis code defines a Java class called `AdditionalRegisters` which extends the `java.util.HashMap` class. The purpose of this class is to represent a collection of `AdditionalRegister` objects, where each object is associated with a unique string key. \n\nThe `AdditionalRegisters` class overrides the `equals` and `hashCode` methods inherited from the `HashMap` class to ensure that two `AdditionalRegisters` objects are considered equal if they contain the same set of key-value pairs. The `toString` method is also overridden to provide a string representation of the object.\n\nThis class is likely used in the larger project to represent a set of additional registers associated with a particular transaction or block in the Ergo blockchain. The `AdditionalRegister` class is likely defined elsewhere in the project and contains information about a single additional register, such as its type and value. \n\nAn example of how this class might be used in the project is to retrieve the additional registers associated with a particular transaction. This could be done by calling a method on a `Transaction` object that returns an `AdditionalRegisters` object. The returned object could then be used to access the individual `AdditionalRegister` objects by their keys. For example:\n\n```\nTransaction tx = getTransactionById(\"abc123\");\nAdditionalRegisters additionalRegs = tx.getAdditionalRegisters();\nAdditionalRegister reg1 = additionalRegs.get(\"key1\");\nAdditionalRegister reg2 = additionalRegs.get(\"key2\");\n```\n\nIn this example, `getTransactionById` is a method that retrieves a `Transaction` object by its ID. The `getAdditionalRegisters` method returns an `AdditionalRegisters` object associated with the transaction, which can then be used to retrieve the individual `AdditionalRegister` objects by their keys.\n## Questions: \n 1. What is the purpose of the `AdditionalRegisters` class?\n- The `AdditionalRegisters` class is a subclass of `java.util.HashMap` and represents a collection of `AdditionalRegister` objects.\n\n2. What is the significance of the `equals` and `hashCode` methods in this class?\n- The `equals` and `hashCode` methods are used for object comparison and hashing, respectively. They are overridden in this class to compare and hash the contents of the `HashMap`.\n\n3. Why is the `toString` method overridden in this class?\n- The `toString` method is overridden to provide a custom string representation of the `AdditionalRegisters` object. It calls the `toIndentedString` method to format the output with indentation.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/AdditionalRegisters.md"}}],["90",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/AdditionalRegisters1.java)\n\nThis code defines a Java class called `AdditionalRegisters1` which extends the `java.util.HashMap` class. The purpose of this class is to represent additional registers in the Ergo blockchain. \n\nThe `AdditionalRegisters1` class overrides the `equals`, `hashCode`, and `toString` methods of the `HashMap` class. The `equals` method checks if two `AdditionalRegisters1` objects are equal by comparing their `HashMap` superclasses. The `hashCode` method returns the hash code of the `HashMap` superclass. The `toString` method returns a string representation of the `AdditionalRegisters1` object.\n\nThis class is likely used in the larger Ergo Explorer API project to represent additional registers in Ergo transactions. Developers can create instances of the `AdditionalRegisters1` class and populate them with key-value pairs representing additional registers. For example:\n\n```\nAdditionalRegisters1 additionalRegisters = new AdditionalRegisters1();\nadditionalRegisters.put(\"key1\", \"value1\");\nadditionalRegisters.put(\"key2\", \"value2\");\n```\n\nThis code creates a new `AdditionalRegisters1` object and adds two key-value pairs to it. These key-value pairs represent additional registers in an Ergo transaction. The `AdditionalRegisters1` object can then be passed to other parts of the Ergo Explorer API project that require additional register information.\n## Questions: \n 1. What is the purpose of this code?\n- This code is a generated class for the Ergo Explorer API v1, specifically for Additional Registers.\n\n2. What is the parent class of AdditionalRegisters1?\n- AdditionalRegisters1 extends the java.util.HashMap class.\n\n3. Can the methods in this class be overridden?\n- Yes, the equals() and hashCode() methods can be overridden in this class.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/AdditionalRegisters1.md"}}],["91",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/AssetInfo.java)\n\nThe `AssetInfo` class is a model class that represents information about an asset in the Ergo blockchain. It contains fields such as `headerId`, `boxId`, `tokenId`, `index`, `amount`, `name`, `decimals`, and `type`. These fields provide information about the asset's location in the blockchain, its identifier, the amount of tokens it represents, and other metadata.\n\nThis class is used in the Ergo Explorer API to represent assets in the blockchain. It can be used to retrieve information about assets, such as their name, amount, and location in the blockchain. For example, a developer could use this class to retrieve information about a specific asset and display it in a user interface.\n\nThe class contains getter and setter methods for each field, as well as methods for equality checking, hashing, and string representation. The `toString()` method returns a string representation of the object, which can be useful for debugging and logging purposes.\n\nOverall, the `AssetInfo` class is an important part of the Ergo Explorer API, providing a convenient way to represent and retrieve information about assets in the Ergo blockchain.\n## Questions: \n 1. What is the purpose of the `AssetInfo` class?\n- The `AssetInfo` class is a model class that represents information about an asset, including its header ID, box ID, token ID, index, amount, name, decimals, and type.\n\n2. What is the significance of the `SerializedName` annotation in this code?\n- The `SerializedName` annotation is used to specify the name of the JSON property that corresponds to a particular field in the `AssetInfo` class. This is necessary because the field names in the Java class may not match the property names in the JSON representation.\n\n3. Why is the `toIndentedString` method private?\n- The `toIndentedString` method is a helper method that is used to convert an object to a string with each line indented by 4 spaces. It is only used internally by the `toString` method, so there is no need for it to be public.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/AssetInfo.md"}}],["92",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/AssetInstanceInfo.java)\n\nThe `AssetInstanceInfo` class is a model class that represents information about a specific asset instance. It contains six fields: `tokenId`, `index`, `amount`, `name`, `decimals`, and `type`. \n\nThe `tokenId` field is a string that represents the unique identifier of the token. The `index` field is an integer that represents the index of the asset in an output. The `amount` field is a long integer that represents the amount of tokens. The `name` field is a string that represents the name of the token. The `decimals` field is an integer that represents the number of decimal places. The `type` field is a string that represents the type of the token (token standard).\n\nThis class is used to represent asset instances in the Ergo Explorer API. It can be used to retrieve information about specific asset instances, such as their token ID, amount, and name. \n\nHere is an example of how this class might be used in the larger project:\n\n```java\nAssetInstanceInfo assetInstance = new AssetInstanceInfo()\n    .tokenId(\"abc123\")\n    .index(0)\n    .amount(1000L)\n    .name(\"My Token\")\n    .decimals(2)\n    .type(\"ERC20\");\n\nSystem.out.println(assetInstance.getTokenId()); // Output: abc123\nSystem.out.println(assetInstance.getAmount()); // Output: 1000\nSystem.out.println(assetInstance.getName()); // Output: My Token\n``` \n\nIn this example, a new `AssetInstanceInfo` object is created and its fields are set using the builder pattern. The `tokenId`, `index`, `amount`, `name`, `decimals`, and `type` fields are set to \"abc123\", 0, 1000L, \"My Token\", 2, and \"ERC20\", respectively. The `getTokenId()`, `getAmount()`, and `getName()` methods are then called on the `assetInstance` object to retrieve the values of those fields. The output of these calls is \"abc123\", 1000, and \"My Token\", respectively.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `AssetInstanceInfo` that represents information about a token asset.\n\n2. What are the required fields for an `AssetInstanceInfo` object?\n- An `AssetInstanceInfo` object requires a `tokenId` and an `index` field.\n\n3. What is the purpose of the `type` field in an `AssetInstanceInfo` object?\n- The `type` field represents the type of token standard that the asset adheres to.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/AssetInstanceInfo.md"}}],["93",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/BadRequest.java)\n\nThis code defines a Java class called `BadRequest` that represents a bad request error response. The purpose of this class is to provide a standardized format for returning error responses when a client sends a request that cannot be fulfilled by the server. \n\nThe `BadRequest` class has two properties: `status` and `reason`. The `status` property is an integer that represents the HTTP status code of the error response. The `reason` property is a string that provides a human-readable explanation of the error. \n\nThis class is generated automatically by the Swagger Codegen program, which is a tool that generates client libraries, server stubs, and documentation from OpenAPI (formerly known as Swagger) specifications. The purpose of this class is to provide a standardized format for error responses that conform to the OpenAPI specification. \n\nIn the larger project, this class may be used by the server to return error responses to clients when a request cannot be fulfilled. For example, if a client sends a request to the server to retrieve data that does not exist, the server may return a `BadRequest` object with a `status` of 404 (Not Found) and a `reason` of \"Data not found\". \n\nHere is an example of how this class may be used in a server method:\n\n```java\npublic Data getData(String id) {\n  Data data = dataRepository.findById(id);\n  if (data == null) {\n    BadRequest error = new BadRequest()\n        .status(404)\n        .reason(\"Data not found\");\n    throw new ApiException(error);\n  }\n  return data;\n}\n```\n\nIn this example, the `getData` method retrieves data from a repository based on an ID. If the data does not exist, the method throws an `ApiException` with a `BadRequest` object that represents the error response. The client can then handle this error response appropriately.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `BadRequest` that represents a bad request response from an API.\n\n2. What is the expected input and output of this code?\n- This code does not have any input or output, as it only defines a class with getter and setter methods for two properties: `status` and `reason`.\n\n3. Can this code be modified by developers?\n- The code comments state that this class is auto-generated by a Swagger code generator program and should not be edited manually. Therefore, developers should not modify this code directly.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/BadRequest.md"}}],["94",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/Balance.java)\n\nThis code defines a Java class called `Balance` that represents the balance of an Ergo wallet. The `Balance` class has two properties: `nanoErgs` and `tokens`. The `nanoErgs` property is a `Long` that represents the balance of the wallet in Ergs, the native currency of the Ergo blockchain. The `tokens` property is a list of `TokenAmount` objects that represent the balance of the wallet in non-native tokens.\n\nThe `Balance` class has getter and setter methods for both properties. The `getNanoErgs` method returns the value of the `nanoErgs` property, while the `getTokens` method returns the list of `TokenAmount` objects. The `setNanoErgs` and `setTokens` methods set the values of the `nanoErgs` and `tokens` properties, respectively. The `addTokensItem` method adds a `TokenAmount` object to the list of tokens.\n\nThe `Balance` class also has methods for equality checking, hashing, and string representation. These methods are used to compare `Balance` objects, generate hash codes for `Balance` objects, and convert `Balance` objects to strings, respectively.\n\nThis class is likely used in the larger project to represent the balance of an Ergo wallet. It can be instantiated with a balance in Ergs and a list of `TokenAmount` objects representing the balance in non-native tokens. The `Balance` object can then be passed around the project to represent the wallet balance. For example, it could be used to display the balance of a wallet in a user interface or to calculate the total value of a user's assets. \n\nExample usage:\n```\nBalance balance = new Balance();\nbalance.setNanoErgs(1000000000L); // set balance to 1 Erg\nList<TokenAmount> tokens = new ArrayList<>();\ntokens.add(new TokenAmount(\"Token1\", 100)); // add 100 units of Token1\ntokens.add(new TokenAmount(\"Token2\", 50)); // add 50 units of Token2\nbalance.setTokens(tokens); // set the token balances\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `Balance` that represents the balance of an Ergo wallet, including the amount of nanoErgs and any tokens held.\n\n2. What is the significance of the `@Schema` annotation?\n- The `@Schema` annotation is used to provide metadata about the `nanoErgs` and `tokens` fields, including their descriptions and whether they are required.\n\n3. What is the purpose of the `toIndentedString` method?\n- The `toIndentedString` method is a helper method used to convert an object to a string with each line indented by 4 spaces, which is used in the `toString` method to format the output of the `Balance` class.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/Balance.md"}}],["95",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/BlockExtensionInfo.java)\n\nThis code defines a Java class called `BlockExtensionInfo` which represents a block extension in the Ergo Explorer API. A block extension is an additional data structure that can be included in a block header in the Ergo blockchain. The purpose of this class is to provide a way to represent block extensions in Java code and to serialize/deserialize them to/from JSON format.\n\nThe class has three instance variables: `headerId`, `digest`, and `fields`. `headerId` is a string that represents the ID of the corresponding block header. `digest` is a string that represents the hex-encoded extension digest. `fields` is an instance of the `Fields` class, which is defined in another file and represents the actual data contained in the block extension.\n\nThe class provides getter and setter methods for each instance variable, as well as methods for converting the object to a string representation and for checking equality with another object.\n\nThis class is likely used in the larger Ergo Explorer API project to represent block extensions in Java code and to serialize/deserialize them to/from JSON format. It may be used in conjunction with other classes and methods to provide a complete API for interacting with the Ergo blockchain. Here is an example of how this class might be used:\n\n```\n// Create a new BlockExtensionInfo object\nBlockExtensionInfo extension = new BlockExtensionInfo()\n    .headerId(\"12345\")\n    .digest(\"abcdef\")\n    .fields(new Fields());\n\n// Serialize the object to JSON format\nGson gson = new Gson();\nString json = gson.toJson(extension);\n\n// Deserialize the object from JSON format\nBlockExtensionInfo deserialized = gson.fromJson(json, BlockExtensionInfo.class);\n```\n## Questions: \n 1. What is the purpose of this code and what does it do?\n- This code is a model class for BlockExtensionInfo in the Ergo Explorer API. It contains information about a block's extension, including the header ID, extension digest, and fields.\n\n2. What is the significance of the @SerializedName and @Schema annotations?\n- The @SerializedName annotation is used to specify the name of the JSON property that corresponds to a Java field. The @Schema annotation is used to provide additional information about a field, such as its description and whether it is required.\n\n3. What is the purpose of the equals and hashCode methods?\n- The equals and hashCode methods are used to compare two instances of the BlockExtensionInfo class for equality. They compare the header ID, extension digest, and fields of the two instances and return true if they are equal, false otherwise. These methods are commonly used in collections such as sets and maps.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/BlockExtensionInfo.md"}}],["96",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/BlockInfo.java)\n\nThe `BlockInfo` class is a model class that represents a block in the Ergo blockchain. It contains information about the block such as its ID, height, epoch, version, timestamp, number of transactions, miner information, size, difficulty, and miner reward. \n\nThis class is used to represent a block in the Ergo Explorer API v1, which is a RESTful API that provides access to information about the Ergo blockchain. The API allows developers to retrieve information about blocks, transactions, addresses, and other data related to the Ergo blockchain. \n\nDevelopers can use this class to deserialize JSON responses from the Ergo Explorer API v1 into Java objects. For example, the following code snippet shows how to deserialize a JSON response into a `BlockInfo` object using the Gson library:\n\n```\nGson gson = new Gson();\nBlockInfo blockInfo = gson.fromJson(jsonResponse, BlockInfo.class);\n```\n\nWhere `jsonResponse` is a string containing the JSON response from the Ergo Explorer API v1. \n\nOnce the JSON response is deserialized into a `BlockInfo` object, developers can access the information about the block using the getter methods provided by the class. For example, to get the ID of the block, developers can call the `getId()` method:\n\n```\nString blockId = blockInfo.getId();\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `BlockInfo` which represents a block in the Ergo blockchain. It contains various properties of a block such as its ID, height, epoch, version, timestamp, transactions count, miner information, size, difficulty, and miner reward.\n\n2. What external libraries or dependencies does this code use?\n- This code uses the `com.google.gson` library for JSON serialization and deserialization, and the `io.swagger.v3.oas.annotations` package for OpenAPI annotations.\n\n3. Can the properties of a `BlockInfo` object be modified after it is created?\n- Yes, the `BlockInfo` class provides setter methods for all of its properties, so they can be modified after the object is created.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/BlockInfo.md"}}],["97",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/BlockReferencesInfo.java)\n\nThis code defines a Java class called `BlockReferencesInfo` which represents references to the previous and next blocks in a blockchain. The class has two private fields, `previousId` and `nextId`, which are both strings representing the IDs of the previous and next blocks respectively. The class has getter and setter methods for both fields, allowing other classes to access and modify the values of these fields.\n\nThe class also includes methods for equality checking, hashing, and string representation. These methods are used to compare instances of the `BlockReferencesInfo` class for equality, generate hash codes for instances of the class, and convert instances of the class to string representations, respectively.\n\nThis class is likely used in the larger project to represent the references to previous and next blocks in a blockchain. Other classes in the project may use instances of this class to access and modify these references. For example, a class representing a block in the blockchain may use an instance of `BlockReferencesInfo` to store the references to the previous and next blocks in the chain.\n\nExample usage:\n\n```\nBlockReferencesInfo blockRefs = new BlockReferencesInfo();\nblockRefs.setPreviousId(\"12345\");\nblockRefs.setNextId(\"67890\");\n\nSystem.out.println(blockRefs.getPreviousId()); // Output: 12345\nSystem.out.println(blockRefs.getNextId()); // Output: 67890\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `BlockReferencesInfo` that contains information about the previous and next blocks in a blockchain.\n\n2. What are the required fields for an instance of this class?\n- An instance of this class requires a `previousId` field, which is the ID of the previous block.\n\n3. What is the purpose of the `hashCode()` method in this class?\n- The `hashCode()` method is used to generate a hash code for an instance of this class, which can be used for various purposes such as storing objects in a hash table.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/BlockReferencesInfo.md"}}],["98",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/BlockSummary.java)\n\nThis code defines a Java class called `BlockSummary` that represents a summary of a block in the Ergo blockchain. The class has two properties: `block` and `references`, both of which are objects of other classes (`FullBlockInfo` and `BlockReferencesInfo`, respectively). \n\nThe `FullBlockInfo` class represents detailed information about a block, while the `BlockReferencesInfo` class represents information about the block's references to other blocks in the blockchain. \n\nThe `BlockSummary` class provides getter and setter methods for both properties, allowing other parts of the code to access and modify them. The class also overrides the `equals`, `hashCode`, and `toString` methods for proper comparison and string representation of `BlockSummary` objects.\n\nThis class is likely used in the larger Ergo Explorer API project to provide a high-level summary of a block's information, including its references to other blocks. Other parts of the project can use this class to easily access and manipulate this information. For example, a method in another class might take a `BlockSummary` object as a parameter and use its `getBlock()` method to access the detailed information about the block. \n\nHere is an example of how this class might be used in another part of the project:\n\n```\npublic void printBlockSummary(BlockSummary blockSummary) {\n    System.out.println(\"Block summary:\");\n    System.out.println(\"Block info: \" + blockSummary.getBlock());\n    System.out.println(\"References: \" + blockSummary.getReferences());\n}\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `BlockSummary` that contains a `FullBlockInfo` object and a `BlockReferencesInfo` object.\n\n2. What external libraries or dependencies does this code use?\n- This code uses the `com.google.gson` and `io.swagger.v3.oas.annotations` libraries.\n\n3. What is the expected input and output of this code?\n- This code does not have any input or output, as it only defines a Java class. However, the `BlockSummary` class can be used as a data model for other parts of the `ergo-appkit` project that deal with blocks and their references.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/BlockSummary.md"}}],["99",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/BoxQuery.java)\n\nThe `BoxQuery` class is a model class that represents a query for a box in the Ergo blockchain. A box is a data structure that contains assets and registers, and is used to store and transfer value in the blockchain. The purpose of this class is to provide a way to search for boxes that meet certain criteria.\n\nThe class has four fields: `ergoTreeTemplateHash`, `registers`, `constants`, and `assets`. The `ergoTreeTemplateHash` field is a SHA-256 hash of the ErgoTree template that the box script should have. The `registers` field is a map of register IDs and register values that the box should contain. The `constants` field is a map of constant indices and constant values that the box should contain. The `assets` field is a list of token IDs that the box should contain.\n\nThe class provides methods to set and get the values of these fields. For example, the `ergoTreeTemplateHash` field can be set using the `ergoTreeTemplateHash` method, and retrieved using the `getErgoTreeTemplateHash` method. Similarly, the `registers` field can be set using the `registers` method, and retrieved using the `getRegisters` method.\n\nThis class is used in the larger Ergo Explorer API project to search for boxes that meet certain criteria. For example, a user might want to search for boxes that contain a certain token, or that have a certain register value. The `BoxQuery` class provides a way to specify these criteria in a structured way, and to pass them to the API for processing. \n\nExample usage:\n\n```\nBoxQuery query = new BoxQuery()\n    .ergoTreeTemplateHash(\"1234567890abcdef\")\n    .putRegistersItem(\"R1\", \"hello\")\n    .addAssetsItem(\"token1\")\n    .addAssetsItem(\"token2\");\n```\n\nThis creates a `BoxQuery` object with an ErgoTree template hash of \"1234567890abcdef\", a register value of \"hello\" for register R1, and two token IDs (\"token1\" and \"token2\").\n## Questions: \n 1. What is the purpose of the `BoxQuery` class?\n- The `BoxQuery` class is a model class that represents a query for a box in the Ergo blockchain.\n\n2. What are the different properties of a `BoxQuery` object?\n- A `BoxQuery` object has four properties: `ergoTreeTemplateHash`, `registers`, `constants`, and `assets`.\n\n3. What is the format of the `ergoTreeTemplateHash` property?\n- The `ergoTreeTemplateHash` property is a SHA-256 hash of the ErgoTree template that the box script should have.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/BoxQuery.md"}}],["100",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/DataInputInfo.java)\n\nThe `DataInputInfo` class is part of the Ergo Explorer API v1 and is used to represent information about a data input in a transaction. This class contains various fields that provide information about the data input, such as the ID of the corresponding box, the number of nanoErgs in the corresponding box, the index of the input in a transaction, the ID of the transaction outputting the corresponding box, the index of the output corresponding to this input, the hex-encoded string of the ergo tree, the decoded address of the corresponding box holder, and a list of asset instances.\n\nThis class can be used in the larger project to represent data inputs in transactions. For example, if a developer is building a wallet application that interacts with the Ergo blockchain, they can use this class to represent data inputs when constructing transactions. The `DataInputInfo` class provides a convenient way to store and manipulate data input information, making it easier for developers to work with transactions.\n\nHere is an example of how this class can be used:\n\n```java\nDataInputInfo dataInput = new DataInputInfo()\n    .boxId(\"12345\")\n    .value(1000000000L)\n    .index(0)\n    .outputBlockId(\"67890\")\n    .outputTransactionId(\"54321\")\n    .outputIndex(1)\n    .ergoTree(\"abcdefg\")\n    .address(\"myAddress\")\n    .addAssetsItem(new AssetInstanceInfo().tokenId(\"token1\").amount(100))\n    .addAssetsItem(new AssetInstanceInfo().tokenId(\"token2\").amount(200))\n    .additionalRegisters(new AdditionalRegisters().put(\"key1\", \"value1\").put(\"key2\", \"value2\"));\n\nSystem.out.println(dataInput.getBoxId()); // Output: 12345\nSystem.out.println(dataInput.getValue()); // Output: 1000000000\nSystem.out.println(dataInput.getAssets().get(0).getTokenId()); // Output: token1\nSystem.out.println(dataInput.getAdditionalRegisters().get(\"key1\")); // Output: value1\n```\n\nIn this example, a new `DataInputInfo` object is created and various fields are set using the builder pattern. The `get` methods are then used to retrieve the values of the fields.\n## Questions: \n 1. What is the purpose of this code and what does it do?\n- This code defines a Java class called `DataInputInfo` which represents information about a data input in a blockchain transaction. It contains various properties such as the ID of the corresponding box, the number of nanoErgs in the box, the index of the input in the transaction, and so on.\n\n2. What external libraries or dependencies does this code rely on?\n- This code relies on the `com.google.gson` library for JSON serialization and deserialization, as well as the `io.swagger.v3.oas.annotations` package for OpenAPI annotations.\n\n3. What is the expected input and output format for this code?\n- The input format for this code is not specified, as it is a Java class that is meant to be used within a larger application. The output format is a JSON representation of the `DataInputInfo` object, which can be generated using the `com.google.gson` library.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/DataInputInfo.md"}}],["101",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/DataInputInfo1.java)\n\nThe code provided is a Java class called `DataInputInfo1` that is part of the `org.ergoplatform.explorer.client.model` package in the `ergo-appkit` project. This class is generated by the Swagger Codegen program and is used to represent a data input in the Ergo Explorer API. \n\nA data input is a reference to an existing box that is being spent in a transaction. This class contains information about the box being spent, such as its ID, the number of nanoErgs it contains, and its index in the transaction. It also contains information about the transaction that created the box, such as its ID and the index of the output that created the box. Additionally, it contains the decoded address of the box holder.\n\nThis class provides getters and setters for each of its fields, allowing other classes to access and modify its properties. It also overrides the `equals`, `hashCode`, and `toString` methods to provide a consistent way to compare and display instances of this class.\n\nThis class is likely used in conjunction with other classes in the `org.ergoplatform.explorer.client.model` package to represent transactions and boxes in the Ergo blockchain. For example, a transaction class might contain a list of data inputs, each represented by an instance of this class. \n\nHere is an example of how this class might be used to create a new data input:\n\n```\nDataInputInfo1 input = new DataInputInfo1()\n    .id(\"abc123\")\n    .value(1000000000L)\n    .index(0)\n    .transactionId(\"def456\")\n    .outputTransactionId(\"ghi789\")\n    .outputIndex(1)\n    .address(\"1erg1234abcd...\");\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `DataInputInfo1` which represents a data input in the Ergo Explorer API.\n\n2. What are the properties of a `DataInputInfo1` object?\n- A `DataInputInfo1` object has the following properties: `id` (String), `value` (Long), `index` (Integer), `transactionId` (String), `outputTransactionId` (String), `outputIndex` (Integer), and `address` (String).\n\n3. What is the purpose of the `equals`, `hashCode`, and `toString` methods?\n- These methods are used for object comparison and conversion to string representation. The `equals` method checks if two `DataInputInfo1` objects are equal, the `hashCode` method generates a hash code for a `DataInputInfo1` object, and the `toString` method returns a string representation of a `DataInputInfo1` object.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/DataInputInfo1.md"}}],["102",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/EpochParameters.java)\n\nThe `EpochParameters` class is a model class that represents the epoch parameters of the Ergo blockchain. It contains various fields that represent different parameters of an epoch, such as the `storageFeeFactor`, `maxBlockSize`, `maxBlockCost`, `blockVersion`, `tokenAccessCost`, `inputCost`, `dataInputCost`, and `outputCost`. \n\nThis class is generated by the Swagger Codegen program and should not be edited manually. It is used to provide a structured representation of epoch parameters that can be used by other classes in the Ergo Explorer API. \n\nFor example, if we have an API endpoint that returns epoch parameters, we can use this class to deserialize the response into an `EpochParameters` object. \n\n```java\n// Assuming we have an API client that returns epoch parameters\nEpochParameters epochParams = apiClient.getEpochParameters();\n\n// We can then access the different parameters of the epoch\nint storageFeeFactor = epochParams.getStorageFeeFactor();\nint maxBlockSize = epochParams.getMaxBlockSize();\nint maxBlockCost = epochParams.getMaxBlockCost();\n// ... and so on\n```\n\nOverall, the `EpochParameters` class is an important part of the Ergo Explorer API as it provides a standardized way of representing epoch parameters that can be used by other classes and endpoints.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `EpochParameters` which contains various parameters related to a blockchain epoch.\n\n2. What are the required parameters for an `EpochParameters` object?\n- The required parameters for an `EpochParameters` object are `id`, `height`, `storageFeeFactor`, `minValuePerByte`, `maxBlockSize`, `maxBlockCost`, `blockVersion`, `tokenAccessCost`, `inputCost`, `dataInputCost`, and `outputCost`.\n\n3. Is there any custom serialization or deserialization logic implemented for this class?\n- Yes, there is custom serialization and deserialization logic implemented for this class using the `com.google.gson` library.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/EpochParameters.md"}}],["103",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/Fields.java)\n\nThis code defines a Java class called `Fields` that extends the `java.util.HashMap` class. The purpose of this class is to represent a collection of key-value pairs, where the keys and values are both strings. The class is generated by the Swagger Codegen program, which is a tool for generating client libraries, server stubs, and documentation from OpenAPI (formerly Swagger) specifications.\n\nThe `Fields` class overrides several methods from the `java.util.HashMap` class, including `equals`, `hashCode`, and `toString`. The `equals` method checks if two `Fields` objects are equal by comparing their keys and values. The `hashCode` method returns a hash code for the `Fields` object based on its keys and values. The `toString` method returns a string representation of the `Fields` object, including its keys and values.\n\nThis class may be used in the larger project as a way to represent arbitrary collections of key-value pairs. For example, it could be used to represent HTTP headers, query parameters, or form data in an HTTP request. The `Fields` class provides a convenient way to manipulate these collections using familiar Java syntax, such as `put(key, value)` and `get(key)`. \n\nHere is an example of how the `Fields` class could be used to represent HTTP headers in an HTTP request:\n\n```\nimport org.ergoplatform.explorer.client.model.Fields;\n\nFields headers = new Fields();\nheaders.put(\"Content-Type\", \"application/json\");\nheaders.put(\"Authorization\", \"Bearer <token>\");\n\n// send HTTP request with headers\nHttpResponse response = HttpClient.sendRequest(url, \"GET\", headers);\n```\n\nIn this example, the `Fields` object `headers` is used to store the HTTP headers for an HTTP GET request. The `put` method is used to add headers to the collection, and the `get` method is used to retrieve headers from the collection. The `Fields` object is then passed to an HTTP client library to send the request.\n## Questions: \n 1. What is the purpose of the `Fields` class?\n- The `Fields` class is a subclass of `java.util.HashMap` and represents a collection of key-value pairs.\n\n2. What is the significance of the `@Override` annotations in this code?\n- The `@Override` annotations indicate that the methods being annotated are overriding methods from a superclass or interface.\n\n3. Why is the `toString()` method overridden in the `Fields` class?\n- The `toString()` method is overridden to provide a custom string representation of the `Fields` object when it is printed or logged.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/Fields.md"}}],["104",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/FullBlockInfo.java)\n\nThis code defines a Java class called `FullBlockInfo` that represents a full block in the Ergo blockchain. The class has four instance variables: `header`, `blockTransactions`, `extension`, and `adProofs`. \n\nThe `header` variable is an instance of the `HeaderInfo` class, which contains information about the block header. The `blockTransactions` variable is a list of `TransactionInfo1` objects, which represent the transactions in the block. The `extension` variable is an instance of the `BlockExtensionInfo` class, which contains additional information about the block. The `adProofs` variable is a string that contains serialized hex-encoded AD Proofs.\n\nThe class provides getter and setter methods for each instance variable, as well as methods to add a `TransactionInfo1` object to the `blockTransactions` list and to convert the object to a string.\n\nThis class is likely used in the larger Ergo appkit project to represent full blocks in the Ergo blockchain. It can be used to retrieve information about a block's header, transactions, and extension, as well as its AD Proofs. For example, a developer could use this class to retrieve the header of the most recent block in the blockchain:\n\n```\nFullBlockInfo block = // retrieve the most recent block\nHeaderInfo header = block.getHeader();\n```\n\nOverall, this code provides a convenient way to represent and manipulate full blocks in the Ergo blockchain.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `FullBlockInfo` which represents a full block information in the Ergo Explorer API.\n\n2. What are the properties of the `FullBlockInfo` class?\n- The `FullBlockInfo` class has four properties: `header` of type `HeaderInfo`, `blockTransactions` of type `List<TransactionInfo1>`, `extension` of type `BlockExtensionInfo`, and `adProofs` of type `String`.\n\n3. What is the purpose of the `adProofs` property?\n- The `adProofs` property is a serialized hex-encoded AD Proofs, which is a cryptographic proof that a transaction was included in a block.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/FullBlockInfo.md"}}],["105",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/HeaderInfo.java)\n\nThe `HeaderInfo` class is a model class that represents the header information of a block in the Ergo blockchain. It contains various fields that provide information about the block, such as its ID, version, height, epoch, difficulty, and various root hashes. \n\nThis class is used in the Ergo Explorer API to provide information about blocks to clients. The API returns instances of this class as JSON objects, which can be deserialized into instances of this class in client code. \n\nFor example, a client could make a request to the API to retrieve the header information for a specific block, and the API would return a JSON object representing an instance of the `HeaderInfo` class. The client could then deserialize this JSON object into an instance of the `HeaderInfo` class and use its fields to access the block's information. \n\nHere is an example of how a client could use an instance of the `HeaderInfo` class:\n\n```java\nHeaderInfo headerInfo = // retrieve header info from API\nSystem.out.println(\"Block ID: \" + headerInfo.getId());\nSystem.out.println(\"Block height: \" + headerInfo.getHeight());\nSystem.out.println(\"Block difficulty: \" + headerInfo.getDifficulty());\n// etc.\n```\n\nOverall, the `HeaderInfo` class is an important part of the Ergo Explorer API, providing clients with information about blocks in the Ergo blockchain.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `HeaderInfo` that represents a block/header in the Ergo blockchain. It contains various properties such as ID, height, difficulty, and timestamps.\n\n2. What external libraries or dependencies does this code use?\n- The code imports `java.util.Objects` and `com.google.gson.annotations.SerializedName` packages. It also uses annotations from `io.swagger.v3.oas.annotations.media.Schema`.\n\n3. What is the format of the data that this code handles?\n- The data format is JSON, as indicated by the use of `@SerializedName` annotations and the `com.google.gson` package. The class is generated by Swagger Codegen, which suggests that it is part of a larger API project.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/HeaderInfo.md"}}],["106",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/InputInfo.java)\n\nThe `InputInfo` class is a model class that represents an input to a transaction in the Ergo blockchain. It contains various fields that provide information about the input, such as the ID of the corresponding box, the number of nanoErgs in the box, the index of the input in the transaction, and the hex-encoded serialized sigma proof. \n\nThe class also contains fields that provide information about the output of the transaction that corresponds to the input, such as the modifier ID, the ID of the transaction outputting the corresponding box, and the index of the output corresponding to the input. Additionally, the class contains fields that provide information about the box holder, such as the decoded address of the corresponding box holder and the assets associated with the input.\n\nThis class is used in the larger Ergo Explorer API project to represent inputs to transactions in the Ergo blockchain. It can be used to deserialize JSON responses from the Ergo Explorer API into Java objects, and to serialize Java objects into JSON requests to the API. \n\nFor example, to deserialize a JSON response from the Ergo Explorer API into an `InputInfo` object, the following code can be used:\n\n```\nGson gson = new Gson();\nInputInfo inputInfo = gson.fromJson(jsonString, InputInfo.class);\n```\n\nWhere `jsonString` is the JSON response string. Similarly, to serialize an `InputInfo` object into a JSON request to the Ergo Explorer API, the following code can be used:\n\n```\nGson gson = new Gson();\nString jsonRequest = gson.toJson(inputInfo);\n```\n\nWhere `inputInfo` is the `InputInfo` object to be serialized.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `InputInfo` which represents input information for a transaction in the Ergo blockchain.\n\n2. What are the required fields for an `InputInfo` object?\n- The required fields are `boxId`, `value`, `index`, `outputBlockId`, `outputTransactionId`, `outputIndex`, `ergoTree`, `address`, and `additionalRegisters`.\n\n3. What is the purpose of the `assets` field in an `InputInfo` object?\n- The `assets` field is a list of `AssetInstanceInfo` objects representing the assets held in the corresponding box.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/InputInfo.md"}}],["107",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/InputInfo1.java)\n\nThe code provided is a Java class called `InputInfo1` that represents an input of a transaction in the Ergo blockchain. The purpose of this class is to provide a model for the input information that can be used by other classes in the Ergo Explorer API. \n\nThe `InputInfo1` class has eight properties: `id`, `value`, `index`, `spendingProof`, `transactionId`, `outputTransactionId`, `outputIndex`, and `address`. These properties represent the different attributes of an input in a transaction. \n\nThe `id` property is a string that represents the ID of the corresponding box. The `value` property is a long integer that represents the number of nanoErgs in the corresponding box. The `index` property is an integer that represents the index of the input in a transaction. The `spendingProof` property is a string that represents the hex-encoded serialized sigma proof. The `transactionId` property is a string that represents the ID of the transaction this input was used in. The `outputTransactionId` property is a string that represents the ID of the transaction outputting the corresponding box. The `outputIndex` property is an integer that represents the index of the output corresponding to this input. Finally, the `address` property is a string that represents the decoded address of the corresponding box holder.\n\nThe `InputInfo1` class provides getter and setter methods for each property, allowing other classes to access and modify the input information. Additionally, the class overrides the `equals`, `hashCode`, and `toString` methods to provide a consistent way of comparing and displaying instances of the class.\n\nOverall, the `InputInfo1` class is an important part of the Ergo Explorer API, as it provides a model for representing input information in the Ergo blockchain. Other classes in the API can use this model to interact with inputs in a standardized way. \n\nExample usage:\n\n```java\nInputInfo1 input = new InputInfo1();\ninput.setId(\"abc123\");\ninput.setValue(1000000000L);\ninput.setIndex(0);\ninput.setTransactionId(\"def456\");\ninput.setAddress(\"A9GJ9J8H7G6F5D4S3A2S1D4F5G6H7J8K9L0\");\nSystem.out.println(input.toString());\n```\n\nOutput:\n```\nclass InputInfo1 {\n    id: abc123\n    value: 1000000000\n    index: 0\n    spendingProof: null\n    transactionId: def456\n    outputTransactionId: null\n    outputIndex: null\n    address: A9GJ9J8H7G6F5D4S3A2S1D4F5G6H7J8K9L0\n}\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `InputInfo1` which represents input information for a transaction in the Ergo Explorer API.\n\n2. What are the required fields for an instance of `InputInfo1`?\n- An instance of `InputInfo1` requires the `id` and `index` fields to be set.\n\n3. What is the purpose of the `spendingProof` field?\n- The `spendingProof` field contains a hex-encoded serialized sigma proof, which is used to prove that the transaction input is authorized to spend the corresponding box.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/InputInfo1.md"}}],["108",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/Items.java)\n\nThe code defines a generic class called `Items` that represents a collection of items of type `T`. The class has two instance variables: `items` and `total`. `items` is a list of items of type `T`, while `total` is an integer that represents the total number of items in the collection. \n\nThe class provides methods to get and set the values of these instance variables. The `items` method returns the list of items, while the `total` method returns the total number of items. The `setItems` method sets the value of the `items` instance variable, while the `setTotal` method sets the value of the `total` instance variable. \n\nThe class also provides a method called `addItemsItem` that adds an item of type `T` to the `items` list. If the `items` list is null, it creates a new list and adds the item to it. \n\nThe class overrides the `equals`, `hashCode`, and `toString` methods. The `equals` method compares two `Items` objects for equality based on their `items` and `total` instance variables. The `hashCode` method returns a hash code value for the `Items` object based on its `items` and `total` instance variables. The `toString` method returns a string representation of the `Items` object, including its `items` and `total` instance variables. \n\nThis class can be used to represent any collection of items of a generic type `T` in the Ergo Explorer API. For example, it could be used to represent a collection of transactions, blocks, or addresses. The `total` instance variable could be used to represent the total number of items in the collection, while the `items` instance variable could be used to represent the list of items. The `addItemsItem` method could be used to add items to the list.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a generic class called `Items` that contains a list of items and a total count.\n\n2. What is the significance of the `@SerializedName` and `@Schema` annotations?\n- `@SerializedName` is used to specify the name of the serialized JSON property for a field. `@Schema` is used to provide additional information about a field for documentation purposes.\n\n3. What is the purpose of the `equals`, `hashCode`, and `toString` methods?\n- These methods are used to implement object comparison, hashing, and string representation for instances of the `Items` class. They are important for proper functioning of collections and debugging.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/Items.md"}}],["109",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/ItemsA.java)\n\nThe code above defines a class called `ItemsA` which extends a generic class called `Items`. The generic type parameter for `Items` is `OutputInfo`, which means that `ItemsA` is a specialized version of `Items` that specifically deals with a collection of `OutputInfo` objects.\n\nThe purpose of this code is to provide a convenient way to work with collections of `OutputInfo` objects within the larger `ergo-appkit` project. By extending the `Items` class, `ItemsA` inherits all of the methods and properties of `Items`, while also adding any additional functionality specific to `OutputInfo`.\n\nFor example, if we have a list of `OutputInfo` objects that we want to work with, we can create an instance of `ItemsA` and pass in the list as a parameter:\n\n```\nList<OutputInfo> outputList = // some list of OutputInfo objects\nItemsA outputItems = new ItemsA(outputList);\n```\n\nWe can then use the methods provided by `ItemsA` to manipulate the collection of `OutputInfo` objects. For example, we can get the size of the collection:\n\n```\nint size = outputItems.size();\n```\n\nOr we can get a specific `OutputInfo` object by its index:\n\n```\nOutputInfo output = outputItems.get(0);\n```\n\nOverall, the `ItemsA` class provides a convenient way to work with collections of `OutputInfo` objects within the `ergo-appkit` project. By extending the `Items` class, it inherits all of the functionality of `Items`, while also adding any additional functionality specific to `OutputInfo`.\n## Questions: \n 1. What is the purpose of the `ItemsA` class?\n   - The `ItemsA` class extends the `Items` class and specifies that it will contain objects of type `OutputInfo`.\n2. What is the `Items` class and what does it do?\n   - Without seeing the code for the `Items` class, it is unclear what it does. However, based on this code, we can assume that it is a generic class that can contain a list of objects of a specified type.\n3. What is the `OutputInfo` class and how is it related to the rest of the project?\n   - Without more context about the project, it is unclear what the `OutputInfo` class represents or how it is used within the `ergo-appkit` project.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/ItemsA.md"}}],["110",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/ListOutputInfo.java)\n\nThis code defines a Java class called `ListOutputInfo` which implements an interface called `OneOfListOutputInfo`. The purpose of this class is not entirely clear from the code provided, but it appears to be related to the Ergo Explorer API, which is a tool for exploring the Ergo blockchain. \n\nThe class contains three methods: `equals()`, `hashCode()`, and `toString()`. The `equals()` method compares two `ListOutputInfo` objects for equality, while the `hashCode()` method generates a hash code for the object. The `toString()` method returns a string representation of the object.\n\nThe `ListOutputInfo` class does not contain any fields or properties, and the `toString()` method does not output any information about the object. Therefore, it is unclear what the purpose of this class is or how it might be used in the larger project.\n\nWithout more context, it is difficult to provide a more detailed explanation of this code. However, it appears to be a small part of a larger project related to the Ergo blockchain.\n## Questions: \n 1. What is the purpose of the `ListOutputInfo` class?\n- The `ListOutputInfo` class is a model class that implements the `OneOfListOutputInfo` interface.\n\n2. What is the `OneOfListOutputInfo` interface?\n- The `OneOfListOutputInfo` interface is not defined in this code snippet, so a smart developer might want to look for its definition in another file or library.\n\n3. What is the expected behavior of the `equals` and `hashCode` methods in this class?\n- The `equals` method returns `true` if the given object is of the same class as `ListOutputInfo`, and the `hashCode` method returns a hash value based on no properties of the class. This behavior might be insufficient for certain use cases, so a smart developer might want to override these methods.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/ListOutputInfo.md"}}],["111",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/MapV.java)\n\nThis code defines a Java class called `MapV` that extends the `java.util.HashMap` class. The purpose of this class is to represent a map of key-value pairs where both the keys and values are strings. The class overrides the `equals` and `hashCode` methods inherited from the `HashMap` class to provide custom implementations that compare two `MapV` objects based on their contents rather than their memory addresses. The `toString` method is also overridden to provide a string representation of the `MapV` object that includes the contents of the map.\n\nThis class may be used in the larger project as a data structure for storing and manipulating maps of string key-value pairs. For example, it could be used to represent configuration settings or user preferences. The `MapV` class provides a convenient way to work with such maps in Java code, as it inherits all the methods of the `HashMap` class and adds custom implementations of key methods for comparing and printing `MapV` objects.\n\nHere is an example of how the `MapV` class could be used in Java code:\n\n```\nMapV config = new MapV();\nconfig.put(\"server\", \"localhost\");\nconfig.put(\"port\", \"8080\");\nconfig.put(\"username\", \"admin\");\nconfig.put(\"password\", \"secret\");\n\nSystem.out.println(config.get(\"server\")); // prints \"localhost\"\nSystem.out.println(config.get(\"port\")); // prints \"8080\"\nSystem.out.println(config.get(\"username\")); // prints \"admin\"\nSystem.out.println(config.get(\"password\")); // prints \"secret\"\n```\n## Questions: \n 1. What is the purpose of the `MapV` class?\n   - The `MapV` class extends the `java.util.HashMap` class and represents a map of key-value pairs where both keys and values are strings.\n\n2. Why does the `MapV` class override the `equals` and `hashCode` methods?\n   - The `MapV` class overrides the `equals` and `hashCode` methods to ensure that two instances of `MapV` are considered equal if they contain the same key-value pairs.\n\n3. What is the purpose of the `toString` and `toIndentedString` methods?\n   - The `toString` method returns a string representation of the `MapV` object, while the `toIndentedString` method is a helper method that indents each line of the string representation by 4 spaces.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/MapV.md"}}],["112",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/MinerInfo.java)\n\nThis code defines a Java class called `MinerInfo` which represents information about a miner in the Ergo blockchain network. The class has two properties: `address` and `name`, both of which are strings. The `address` property represents the miner's reward address, while the `name` property represents the miner's name.\n\nThe class has two methods for setting the values of these properties: `address()` and `name()`. Both methods return an instance of the `MinerInfo` class, which allows for method chaining. For example, the following code sets the `address` and `name` properties of a `MinerInfo` object in a single statement:\n\n```\nMinerInfo miner = new MinerInfo()\n    .address(\"abc123\")\n    .name(\"John Doe\");\n```\n\nThe class also has getter and setter methods for each property. The getter methods are annotated with `@Schema` to indicate that they are required properties.\n\nThe class overrides the `equals()`, `hashCode()`, and `toString()` methods to provide basic object comparison and string representation functionality.\n\nThis class is likely used in the larger Ergo Explorer API project to represent miner information in various contexts, such as in responses to API requests or in database records. Other classes in the project may use instances of `MinerInfo` to store or manipulate miner information.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `MinerInfo` that represents information about a miner, including their reward address and name.\n\n2. What external libraries or dependencies does this code use?\n- This code uses the `com.google.gson` and `io.swagger.v3.oas.annotations` libraries.\n\n3. Can the `address` and `name` fields be null?\n- No, both `address` and `name` fields are marked as required in the Swagger/OpenAPI annotations, so they cannot be null.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/MinerInfo.md"}}],["113",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/Nil.java)\n\nThis code defines a class called `Nil` which implements the `OneOfListOutputInfo` interface. The purpose of this class is not entirely clear from the code provided, but it appears to be a placeholder or null object used in the context of a list output. \n\nThe `Nil` class has no properties or methods of its own, but it overrides several methods inherited from the `Object` class and the `OneOfListOutputInfo` interface. The `equals()` method checks if the given object is the same instance as `this`, and the `hashCode()` method returns a hash code value for the object. The `toString()` method returns a string representation of the object, which in this case is an empty string. \n\nThe `OneOfListOutputInfo` interface is not defined in this file, but it is likely used elsewhere in the `ergo-appkit` project to represent different types of output that can be returned from a list. The `Nil` class may be used as a placeholder in cases where the list is empty or no valid output is available. \n\nHere is an example of how the `Nil` class might be used in the context of a list output:\n\n```\nList<OneOfListOutputInfo> myList = new ArrayList<>();\nif (myList.isEmpty()) {\n    myList.add(new Nil());\n}\n```\n\nIn this example, if the `myList` is empty, a new `Nil` object is added to the list as a placeholder. This allows the list to be processed without encountering null values or other errors. \n\nOverall, the `Nil` class is a simple but useful component of the `ergo-appkit` project that helps to ensure robust and reliable list processing.\n## Questions: \n 1. What is the purpose of the `Nil` class?\n- The `Nil` class is a model class that implements the `OneOfListOutputInfo` interface and represents an empty list.\n\n2. Why is the `equals` method overridden in this class?\n- The `equals` method is overridden to compare instances of the `Nil` class for equality.\n\n3. What is the significance of the `hashCode` method in this class?\n- The `hashCode` method is used to generate a hash code for instances of the `Nil` class, which is required for certain operations in Java collections. Since the `Nil` class has no fields, its hash code is simply the hash code of an empty object.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/Nil.md"}}],["114",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/NotFound.java)\n\nThis code defines a Java class called `NotFound` that represents a response object returned by the Ergo Explorer API. The `NotFound` class has two properties: `status` and `reason`, both of which are serialized using the Gson library. The `status` property is an integer that represents the HTTP status code of the response, while the `reason` property is a string that provides a human-readable explanation of why the requested resource was not found.\n\nThis class is used in the Ergo Explorer API to provide a standardized response format for requests that result in a 404 Not Found error. By using this class, the API can ensure that clients receive a consistent response format regardless of the specific resource that was not found.\n\nHere is an example of how this class might be used in the larger Ergo Explorer project:\n\n```java\nimport org.ergoplatform.explorer.client.api.NotFoundException;\nimport org.ergoplatform.explorer.client.api.ExplorerApi;\nimport org.ergoplatform.explorer.client.model.NotFound;\n\nExplorerApi api = new ExplorerApi();\ntry {\n    // Make a request to the API to retrieve a resource that does not exist\n    api.getResource(\"nonexistent-resource\");\n} catch (NotFoundException e) {\n    // Handle the 404 Not Found error by parsing the response body as a NotFound object\n    NotFound notFound = e.getResponseBody();\n    System.out.println(\"Resource not found: \" + notFound.getReason());\n}\n```\n\nIn this example, the `ExplorerApi` class is used to make a request to the Ergo Explorer API to retrieve a resource that does not exist. If the API returns a 404 Not Found error, the `NotFoundException` is caught and the response body is parsed as a `NotFound` object. The `reason` property of the `NotFound` object is then used to provide a user-friendly error message to the client.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `NotFound` that represents a response object for a 404 error.\n\n2. What dependencies does this code have?\n- This code depends on the `com.google.gson` and `io.swagger.v3.oas.annotations` packages.\n\n3. Can this code be modified manually?\n- No, this code should not be edited manually as it is auto-generated by the Swagger Codegen program.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/NotFound.md"}}],["115",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/OneOfListOutputInfo.java)\n\nThis code defines an interface called \"OneOfListOutputInfo\" within the \"org.ergoplatform.explorer.client.model\" package. The purpose of this interface is not immediately clear from the code itself, but it is likely used as part of the Ergo Explorer API v1, which is described as a Swagger-generated API for exploring the Ergo blockchain.\n\nInterfaces in Java are used to define a set of methods that a class must implement if it implements the interface. In this case, any class that implements the OneOfListOutputInfo interface will need to provide implementations for all of its methods. However, since there are no methods defined in this interface, it is likely that it is used as a marker interface to indicate that a class belongs to a certain group or category.\n\nWithout more context about the Ergo Explorer API and how this interface is used within it, it is difficult to provide more specific information about its purpose. However, it is likely that other classes within the org.ergoplatform.explorer.client.model package implement this interface and provide more specific functionality related to exploring the Ergo blockchain.\n\nExample usage:\n\n```java\npublic class MyOutputInfo implements OneOfListOutputInfo {\n  // Implementations of methods required by OneOfListOutputInfo\n}\n\nMyOutputInfo outputInfo = new MyOutputInfo();\n// Use outputInfo as an instance of OneOfListOutputInfo\n```\n## Questions: \n 1. What is the purpose of this code file?\n- This code file is an interface for OneOfListOutputInfo in the Ergo Explorer API v1.\n\n2. What is the relationship between this code file and the rest of the ergo-appkit project?\n- It is unclear from this code file alone what the relationship is between this interface and the rest of the ergo-appkit project.\n\n3. Can this interface be edited or modified by developers?\n- The comments in the code file indicate that it should not be edited manually, but it is unclear if it can be modified through the Swagger Codegen program.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/OneOfListOutputInfo.md"}}],["116",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/OutputInfo.java)\n\nThe `OutputInfo` class is a model class that represents the output of a transaction in the Ergo blockchain. It contains information about the box that was created as a result of the transaction, such as its ID, the ID of the transaction that created it, the ID of the block it was included in, its value in nanoERG, its index in the transaction, the height at which it was created, the height at which it was fixed in the blockchain, the serialized Ergo tree, the address derived from the Ergo tree, the assets associated with the box, the additional registers, the ID of the transaction that spent the output, and a boolean flag indicating whether the box is on the main chain.\n\nThis class is used in the Ergo Explorer API to represent the output of a transaction. It can be used to retrieve information about a specific output, such as its value, assets, and address. For example, the following code retrieves the value of an output:\n\n```\nOutputInfo output = ...; // get the output from the API\nLong value = output.getValue();\n```\n\nSimilarly, the following code retrieves the assets associated with an output:\n\n```\nOutputInfo output = ...; // get the output from the API\nList<AssetInstanceInfo> assets = output.getAssets();\n```\n\nOverall, the `OutputInfo` class is an important part of the Ergo Explorer API, as it provides a convenient way to retrieve information about the outputs of transactions in the Ergo blockchain.\n## Questions: \n 1. What is the purpose of the `OutputInfo` class?\n- The `OutputInfo` class is a model class that represents information about a transaction output in the Ergo Explorer API.\n\n2. What are some of the properties of an `OutputInfo` object?\n- Some of the properties of an `OutputInfo` object include the box ID, transaction ID, block ID, value, index, creation height, settlement height, ergo tree, address, assets, additional registers, spent transaction ID, and main chain.\n\n3. What is the purpose of the `toIndentedString` method?\n- The `toIndentedString` method is a helper method that converts an object to a string with each line indented by 4 spaces, except for the first line. It is used in the `toString` method to format the output of the `OutputInfo` object.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/OutputInfo.md"}}],["117",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/OutputInfo1.java)\n\nThe `OutputInfo1` class is a model class that represents an output of a transaction in the Ergo blockchain. It contains information about the output such as its ID, the ID of the transaction that created it, its value in nanoERG, its index in the transaction, the height at which it was created, the serialized Ergo tree, the address derived from the Ergo tree, the list of asset instances associated with the output, additional registers, the ID of the transaction that spent the output, and a boolean flag indicating whether the output is on the main chain.\n\nThis class is used in the Ergo Explorer API v1 to provide information about outputs to clients. It is generated by the Swagger Codegen program and should not be edited manually. \n\nHere is an example of how this class can be used in Java code:\n\n```java\nOutputInfo1 output = new OutputInfo1();\noutput.setId(\"123\");\noutput.setTxId(\"456\");\noutput.setValue(1000000000L);\noutput.setIndex(0);\noutput.setCreationHeight(1000);\noutput.setErgoTree(\"0000000000000000000000000000000000000000000000000000000000000000\");\noutput.setAddress(\"9f5ebf1f4ce6cee6d7f8a5e8e6b7e5f0\");\noutput.setAssets(new ArrayList<AssetInstanceInfo>());\noutput.setAdditionalRegisters(new AdditionalRegisters1());\noutput.setSpentTransactionId(\"789\");\noutput.setMainChain(true);\n```\n\nIn this example, a new `OutputInfo1` object is created and its properties are set using the setter methods. This object can then be used to represent an output in the Ergo blockchain.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `OutputInfo1` which represents information about a transaction output in the Ergo blockchain.\n\n2. What are the required fields for an `OutputInfo1` object?\n- The required fields for an `OutputInfo1` object are `id`, `txId`, `value`, `index`, `creationHeight`, `ergoTree`, `address`, and `additionalRegisters`.\n\n3. What is the purpose of the `assets` field in an `OutputInfo1` object?\n- The `assets` field is a list of `AssetInstanceInfo` objects that represent any assets associated with the transaction output.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/OutputInfo1.md"}}],["118",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/PowSolutionInfo.java)\n\nThis code defines a Java class called `PowSolutionInfo` that represents a data model for a proof-of-work solution. The class has four private fields: `pk`, `w`, `n`, and `d`, which are all strings. The `pk` field represents the public key of the miner who found the solution, while the `w`, `n`, and `d` fields are all hex-encoded strings that represent different parts of the solution.\n\nThe class provides getter and setter methods for each field, as well as an `equals` method that compares two `PowSolutionInfo` objects for equality based on their fields. It also provides a `toString` method that returns a string representation of the object.\n\nThis class is likely used in the larger project to represent proof-of-work solutions that are found by miners in the Ergo blockchain network. It may be used in conjunction with other classes and methods to validate and verify these solutions, as well as to store and retrieve them from a database or other data store.\n\nExample usage:\n\n```\nPowSolutionInfo solution = new PowSolutionInfo()\n    .pk(\"abc123\")\n    .w(\"deadbeef\")\n    .n(\"cafebab\")\n    .d(\"facefeed\");\n\nString pk = solution.getPk(); // \"abc123\"\nString w = solution.getW(); // \"deadbeef\"\nString n = solution.getN(); // \"cafebab\"\nString d = solution.getD(); // \"facefeed\"\n\nboolean isEqual = solution.equals(otherSolution); // true or false\nString solutionString = solution.toString(); // \"PowSolutionInfo { pk: abc123, w: deadbeef, n: cafebab, d: facefeed }\"\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `PowSolutionInfo` which contains fields for miner public key, hex-encoded strings, and Autolykos.d.\n\n2. What is the expected input and output of this code?\n- This code does not have any input or output as it only defines a Java class.\n\n3. What is the significance of the `@Schema` annotation in this code?\n- The `@Schema` annotation is used to provide a description of the fields in the `PowSolutionInfo` class for documentation purposes.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/PowSolutionInfo.md"}}],["119",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/TokenAmount.java)\n\nThis code defines a Java class called `TokenAmount` that represents a token and its associated amount. The class has four properties: `tokenId`, `amount`, `decimals`, and `name`. \n\n`tokenId` is a string that represents the unique identifier of the token. `amount` is a long integer that represents the amount of the token. `decimals` is an integer that represents the number of decimal places used to represent the token amount. `name` is a string that represents the name of the token.\n\nThe class also has getter and setter methods for each property, as well as methods for setting the properties in a fluent style. Additionally, the class overrides the `equals`, `hashCode`, and `toString` methods for object comparison and string representation.\n\nThis class is likely used in the larger project to represent token amounts in various contexts, such as in transactions or in user wallets. For example, a transaction object may contain one or more `TokenAmount` objects to represent the tokens being transferred. \n\nHere is an example of how this class might be used:\n\n```\nTokenAmount tokenAmount = new TokenAmount()\n    .tokenId(\"abc123\")\n    .amount(1000L)\n    .decimals(2)\n    .name(\"My Token\");\n\nSystem.out.println(tokenAmount.getAmount()); // Output: 1000\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `TokenAmount` which represents a token with its ID, amount, number of decimals, and name.\n\n2. What external libraries or dependencies does this code use?\n- This code uses the `com.google.gson` and `io.swagger.v3.oas.annotations` libraries.\n\n3. Can the properties of a `TokenAmount` object be null?\n- Yes, the `name` property is not required and can be null.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/TokenAmount.md"}}],["120",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/TokenInfo.java)\n\nThe `TokenInfo` class is a model class that represents information about a token asset in the Ergo Explorer API. It contains fields for the ID of the asset, the box ID it was issued by, the emission amount, name, description, type, and number of decimal places. \n\nThis class is generated automatically by the Swagger Codegen program and should not be edited manually. It includes annotations for the OpenAPI specification version 1.0 and the Gson library for JSON serialization and deserialization. \n\nThis class can be used in the larger project to represent token assets in the Ergo Explorer API. For example, it can be used to deserialize JSON responses from the API into Java objects that can be manipulated and displayed in the user interface. \n\nHere is an example of how this class can be used to deserialize a JSON response from the API:\n\n```java\nimport com.google.gson.Gson;\n\n// assume json is a String containing a JSON response from the API\nString json = \"{...}\";\n\n// create a Gson object to deserialize the JSON\nGson gson = new Gson();\n\n// deserialize the JSON into a TokenInfo object\nTokenInfo tokenInfo = gson.fromJson(json, TokenInfo.class);\n\n// access the fields of the TokenInfo object\nString id = tokenInfo.getId();\nString name = tokenInfo.getName();\n// etc.\n```\n\nOverall, the `TokenInfo` class is an important part of the Ergo Explorer API and can be used to represent token assets in the larger project.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `TokenInfo` which represents information about a token asset.\n\n2. What are the required fields for a `TokenInfo` object?\n- A `TokenInfo` object requires an `id` and a `boxId` field.\n\n3. What is the purpose of the `emissionAmount` field?\n- The `emissionAmount` field represents the number of decimal places for the token asset.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/TokenInfo.md"}}],["121",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/TotalBalance.java)\n\nThis code defines a Java class called `TotalBalance` which represents the total balance of a particular account in a cryptocurrency called Ergo. The class has two instance variables: `confirmed` and `unconfirmed`, both of which are of type `Balance`. The `Balance` class is defined in another file and is not shown here.\n\nThe `TotalBalance` class has two getter and setter methods for the `confirmed` and `unconfirmed` instance variables. These methods allow other parts of the code to access and modify the values of these variables.\n\nThe class also has several methods that are used for serialization and deserialization of JSON data. These methods are used to convert instances of the `TotalBalance` class to and from JSON format, which is a common data format used in web applications.\n\nOverall, this class is a simple data model that represents the total balance of an Ergo account. It can be used in other parts of the Ergo app to display the total balance of a user's account or to perform calculations on the total balance. For example, the following code snippet shows how an instance of the `TotalBalance` class can be created and initialized:\n\n```\nBalance confirmedBalance = new Balance(1000);\nBalance unconfirmedBalance = new Balance(500);\nTotalBalance totalBalance = new TotalBalance()\n    .confirmed(confirmedBalance)\n    .unconfirmed(unconfirmedBalance);\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `TotalBalance` that represents the total balance of a cryptocurrency wallet, including both confirmed and unconfirmed balances.\n\n2. What external libraries or dependencies does this code use?\n- This code uses the `com.google.gson` and `io.swagger.v3.oas` libraries for JSON serialization and deserialization, and for OpenAPI schema annotations.\n\n3. What is the expected input and output of this code?\n- This code expects input in the form of JSON data that conforms to the `TotalBalance` schema, and outputs an instance of the `TotalBalance` class that contains the confirmed and unconfirmed balances.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/TotalBalance.md"}}],["122",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/TransactionInfo.java)\n\nThe `TransactionInfo` class is a model class that represents a transaction in the Ergo blockchain. It contains information about the transaction such as its ID, the ID of the block it was included in, the height of the block, the timestamp, the index of the transaction in the block, the number of confirmations, the inputs, data inputs, outputs, and the size of the transaction in bytes.\n\nThis class is used in the Ergo Explorer API to provide information about transactions to clients. It is generated by the Swagger Codegen program and should not be edited manually.\n\nHere is an example of how this class can be used:\n\n```java\nTransactionInfo transaction = new TransactionInfo()\n    .id(\"12345\")\n    .blockId(\"67890\")\n    .inclusionHeight(100)\n    .timestamp(1625678910L)\n    .index(0)\n    .numConfirmations(5)\n    .addInputsItem(new InputInfo())\n    .addDataInputsItem(new DataInputInfo())\n    .addOutputsItem(new OutputInfo())\n    .size(200);\n\nSystem.out.println(transaction.toString());\n```\n\nThis will create a new `TransactionInfo` object with the specified values and print out its string representation.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `TransactionInfo` that represents information about a transaction in the Ergo blockchain.\n\n2. What are the properties of a `TransactionInfo` object?\n- A `TransactionInfo` object has properties such as `id`, `blockId`, `inclusionHeight`, `timestamp`, `index`, `numConfirmations`, `inputs`, `dataInputs`, `outputs`, and `size`.\n\n3. What is the purpose of the `equals`, `hashCode`, and `toString` methods?\n- These methods are used for object comparison and printing. `equals` and `hashCode` are used for comparing two `TransactionInfo` objects, while `toString` is used for printing a `TransactionInfo` object as a string.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/TransactionInfo.md"}}],["123",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/TransactionInfo1.java)\n\nThe `TransactionInfo1` class is a model class that represents a transaction in the Ergo blockchain. It contains information about the transaction such as its ID, the ID of the corresponding header, the height of the block the transaction was included in, the timestamp the transaction got into the network, the index of the transaction inside a block, the number of transaction confirmations, and lists of inputs, data inputs, and outputs.\n\nThis class is generated by the Swagger Codegen program and should not be edited manually. It is used by other classes in the `org.ergoplatform.explorer.client.model` package to represent transactions in the Ergo blockchain.\n\nHere is an example of how this class might be used in the larger project:\n\n```java\nimport org.ergoplatform.explorer.client.api.TransactionsApi;\nimport org.ergoplatform.explorer.client.model.TransactionInfo1;\n\npublic class ErgoExplorer {\n    public static void main(String[] args) {\n        TransactionsApi transactionsApi = new TransactionsApi();\n        TransactionInfo1 transaction = transactionsApi.getTransactionById(\"12345\");\n        System.out.println(\"Transaction ID: \" + transaction.getId());\n        System.out.println(\"Number of confirmations: \" + transaction.getConfirmationsCount());\n        // ...\n    }\n}\n```\n\nIn this example, we create an instance of the `TransactionsApi` class, which provides methods for interacting with the Ergo blockchain's transactions. We then use the `getTransactionById` method to retrieve a `TransactionInfo1` object representing a transaction with the ID \"12345\". We can then access the various properties of the transaction, such as its ID and number of confirmations, using the getter methods provided by the `TransactionInfo1` class.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `TransactionInfo1` which represents information about a transaction in the Ergo blockchain.\n\n2. What are the properties of a `TransactionInfo1` object?\n- A `TransactionInfo1` object has the following properties: `id`, `headerId`, `inclusionHeight`, `timestamp`, `index`, `confirmationsCount`, `inputs`, `dataInputs`, and `outputs`.\n\n3. What is the purpose of the `equals`, `hashCode`, and `toString` methods?\n- These methods are used for object comparison and string representation. The `equals` method checks if two `TransactionInfo1` objects are equal, the `hashCode` method generates a hash code for a `TransactionInfo1` object, and the `toString` method returns a string representation of a `TransactionInfo1` object.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/TransactionInfo1.md"}}],["124",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/UnknownErr.java)\n\nThis code defines a Java class called `UnknownErr` which is used in the Ergo Explorer API v1 project. The purpose of this class is to represent an error response that has an unknown reason. The class has two properties: `status` and `reason`. `status` is an integer that represents the HTTP status code of the error response. `reason` is a string that provides a brief description of the error.\n\nThe class has getter and setter methods for both properties, as well as methods for equality checking, hashing, and string representation. The class also has annotations that provide additional information about the properties, such as whether they are required or not.\n\nThis class can be used in the larger project to handle error responses that have an unknown reason. For example, if the API encounters an error that it does not recognize, it can return an instance of this class with the appropriate HTTP status code and a brief description of the error. This allows the client to handle the error in a more meaningful way than simply receiving a generic error message.\n\nHere is an example of how this class might be used in the Ergo Explorer API v1 project:\n\n```\nUnknownErr error = new UnknownErr();\nerror.setStatus(404);\nerror.setReason(\"The requested resource could not be found.\");\n```\n\nThis code creates a new instance of the `UnknownErr` class and sets its `status` property to 404 and its `reason` property to \"The requested resource could not be found.\" This instance can then be returned to the client as an error response.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `UnknownErr` which has two properties: `status` and `reason`.\n\n2. What is the expected input and output of this code?\n- The input is an instance of the `UnknownErr` class, which has a `status` and a `reason` property. The output is a string representation of the object.\n\n3. What is the significance of the `@Schema` annotation in this code?\n- The `@Schema` annotation is used to provide additional information about the properties of the `UnknownErr` class, such as whether they are required or not, and a description of what they represent.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/model/UnknownErr.md"}}],["125",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/java-client-generated/src/main/java/org/ergoplatform/explorer/client)\n\nThe `.autodoc/docs/json/java-client-generated/src/main/java/org/ergoplatform/explorer/client` folder contains classes and interfaces that enable developers to interact with the Ergo blockchain explorer API, fetch data, and format collections of strings into various formats.\n\n`CollectionFormats.java` provides classes for formatting collections of strings into CSV, SSV, TSV, and PIPES formats. These classes can be used to format data for different parts of the application. For example:\n\n```java\nList<String> params = Arrays.asList(\"param1\", \"param2\", \"param3\");\nCSVParams csvParams = new CSVParams(params);\nString formattedParams = csvParams.toString();\n```\n\n`DefaultApi.java` is an interface that provides methods for interacting with the Ergo blockchain explorer API, such as fetching balances, transactions, blocks, and tokens. It serves as a bridge between the Ergo blockchain explorer API and the ergo-appkit project. For example:\n\n```java\nDefaultApi api = new DefaultApi();\nString address = \"9f4QF8AD1nQ3nJahQVkM6c5jmBvG4Df6MAzvp8uss6R4XNt8vGt\";\nApiResponse<ConfirmedBalance> response = api.getApiV1AddressesP1BalanceConfirmed(address, 10);\n```\n\n`ExplorerApiClient.java` is a wrapper around the Retrofit library, providing a convenient way to interact with a RESTful API. It offers methods to configure the Retrofit instance and handle deserialization failures. For example:\n\n```java\nExplorerApiClient client = new ExplorerApiClient();\nclient.createDefaultAdapter();\nDefaultApi api = client.createService(DefaultApi.class);\n```\n\n`JSON.java` is responsible for creating and configuring a `Gson` object, which is used to serialize and deserialize Java objects to and from JSON. It contains nested classes that extend `TypeAdapter` to customize the serialization and deserialization of specific Java types. For example:\n\n```java\nGson gson = new JSON().createGson();\nString jsonString = \"{\\\"name\\\":\\\"John\\\",\\\"age\\\":30}\";\nPerson person = gson.fromJson(jsonString, Person.class);\n```\n\n`StringUtil.java` provides utility methods for working with arrays of strings, such as `containsIgnoreCase` and `join`. These methods can be used throughout the project to simplify string manipulation tasks. For example:\n\n```java\nString[] names = {\"Alice\", \"Bob\", \"Charlie\"};\nString commaSeparatedNames = StringUtil.join(names, \", \");\n```\n\nThe `auth` subfolder contains classes for adding authentication information to HTTP requests made by the Ergo Explorer client. `ApiKeyAuth` adds an API key to requests, while `HttpBasicAuth` adds HTTP Basic Authentication headers. These classes can be used with an `OkHttpClient` instance to ensure that all requests include the necessary authentication information. For example:\n\n```java\nApiKeyAuth apiKeyAuth = new ApiKeyAuth(\"header\", \"X-Api-Key\");\napiKeyAuth.setApiKey(\"my-api-key\");\n\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(apiKeyAuth)\n        .build();\n```\n\nOverall, this folder provides essential components for interacting with the Ergo blockchain explorer API, handling JSON serialization and deserialization, formatting collections of strings, and adding authentication information to HTTP requests.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/client/summary.md"}}],["126",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/java-client-generated/src/main/java/org/ergoplatform/explorer)\n\nThe `.autodoc/docs/json/java-client-generated/src/main/java/org/ergoplatform/explorer` folder contains essential components for interacting with the Ergo blockchain explorer API, handling JSON serialization and deserialization, formatting collections of strings, and adding authentication information to HTTP requests.\n\n`CollectionFormats.java` provides classes for formatting collections of strings into CSV, SSV, TSV, and PIPES formats. These classes can be used to format data for different parts of the application. For example:\n\n```java\nList<String> params = Arrays.asList(\"param1\", \"param2\", \"param3\");\nCSVParams csvParams = new CSVParams(params);\nString formattedParams = csvParams.toString();\n```\n\n`DefaultApi.java` is an interface that provides methods for interacting with the Ergo blockchain explorer API, such as fetching balances, transactions, blocks, and tokens. It serves as a bridge between the Ergo blockchain explorer API and the ergo-appkit project. For example:\n\n```java\nDefaultApi api = new DefaultApi();\nString address = \"9f4QF8AD1nQ3nJahQVkM6c5jmBvG4Df6MAzvp8uss6R4XNt8vGt\";\nApiResponse<ConfirmedBalance> response = api.getApiV1AddressesP1BalanceConfirmed(address, 10);\n```\n\n`ExplorerApiClient.java` is a wrapper around the Retrofit library, providing a convenient way to interact with a RESTful API. It offers methods to configure the Retrofit instance and handle deserialization failures. For example:\n\n```java\nExplorerApiClient client = new ExplorerApiClient();\nclient.createDefaultAdapter();\nDefaultApi api = client.createService(DefaultApi.class);\n```\n\n`JSON.java` is responsible for creating and configuring a `Gson` object, which is used to serialize and deserialize Java objects to and from JSON. It contains nested classes that extend `TypeAdapter` to customize the serialization and deserialization of specific Java types. For example:\n\n```java\nGson gson = new JSON().createGson();\nString jsonString = \"{\\\"name\\\":\\\"John\\\",\\\"age\\\":30}\";\nPerson person = gson.fromJson(jsonString, Person.class);\n```\n\n`StringUtil.java` provides utility methods for working with arrays of strings, such as `containsIgnoreCase` and `join`. These methods can be used throughout the project to simplify string manipulation tasks. For example:\n\n```java\nString[] names = {\"Alice\", \"Bob\", \"Charlie\"};\nString commaSeparatedNames = StringUtil.join(names, \", \");\n```\n\nThe `auth` subfolder contains classes for adding authentication information to HTTP requests made by the Ergo Explorer client. `ApiKeyAuth` adds an API key to requests, while `HttpBasicAuth` adds HTTP Basic Authentication headers. These classes can be used with an `OkHttpClient` instance to ensure that all requests include the necessary authentication information. For example:\n\n```java\nApiKeyAuth apiKeyAuth = new ApiKeyAuth(\"header\", \"X-Api-Key\");\napiKeyAuth.setApiKey(\"my-api-key\");\n\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(apiKeyAuth)\n        .build();\n```\n\nOverall, this folder provides essential components for interacting with the Ergo blockchain explorer API, handling JSON serialization and deserialization, formatting collections of strings, and adding authentication information to HTTP requests.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/explorer/summary.md"}}],["127",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/AddressHolder.java)\n\nThe `AddressHolder` class is a model class that represents an encoded ErgoAddress. It is used in the Ergo Node API to hold the address value. This class is generated automatically by the Swagger code generator program and should not be edited manually.\n\nThe `AddressHolder` class has a single field, `address`, which is a string that holds the encoded ErgoAddress. The `address` field is annotated with `@SerializedName` and `@Schema`, which provide metadata about the field. The `@SerializedName` annotation specifies the name of the field in the serialized JSON representation of the object. The `@Schema` annotation provides a description of the field and specifies that it is required.\n\nThe `AddressHolder` class has a constructor that takes no arguments and a getter and setter method for the `address` field. The `toString()` method is overridden to provide a string representation of the object.\n\nThis class can be used in the Ergo Node API to represent an encoded ErgoAddress. For example, it can be used as a parameter or return type in API methods that require or return an encoded ErgoAddress. Here is an example of how this class can be used:\n\n```\nAddressHolder addressHolder = new AddressHolder();\naddressHolder.setAddress(\"9f7c5f3d7f7d7f7d7f7d7f7d7f7d7f7d7f7d7f7d7f7d7f7d7f7d7f7d7f7d7f7\");\nString address = addressHolder.getAddress();\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `AddressHolder` that holds an encoded ErgoAddress.\n\n2. What dependencies does this code have?\n- This code depends on the `com.google.gson` and `io.swagger.v3.oas.annotations` libraries.\n\n3. Can the `address` field be null?\n- No, the `address` field is marked as required in the schema annotation and does not have a default value, so it must be set to a non-null value.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/AddressHolder.md"}}],["128",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/AddressValidity.java)\n\nThis code defines a Java class called `AddressValidity` which represents the validity status of an Ergo address. The class has three fields: `address`, `isValid`, and `error`. The `address` field is a string that represents the Ergo address being checked for validity. The `isValid` field is a boolean that indicates whether the address is valid or not. The `error` field is a string that contains an error message if the address is invalid.\n\nThe purpose of this class is to provide a standardized way of checking the validity of Ergo addresses. It can be used in the larger project to validate addresses entered by users or to check the validity of addresses stored in the system.\n\nHere is an example of how this class can be used:\n\n```java\nAddressValidity addressValidity = new AddressValidity();\naddressValidity.setAddress(\"9fZk7JQJLJ8xvJZ5L6jL9zvZ8J4QJzv5K6JL9zvZ8J4QJzv5K6J\");\naddressValidity.setIsValid(true);\nString error = addressValidity.getError();\nif (error == null) {\n    System.out.println(\"Address is valid\");\n} else {\n    System.out.println(\"Address is invalid: \" + error);\n}\n```\n\nIn this example, an instance of the `AddressValidity` class is created and the `address` and `isValid` fields are set. The `getError()` method is then called to check if there is an error message. If the error message is null, the address is considered valid and a message is printed to the console. If there is an error message, the address is considered invalid and the error message is printed to the console.\n\nOverall, this class provides a simple and standardized way of checking the validity of Ergo addresses in the larger project.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `AddressValidity` that represents the validity status of an Ergo address.\n\n2. What dependencies does this code have?\n- This code depends on the `com.google.gson` and `io.swagger.v3.oas.annotations` libraries.\n\n3. Can the properties of `AddressValidity` be null?\n- Yes, the `error` property can be null, but the `address` and `isValid` properties are required and cannot be null.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/AddressValidity.md"}}],["129",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/AndPredicate.java)\n\nThe code defines a Java class called `AndPredicate` which extends another class called `ScanningPredicate`. The purpose of this class is to represent a logical AND operation between multiple scanning predicates. \n\nThe class has a single field called `args`, which is a list of `ScanningPredicate` objects. This list represents the scanning predicates that are being ANDed together. The `args` field can be set using the `args` method, which takes a list of `ScanningPredicate` objects, or by calling the `addArgsItem` method, which adds a single `ScanningPredicate` object to the list.\n\nThe class also overrides several methods from the `Object` class, including `equals`, `hashCode`, and `toString`. These methods are used to compare `AndPredicate` objects, generate hash codes for `AndPredicate` objects, and generate string representations of `AndPredicate` objects, respectively.\n\nThis class is likely used in the larger project to represent complex scanning predicates that require multiple conditions to be met. For example, if a scanning operation needs to find all transactions that have both a certain output and a certain input, an `AndPredicate` object could be used to represent this condition. \n\nHere is an example of how an `AndPredicate` object could be created and used:\n\n```\n// Create two scanning predicates\nScanningPredicate predicate1 = new ScanningPredicate();\nScanningPredicate predicate2 = new ScanningPredicate();\n\n// Create an AndPredicate object and add the two scanning predicates to it\nAndPredicate andPredicate = new AndPredicate();\nandPredicate.addArgsItem(predicate1);\nandPredicate.addArgsItem(predicate2);\n\n// Use the AndPredicate object in a scanning operation\nList<Transaction> transactions = scanner.scan(andPredicate);\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code is a model class for an AndPredicate in the Ergo Node API, which extends the ScanningPredicate class.\n\n2. What is the significance of the @SerializedName and @Schema annotations?\n- The @SerializedName annotation is used to specify the name of the JSON property that corresponds to the annotated field or method. The @Schema annotation is used to describe the schema of the annotated element in the OpenAPI specification.\n\n3. What is the purpose of the equals() and hashCode() methods?\n- The equals() method is used to compare two AndPredicate objects for equality based on their args field and the equals() method of the superclass. The hashCode() method is used to generate a hash code for an AndPredicate object based on its args field and the hashCode() method of the superclass.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/AndPredicate.md"}}],["130",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/AnyOfRequestsHolderRequestsItems.java)\n\nThis code defines an interface called \"AnyOfRequestsHolderRequestsItems\" within the \"org.ergoplatform.restapi.client\" package. The purpose of this interface is not immediately clear from the code itself, but it is likely used as part of the Ergo Node API. \n\nInterfaces in Java are used to define a set of methods that a class must implement if it implements that interface. In this case, the interface does not have any methods defined, so any class that implements this interface will not be required to implement any specific methods. \n\nIt is possible that this interface is used as part of a larger set of interfaces and classes that define the Ergo Node API. Other classes may implement this interface and provide their own methods, which would be used to interact with the Ergo Node API. \n\nWithout more context, it is difficult to provide specific examples of how this interface might be used. However, it is likely that it is used in conjunction with other classes and interfaces to provide a comprehensive API for interacting with the Ergo Node.\n## Questions: \n 1. What is the purpose of this code file?\n- This code file contains an interface called `AnyOfRequestsHolderRequestsItems` which is likely used in the Ergo Node API.\n\n2. What version of the OpenAPI spec is being used?\n- The code file is using version 4.0.12 of the OpenAPI spec.\n\n3. Why is there a note to not edit the class manually?\n- The class is auto generated by the Swagger code generator program, so any manual edits may be overwritten by future code generation.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/AnyOfRequestsHolderRequestsItems.md"}}],["131",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ApiClient.java)\n\nThe `ApiClient` class is a utility class that provides methods for creating and configuring a Retrofit client. It is used to make HTTP requests to a RESTful API. The class is responsible for creating a `Retrofit` instance, which is used to create a service that can be used to make HTTP requests to the API. The `ApiClient` class provides methods for setting up authentication, adding interceptors, and configuring the `Retrofit` instance.\n\nThe `ApiClient` class has several constructors that allow for different types of authentication to be used. The `createDefaultAdapter()` method is used to create a default `Retrofit` instance with a `Gson` converter factory and a `Scalars` converter factory. The `createService()` method is used to create a service that can be used to make HTTP requests to the API.\n\nThe `GsonCustomConverterFactory` class is a custom converter factory that is used to handle deserialization errors. If the deserialization fails due to a `JsonParseException` and the expected type is a `String`, then the `GsonResponseBodyConverterToString` class is used to return the body string.\n\nOverall, the `ApiClient` class is an important utility class that provides a simple and flexible way to make HTTP requests to a RESTful API. It is used extensively throughout the `ergo-appkit` project to interact with the Ergo blockchain. Below is an example of how the `ApiClient` class can be used to create a service that can be used to make HTTP requests to the Ergo blockchain API:\n\n```\nApiClient apiClient = new ApiClient(\"https://api.ergoplatform.com\");\nMyApiService apiService = apiClient.createService(MyApiService.class);\n```\n## Questions: \n 1. What is the purpose of the `ApiClient` class?\n- The `ApiClient` class is used to create a Retrofit client that can be used to make HTTP requests to a REST API.\n\n2. What authentication methods are supported by the `ApiClient` class?\n- The `ApiClient` class supports API key authentication and basic authentication.\n\n3. What is the purpose of the `GsonCustomConverterFactory` class?\n- The `GsonCustomConverterFactory` class is used to customize the Gson converter factory used by Retrofit to handle response bodies. It provides a custom implementation of the `responseBodyConverter` method that returns a `GsonResponseBodyConverterToString` instance if the expected type is `String`.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ApiClient.md"}}],["132",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ApiError.java)\n\nThe `ApiError` class is a model class that represents an error response from the Ergo Node API. It contains three fields: `error`, `reason`, and `detail`. The `error` field is an integer that represents the error code, while the `reason` field is a string that represents the error message. The `detail` field is a string that provides a more detailed description of the error.\n\nThis class is generated automatically by the Swagger Codegen program and should not be edited manually. It is used by the Ergo Node API to provide error responses to clients. When an error occurs, the API will return an instance of the `ApiError` class with the appropriate error code, error message, and detailed description.\n\nHere is an example of how this class might be used in the larger project:\n\n```java\ntry {\n    // make API request\n} catch (ApiException e) {\n    // handle error response\n    ApiError error = e.getResponseBody();\n    System.out.println(\"Error code: \" + error.getError());\n    System.out.println(\"Error message: \" + error.getReason());\n    System.out.println(\"Error details: \" + error.getDetail());\n}\n```\n\nIn this example, an API request is made and an `ApiException` is thrown if an error occurs. The `getResponseBody()` method is called to retrieve the error response as an instance of the `ApiError` class. The error code, error message, and detailed description are then printed to the console for debugging purposes.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `ApiError` that represents an error response from an API.\n\n2. What dependencies does this code have?\n- This code depends on the `com.google.gson` and `io.swagger.v3.oas.annotations` libraries.\n\n3. Can the properties of `ApiError` be null?\n- No, the `error`, `reason`, and `detail` properties of `ApiError` are all marked as required in the OpenAPI schema annotations.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ApiError.md"}}],["133",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Asset.java)\n\nThis code defines a Java class called `Asset` that represents a token detail in a transaction. It contains two fields: `tokenId` and `amount`. `tokenId` is a string that represents the unique identifier of the token, while `amount` is a long integer that represents the amount of the token. \n\nThe class also includes getter and setter methods for both fields, as well as methods for equality checking, hashing, and string representation. The string representation method returns a string that contains the values of the `tokenId` and `amount` fields.\n\nThis class is likely used in the larger project to represent token details in transactions. It can be instantiated and populated with values for `tokenId` and `amount`, and then passed to other parts of the project that require this information. For example, it could be used in a method that creates a new transaction and needs to specify the tokens being transferred.\n\nHere is an example of how this class could be used:\n\n```\nAsset asset = new Asset();\nasset.setTokenId(\"abc123\");\nasset.setAmount(1000L);\n\nSystem.out.println(asset.getTokenId()); // prints \"abc123\"\nSystem.out.println(asset.getAmount()); // prints \"1000\"\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `Asset` which represents token details in a transaction, and includes methods for getting and setting the token ID and amount.\n\n2. What version of the OpenAPI spec is this code based on?\n- This code is based on version 4.0.12 of the OpenAPI spec.\n\n3. Is this class editable or auto-generated?\n- This class is auto-generated by the Swagger code generator program, and should not be edited manually.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Asset.md"}}],["134",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/AssetIssueRequest.java)\n\nThe `AssetIssueRequest` class is part of the Ergo Node API and is used to generate a request for an asset issue transaction. This class contains several fields that can be set to specify the details of the asset issue transaction. \n\nThe `address` field is a string that specifies the address where the issued assets will be sent. The `ergValue` field is an optional integer that specifies the amount of ergs to be put into the box with the issued assets. The `amount` field is a required long that specifies the supply amount of the asset to be issued. The `name` field is a required string that specifies the name of the asset to be issued. The `description` field is a required string that specifies the description of the asset to be issued. The `decimals` field is a required integer that specifies the number of decimal places for the asset to be issued. The `registers` field is an optional `Registers` object that specifies the registers for the asset to be issued.\n\nThe `AssetIssueRequest` class implements the `AnyOfRequestsHolderRequestsItems` interface, which is used to hold a list of requests. This class also overrides several methods, including `equals()`, `hashCode()`, and `toString()`, to provide custom behavior for comparing and displaying instances of this class.\n\nThis class can be used in the larger Ergo Node API project to generate requests for asset issue transactions. For example, a developer could create an instance of the `AssetIssueRequest` class and set its fields to specify the details of an asset issue transaction. The developer could then pass this instance to a method that generates the asset issue transaction using the Ergo Node API. \n\nExample usage:\n\n```\nAssetIssueRequest request = new AssetIssueRequest()\n    .address(\"myErgoAddress\")\n    .ergValue(1000000)\n    .amount(100000000)\n    .name(\"MyToken\")\n    .description(\"A token for my project\")\n    .decimals(8)\n    .registers(new Registers());\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code is a model for a request to generate an asset issue transaction in the Ergo Node API.\n\n2. What are the required fields for an asset issue request?\n- The required fields for an asset issue request are `amount`, `name`, `description`, and `decimals`.\n\n3. What is the purpose of the `Registers` class?\n- The `Registers` class is used to represent the registers associated with an asset issue request.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/AssetIssueRequest.md"}}],["135",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/AvlTreeData.java)\n\nThe `AvlTreeData` class is part of the Ergo Node API and is used to represent AVL tree data. The class contains four properties: `digest`, `treeFlags`, `keyLength`, and `valueLength`. \n\nThe `digest` property is a string that represents the hash of the AVL tree. The `treeFlags` property is an integer that represents the flags of the AVL tree. The `keyLength` property is an integer that represents the length of the key in the AVL tree. The `valueLength` property is an integer that represents the length of the value in the AVL tree.\n\nThe class provides getters and setters for each property. The `toString()` method is overridden to provide a string representation of the object. The `equals()` and `hashCode()` methods are also overridden to provide a way to compare objects of this class.\n\nThis class is used in the larger Ergo Node API project to represent AVL tree data. It can be used to create and manipulate AVL trees. For example, the following code creates an `AvlTreeData` object with a digest of \"abc123\", tree flags of 1, key length of 10, and value length of 20:\n\n```\nAvlTreeData avlTreeData = new AvlTreeData()\n    .digest(\"abc123\")\n    .treeFlags(1)\n    .keyLength(10)\n    .valueLength(20);\n```\n## Questions: \n 1. What is the purpose of the `AvlTreeData` class?\n- The `AvlTreeData` class is part of the Ergo Node API and represents data related to an AVL tree.\n\n2. What are the required fields for an `AvlTreeData` object?\n- The `digest` field is the only required field for an `AvlTreeData` object.\n\n3. Can the `treeFlags`, `keyLength`, and `valueLength` fields be null?\n- Yes, the `treeFlags`, `keyLength`, and `valueLength` fields can be null.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/AvlTreeData.md"}}],["136",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/BalancesSnapshot.java)\n\nThe `BalancesSnapshot` class is part of the Ergo Node API and is used to represent the amount of Ergo tokens and assets. This class is generated automatically by the Swagger code generator program and should not be edited manually. \n\nThe class has three properties: `height`, `balance`, and `assets`. The `height` property is an integer that represents the height of the block at which the balance snapshot was taken. The `balance` property is a long integer that represents the total balance of Ergo tokens. The `assets` property is a list of `Asset` objects that represent the balances of non-Ergo assets. \n\nThe `BalancesSnapshot` class has several methods that allow for setting and getting the values of its properties. The `height` property can be set and retrieved using the `height()` and `getHeight()` methods, respectively. Similarly, the `balance` property can be set and retrieved using the `balance()` and `getBalance()` methods. The `assets` property can be set and retrieved using the `assets()` and `getAssets()` methods. Additionally, the `addAssetsItem()` method can be used to add an `Asset` object to the `assets` list. \n\nThis class is used in the larger Ergo Node API project to represent the balance of a particular address at a specific block height. It can be used to retrieve the balance of an address by making a request to the Ergo Node API and parsing the response into a `BalancesSnapshot` object. For example, the following code snippet demonstrates how to retrieve the balance of an address using the Ergo Node API and the `BalancesSnapshot` class:\n\n```\n// create a new Ergo Node API client\nApiClient client = new ApiClient();\n\n// set the base URL of the Ergo Node API\nclient.setBasePath(\"https://localhost:9052\");\n\n// create a new API instance using the client\nBalancesApi api = new BalancesApi(client);\n\n// set the address and block height\nString address = \"9f3f1f1d7b6c3c6c7f7d6c3c6c7f7d6c3c6c7f7d6c3c6c7f7d6c3c6c7f7d6c3c\";\nint height = 123456;\n\n// make the API request to retrieve the balance snapshot\nBalancesSnapshot balances = api.getBalance(address, height);\n\n// print the balance and assets\nSystem.out.println(\"Balance: \" + balances.getBalance());\nSystem.out.println(\"Assets: \" + balances.getAssets());\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `BalancesSnapshot` that represents the amount of Ergo tokens and assets.\n\n2. What is the expected input and output of this code?\n- This code does not have any input or output, as it only defines a Java class.\n\n3. What is the significance of the `Asset` class imported in this code?\n- The `Asset` class is used as a type for the `assets` field in the `BalancesSnapshot` class, which represents a list of assets.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/BalancesSnapshot.md"}}],["137",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/BlacklistedPeers.java)\n\nThe code defines a Java class called `BlacklistedPeers` which represents a list of IP addresses that have been blacklisted by the Ergo Node API. The purpose of this class is to provide a way for the Ergo Node API to keep track of IP addresses that have been identified as malicious or otherwise undesirable, and to prevent them from accessing the API in the future.\n\nThe `BlacklistedPeers` class has a single field called `addresses`, which is a list of strings representing the IP addresses that have been blacklisted. The class provides methods for adding and retrieving IP addresses from the list.\n\nThe class also includes methods for comparing instances of the class for equality and generating a string representation of the class.\n\nThis class is likely used in conjunction with other classes and methods in the Ergo Node API to provide security and access control features. For example, the API may use this class to check incoming requests against the list of blacklisted IP addresses and deny access to any requests coming from those addresses.\n\nExample usage:\n\n```\n// create a new instance of the BlacklistedPeers class\nBlacklistedPeers blacklistedPeers = new BlacklistedPeers();\n\n// add an IP address to the list of blacklisted peers\nblacklistedPeers.addAddressesItem(\"192.168.1.1\");\n\n// retrieve the list of blacklisted peers\nList<String> addresses = blacklistedPeers.getAddresses();\n\n// print out the list of blacklisted peers\nSystem.out.println(\"Blacklisted peers: \" + addresses);\n```\n## Questions: \n 1. What is the purpose of this code?\n   - This code defines a Java class called `BlacklistedPeers` which has a list of IP addresses that are blacklisted.\n\n2. What dependencies does this code have?\n   - This code depends on the `com.google.gson` and `io.swagger.v3.oas.annotations` libraries.\n\n3. Can the list of blacklisted addresses be modified after it is set?\n   - Yes, the `addresses` field can be modified by calling the `setAddresses` method or the `addAddressesItem` method to add individual addresses to the list.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/BlacklistedPeers.md"}}],["138",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/BlockADProofs.java)\n\nThe `BlockADProofs` class is part of the Ergo Node API and is used to model a block's AD (authenticated data) proofs. This class is generated automatically by the Swagger code generator program and should not be edited manually. \n\nThe `BlockADProofs` class has four properties: `headerId`, `proofBytes`, `digest`, and `size`. `headerId` is a string that represents the block header ID. `proofBytes` is a string that represents the serialized AD proof. `digest` is a string that represents the hash of the AD proof. `size` is an integer that represents the size of the AD proof in bytes. \n\nThis class provides getter and setter methods for each property, allowing users to access and modify the properties as needed. Additionally, the class provides methods for equality checking, hashing, and string representation. \n\nIn the larger Ergo Node API project, the `BlockADProofs` class is used to represent a block's AD proofs. This class can be used to serialize and deserialize AD proofs, as well as to perform equality checks and hashing. Other classes in the Ergo Node API may use the `BlockADProofs` class as a parameter or return type in their methods. \n\nExample usage:\n\n```java\nBlockADProofs adProofs = new BlockADProofs();\nadProofs.setHeaderId(\"12345\");\nadProofs.setProofBytes(\"abcdefg\");\nadProofs.setDigest(\"hash123\");\nadProofs.setSize(100);\n\nString headerId = adProofs.getHeaderId(); // returns \"12345\"\nString proofBytes = adProofs.getProofBytes(); // returns \"abcdefg\"\nString digest = adProofs.getDigest(); // returns \"hash123\"\nint size = adProofs.getSize(); // returns 100\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `BlockADProofs` which represents a block's AD (authenticated data) proofs in the Ergo Node API.\n\n2. What are the required fields for a `BlockADProofs` object?\n- A `BlockADProofs` object requires a `headerId`, `proofBytes`, `digest`, and `size` field.\n\n3. Can the fields of a `BlockADProofs` object be modified after instantiation?\n- Yes, the fields of a `BlockADProofs` object can be modified using the provided setter methods.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/BlockADProofs.md"}}],["139",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/BlockHeader.java)\n\nThe `BlockHeader` class is part of the Ergo Node API and provides a model for the block header data structure. The block header contains metadata about a block in the blockchain, such as its ID, timestamp, version, and various hashes. This class defines the properties of a block header and provides getters and setters for each property.\n\nThe class contains fields for the block ID, timestamp, version, adProofsRoot, stateRoot, transactionsRoot, nBits, extensionHash, powSolutions, height, difficulty, parentId, votes, size, extensionId, transactionsId, and adProofsId. Each field has a corresponding getter and setter method. The `@SerializedName` annotation is used to specify the JSON field name for each property.\n\nThe class also includes methods for equality checking, hashing, and string representation. These methods are used to compare and manipulate instances of the `BlockHeader` class.\n\nThis class is generated automatically by the Swagger code generator program and should not be edited manually. It is used by other classes in the Ergo Node API to represent block headers in the blockchain. For example, the `BlockSummary` class contains a `BlockHeader` object as one of its properties. Developers can use this class to interact with the Ergo blockchain and retrieve information about blocks and transactions. \n\nExample usage:\n\n```java\nBlockHeader blockHeader = new BlockHeader();\nblockHeader.setId(\"12345\");\nblockHeader.setTimestamp(1625678900L);\nblockHeader.setVersion(1);\nblockHeader.setAdProofsRoot(\"adProofsRootHash\");\nblockHeader.setStateRoot(\"stateRootHash\");\nblockHeader.setTransactionsRoot(\"transactionsRootHash\");\nblockHeader.setNBits(19857408L);\nblockHeader.setExtensionHash(\"extensionHash\");\nblockHeader.setPowSolutions(new PowSolutions());\nblockHeader.setHeight(667);\nblockHeader.setDifficulty(BigInteger.valueOf(62));\nblockHeader.setParentId(\"parentBlockId\");\nblockHeader.setVotes(\"votes\");\nblockHeader.setSize(1024);\nblockHeader.setExtensionId(\"extensionId\");\nblockHeader.setTransactionsId(\"transactionsId\");\nblockHeader.setAdProofsId(\"adProofsId\");\n\nString blockId = blockHeader.getId();\nLong timestamp = blockHeader.getTimestamp();\nInteger version = blockHeader.getVersion();\n// ... get other properties\n\nSystem.out.println(blockHeader.toString());\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `BlockHeader` which represents a block header in the Ergo blockchain. It contains various fields such as `id`, `timestamp`, `version`, `adProofsRoot`, etc.\n\n2. What is the significance of the `@SerializedName` and `@Schema` annotations?\n- The `@SerializedName` annotation is used to specify the name of the JSON property that corresponds to a particular Java field when serializing or deserializing JSON data. The `@Schema` annotation is used to provide additional information about a field such as its description, example value, and whether it is required.\n\n3. What is the purpose of the `equals`, `hashCode`, and `toString` methods?\n- These methods are used to implement object equality, hashing, and string representation respectively. They are commonly used in Java classes to enable comparison and printing of objects.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/BlockHeader.md"}}],["140",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/BlockHeaderWithoutPow.java)\n\nThe `BlockHeaderWithoutPow` class is part of the Ergo Node API and is used to model block headers without proof-of-work (PoW) information. This class is generated automatically by the Swagger code generator program and should not be edited manually.\n\nThe class contains fields that represent various properties of a block header, such as the block ID, timestamp, version, and root hashes of the ad proofs, state, and transactions. It also includes fields for the block's difficulty, height, and parent ID, as well as the size and IDs of the block's extension, transactions, and ad proofs.\n\nThe class provides getter and setter methods for each field, allowing developers to easily access and modify the properties of a block header. For example, to get the ID of a block header, you can call the `getId()` method:\n\n```\nBlockHeaderWithoutPow header = new BlockHeaderWithoutPow();\nString id = header.getId();\n```\n\nTo set the timestamp of a block header, you can call the `setTimestamp()` method:\n\n```\nBlockHeaderWithoutPow header = new BlockHeaderWithoutPow();\nheader.setTimestamp(123456789);\n```\n\nThe class also includes methods for equality checking, hashing, and string representation.\n\nOverall, the `BlockHeaderWithoutPow` class is an important part of the Ergo Node API and is used to represent block headers without PoW information. It provides a convenient way for developers to work with block headers and access their properties.\n## Questions: \n 1. What is the purpose of this code?\n- This code is a model for the BlockHeaderWithoutPow API in the Ergo Node API project.\n\n2. What are the required fields for a BlockHeaderWithoutPow object?\n- The required fields for a BlockHeaderWithoutPow object are id, timestamp, version, adProofsRoot, stateRoot, transactionsRoot, nBits, height, difficulty, parentId, and votes.\n\n3. What is the purpose of the equals, hashCode, and toString methods?\n- The equals method compares two BlockHeaderWithoutPow objects for equality, the hashCode method generates a hash code for the object, and the toString method returns a string representation of the object.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/BlockHeaderWithoutPow.md"}}],["141",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/BlockTransactions.java)\n\nThis code defines a Java class called `BlockTransactions` which is used to represent a block's transactions in the Ergo Node API. The class has three instance variables: `headerId`, `transactions`, and `size`. `headerId` is a string that represents the ID of the block header, `transactions` is an instance of the `Transactions` class (which is defined elsewhere in the project), and `size` is an integer that represents the size of the block in bytes.\n\nThe class has several methods that allow for getting and setting the values of its instance variables. The `headerId` and `transactions` variables are required, while `size` is optional. The class also has methods for checking equality and generating a string representation of the object.\n\nThis class is likely used in the larger Ergo Node API project to represent a block's transactions in a standardized way. It can be used to serialize and deserialize block transaction data between different parts of the Ergo Node API. For example, it may be used to represent block transaction data in HTTP requests and responses. Here is an example of how this class might be used in the Ergo Node API:\n\n```java\nBlockTransactions blockTransactions = new BlockTransactions();\nblockTransactions.setHeaderId(\"12345\");\nblockTransactions.setTransactions(transactions);\nblockTransactions.setSize(1024);\n\n// Serialize the object to JSON\nGson gson = new Gson();\nString json = gson.toJson(blockTransactions);\n\n// Deserialize the JSON back into a BlockTransactions object\nBlockTransactions deserialized = gson.fromJson(json, BlockTransactions.class);\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `BlockTransactions` that represents a block's transactions in the Ergo Node API.\n\n2. What are the required fields for a `BlockTransactions` object?\n- A `BlockTransactions` object requires a `headerId` (String) and `transactions` (Transactions) field.\n\n3. What is the purpose of the `size` field in a `BlockTransactions` object?\n- The `size` field represents the size of the block's transactions in bytes.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/BlockTransactions.md"}}],["142",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/BlocksApi.java)\n\nThe `BlocksApi` interface is part of the `ergo-appkit` project and provides methods for interacting with the Ergo blockchain. This interface defines several HTTP methods that can be used to retrieve information about blocks, headers, transactions, and more.\n\nThe `getBlockHeaderById` method retrieves the header information for a given block ID. The `getBlockTransactionsById` method retrieves the transaction information for a given block ID. The `getChainSlice` method retrieves a list of block headers within a specified range of heights. The `getFullBlockAt` method retrieves the header IDs at a given height. The `getFullBlockById` method retrieves the full block information for a given block ID. The `getHeaderIds` method retrieves an array of header IDs. The `getLastHeaders` method retrieves the last headers objects. The `getModifierById` method retrieves the persistent modifier by its ID. The `getProofForTx` method retrieves the Merkle proof for a given transaction ID. The `sendMinedBlock` method sends a mined block to the Ergo network.\n\nEach method takes in parameters that are used to construct the appropriate HTTP request. For example, the `getBlockHeaderById` method takes in a `headerId` parameter that is used to construct the URL for the HTTP GET request. The response from each method is wrapped in a `Call` object, which can be used to execute the request asynchronously.\n\nHere is an example of how to use the `getBlockHeaderById` method:\n\n```java\nBlocksApi blocksApi = retrofit.create(BlocksApi.class);\nCall<BlockHeader> call = blocksApi.getBlockHeaderById(\"blockId\");\ncall.enqueue(new Callback<BlockHeader>() {\n    @Override\n    public void onResponse(Call<BlockHeader> call, Response<BlockHeader> response) {\n        if (response.isSuccessful()) {\n            BlockHeader blockHeader = response.body();\n            // Do something with the block header\n        } else {\n            ApiError error = ApiErrorUtils.parseError(response);\n            // Handle the error\n        }\n    }\n\n    @Override\n    public void onFailure(Call<BlockHeader> call, Throwable t) {\n        // Handle the failure\n    }\n});\n```\n\nIn this example, we create an instance of the `BlocksApi` interface using Retrofit. We then call the `getBlockHeaderById` method with a block ID parameter and enqueue the request to execute it asynchronously. When the response is received, we check if it was successful and handle the response or error accordingly.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines an interface for making REST API calls related to blocks in the Ergo blockchain.\n\n2. What dependencies are required to use this code?\n- This code requires the Retrofit2 library and its dependencies.\n\n3. What API calls can be made using this interface?\n- This interface allows for making API calls to get block header and transaction information, headers in a specified range, header IDs, last headers, persistent modifiers, and Merkle proofs for transactions. It also allows for sending a mined block.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/BlocksApi.md"}}],["143",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Body.java)\n\nThe `Body` class is part of the Ergo Node API and is used to represent the request body for certain API endpoints. Specifically, it is used to pass information related to wallet encryption and password protection of mnemonic seeds. \n\nThe class has two fields: `pass` and `mnemonicPass`. The `pass` field is a required string that represents the password used to encrypt the wallet file. The `mnemonicPass` field is an optional string that represents an additional password used to password-protect the mnemonic seed. \n\nThe class provides getter and setter methods for both fields, as well as methods for building instances of the class. It also overrides the `equals`, `hashCode`, and `toString` methods for object comparison and string representation. \n\nThis class is generated automatically by the Swagger code generator program and should not be edited manually. It is used in conjunction with other classes and methods in the Ergo Node API to provide a comprehensive set of tools for interacting with the Ergo blockchain. \n\nExample usage:\n\n```\nBody body = new Body();\nbody.setPass(\"myPassword\");\nbody.setMnemonicPass(\"myMnemonicPassword\");\n```\n\nThis creates a new instance of the `Body` class and sets the `pass` and `mnemonicPass` fields to the specified values. This instance can then be passed as the request body to certain API endpoints that require wallet encryption and/or mnemonic seed password protection.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `Body` that represents a request body for an API endpoint in the Ergo Node API.\n\n2. What are the required and optional parameters for the `Body` object?\n- The `pass` parameter is required and represents the password to encrypt the wallet file with. The `mnemonicPass` parameter is optional and represents a password to password-protect the mnemonic seed.\n\n3. Is this code editable?\n- No, this code should not be edited manually as it is auto-generated by the Swagger code generator program.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Body.md"}}],["144",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Body1.java)\n\nThe `Body1` class is a model class that represents a request body for a specific API endpoint in the Ergo Node API. Specifically, this class is used for the `/wallet/mnemonic` endpoint, which is used to create a new wallet from a mnemonic seed. \n\nThe class has three fields: `pass`, `mnemonic`, and `mnemonicPass`. `pass` is a required field that represents the password to encrypt the wallet file with. `mnemonic` is also a required field that represents the mnemonic seed used to generate the wallet. `mnemonicPass` is an optional field that represents a password to password-protect the mnemonic seed. \n\nThe class provides getter and setter methods for each field, as well as an `equals` method, a `hashCode` method, and a `toString` method. These methods are used to compare instances of the class, generate hash codes for instances of the class, and generate string representations of instances of the class, respectively. \n\nDevelopers using the Ergo Node API can use this class to create a request body for the `/wallet/mnemonic` endpoint. For example, the following code creates a `Body1` instance with the required fields set:\n\n```\nBody1 body = new Body1()\n    .pass(\"myPassword\")\n    .mnemonic(\"myMnemonicSeed\");\n```\n\nThe `body` instance can then be used as the request body when making a request to the `/wallet/mnemonic` endpoint.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `Body1` that represents a request body for a specific API endpoint in the Ergo Node API.\n\n2. What are the required fields for an instance of this class?\n- An instance of `Body1` must have a non-null `pass` and `mnemonic` field.\n\n3. What is the purpose of the `mnemonicPass` field?\n- The `mnemonicPass` field is an optional field that can be used to password-protect the `mnemonic` field.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Body1.md"}}],["145",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Body2.java)\n\nThe `Body2` class is a model class that represents a request body for a specific API endpoint in the Ergo Node API. The purpose of this class is to provide a structure for the request body that can be used to send data to the API endpoint. \n\nThe `Body2` class has two properties: `mnemonic` and `mnemonicPass`. The `mnemonic` property is a string that represents a mnemonic seed, which is an optional parameter. The `mnemonicPass` property is also a string that represents an optional password to protect the mnemonic seed. \n\nThis class provides getter and setter methods for both properties, which can be used to set and retrieve the values of these properties. Additionally, the class provides methods for equality checking, hashing, and string representation. \n\nThis class is generated automatically by the Swagger Codegen program and should not be edited manually. It is used in conjunction with other classes and methods in the Ergo Node API to provide a complete set of functionality for interacting with the Ergo blockchain. \n\nExample usage:\n\n```java\nBody2 body = new Body2();\nbody.setMnemonic(\"example mnemonic\");\nbody.setMnemonicPass(\"example password\");\n```\n\nIn this example, a new instance of the `Body2` class is created and the `mnemonic` and `mnemonicPass` properties are set using the provided setter methods. This instance can then be used as the request body for the API endpoint that requires this specific structure.\n## Questions: \n 1. What is the purpose of this code?\n- This code is a model class for the Ergo Node API, specifically for the Body2 object.\n\n2. What is the significance of the @SerializedName and @Schema annotations?\n- The @SerializedName annotation is used to specify the name of the JSON property that corresponds to a field in the Java object. The @Schema annotation is used to provide additional information about the field, such as whether it is required or optional, and a description.\n\n3. What is the purpose of the equals and hashCode methods?\n- The equals and hashCode methods are used to compare two instances of the Body2 class for equality. They are generated automatically by the IDE and compare the mnemonic and mnemonicPass fields of the objects.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Body2.md"}}],["146",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Body3.java)\n\nThe `Body3` class is a model class that represents the request body for a specific API endpoint in the Ergo Node API. The purpose of this class is to provide a structured way to pass a password to decrypt a wallet file to the API endpoint. \n\nThe class has a single field, `pass`, which is a string representing the password to decrypt the wallet file. The `pass` field has a getter and a setter method, which allow for getting and setting the value of the password. \n\nThe class also has methods for equality checking, hashing, and string representation. These methods are used to ensure that instances of the `Body3` class can be compared and hashed correctly, and to provide a human-readable string representation of the class.\n\nThis class is generated automatically by the Swagger Codegen program, which takes an OpenAPI specification as input and generates client code in various programming languages. In this case, the `Body3` class is generated from the OpenAPI specification for the Ergo Node API. \n\nIn the larger project, this class would be used by the client code to create instances of the `Body3` class and pass them as the request body to the API endpoint that requires a password to decrypt a wallet file. For example, in Java code, a `Body3` object could be created and populated with a password like this:\n\n```\nBody3 body = new Body3();\nbody.setPass(\"myPassword\");\n```\n\nThen, the `body` object could be passed as the request body to the API endpoint that requires a password to decrypt a wallet file.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `Body3` which represents a request body with a password field for decrypting a wallet file in the Ergo Node API.\n\n2. What is the expected format of the password field?\n- The password field is expected to be a string and is required according to the `@Schema` annotation.\n\n3. Can the `Body3` class be modified manually?\n- No, the class is auto-generated by the Swagger code generator program and should not be edited manually according to the comments in the code.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Body3.md"}}],["147",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Body4.java)\n\nThe `Body4` class is a model class that represents a request body for a specific API endpoint in the Ergo Node API. The purpose of this class is to provide a Java representation of the JSON request body that is expected by the API endpoint. \n\nThe `Body4` class has a single field, `address`, which is a string representing a Pay2PubKey address. The `address` field is annotated with Swagger annotations that provide additional information about the field, such as an example value and a description. \n\nThe `Body4` class also includes standard Java methods such as getters, setters, and `equals`, `hashCode`, and `toString` methods. These methods are used to manipulate and compare instances of the `Body4` class. \n\nThis class is generated automatically by the Swagger code generator program and should not be edited manually. It is used in conjunction with other classes and methods in the `org.ergoplatform.restapi.client` package to interact with the Ergo Node API. \n\nExample usage:\n\n```java\nBody4 body = new Body4();\nbody.setAddress(\"3WzCFq7mkykKqi4Ykdk8BK814tkh6EsPmA42pQZxU2NRwSDgd6yB\");\nString address = body.getAddress(); // returns \"3WzCFq7mkykKqi4Ykdk8BK814tkh6EsPmA42pQZxU2NRwSDgd6yB\"\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code is a model class for the Ergo Node API, specifically for the Body4 object.\n\n2. What is the expected input for the `address` field?\n- The `address` field is expected to be a Pay2PubKey address, as indicated in the `@Schema` annotation.\n\n3. Can the `address` field be null or empty?\n- No, the `address` field is marked as required in the `@Schema` annotation, so it cannot be null or empty.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Body4.md"}}],["148",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Body5.java)\n\nThis code defines a Java class called `Body5` that represents a request body for a REST API endpoint. The purpose of this class is to provide a model for the request body that can be used to generate documentation and client code for the API. \n\nThe `Body5` class has a single field called `derivationPath`, which is a string representing the derivation path for a new secret to derive. The `derivationPath` field is annotated with Swagger annotations that provide additional information about the field, such as an example value and a description. \n\nThe class also includes standard Java methods for getting and setting the `derivationPath` field, as well as methods for comparing instances of the class for equality and generating a string representation of the class. \n\nThis class is part of the `org.ergoplatform.restapi.client` package, which suggests that it is used by a client library for the Ergo Node API. The client library may use this class to generate request bodies for API requests, or to parse response bodies from API responses. \n\nExample usage:\n\n```java\nBody5 requestBody = new Body5();\nrequestBody.setDerivationPath(\"m/1/2\");\n\n// Use the requestBody object to make an API request\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `Body5` that represents a request body for a REST API endpoint in the Ergo Node API.\n\n2. What is the `derivationPath` property used for?\n- The `derivationPath` property is a required string property that specifies the derivation path for a new secret to derive.\n\n3. Can the `Body5` class be modified manually?\n- No, the `Body5` class is auto-generated by the Swagger code generator program and should not be edited manually.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Body5.md"}}],["149",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/BoxesRequestHolder.java)\n\nThe `BoxesRequestHolder` class is part of the Ergo Node API and is used to hold requests for wallet boxes. It contains two fields: `targetAssets` and `targetBalance`. \n\nThe `targetAssets` field is a list of lists, where each inner list represents a specific asset and contains two elements: the asset ID and the amount. This field is used to specify which assets the user wants to include in their wallet boxes. \n\nThe `targetBalance` field is a Long that represents the desired total balance of the wallet boxes. This field is used to specify the total amount of Ergs (the native currency of the Ergo blockchain) that the user wants to include in their wallet boxes. \n\nThe class provides methods to set and get the values of these fields, as well as to add items to the `targetAssets` list. It also includes methods to override the `equals`, `hashCode`, and `toString` methods for object comparison and printing.\n\nThis class can be used in the larger project to create requests for wallet boxes that meet specific criteria. For example, a user may want to create wallet boxes that contain a certain amount of Ergs and a specific set of assets. They can use this class to create a request object that specifies these criteria and then send the request to the Ergo Node API to retrieve the desired wallet boxes. \n\nHere is an example of how this class can be used:\n\n```\nBoxesRequestHolder request = new BoxesRequestHolder();\nrequest.addTargetAssetsItem(Arrays.asList(\"asset1\", 100));\nrequest.addTargetAssetsItem(Arrays.asList(\"asset2\", 50));\nrequest.targetBalance(500);\n\n// Send request to Ergo Node API and retrieve wallet boxes that meet the specified criteria\nList<WalletBox> boxes = ergoNodeApi.getWalletBoxes(request);\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `BoxesRequestHolder` that holds a request for wallet boxes.\n\n2. What are the required parameters for a `BoxesRequestHolder` object?\n- A `BoxesRequestHolder` object requires a `targetAssets` list and a `targetBalance` long value.\n\n3. What is the purpose of the `targetAssets` list?\n- The `targetAssets` list holds a list of target assets for the wallet boxes.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/BoxesRequestHolder.md"}}],["150",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/CandidateBlock.java)\n\nThe `CandidateBlock` class is part of the Ergo Node API and is used to represent a candidate block that is being mined by a node. It contains information about the block such as its version, timestamp, state root, and number of transactions. \n\nThe class has several methods that allow for setting and getting the values of its fields. For example, the `version` method sets the version of the candidate block, while the `getTransactionsNumber` method returns the number of transactions in the block. \n\nThe class also has methods for converting the object to a string and for checking if two objects are equal. These methods are used for debugging and testing purposes. \n\nOverall, the `CandidateBlock` class is an important part of the Ergo Node API as it allows developers to interact with candidate blocks that are being mined by nodes. It can be used in conjunction with other classes in the API to build applications that interact with the Ergo blockchain. \n\nExample usage:\n\n```java\nCandidateBlock block = new CandidateBlock();\nblock.setVersion(2);\nblock.setTimestamp(1631234567);\nblock.setParentId(\"1234567890abcdef\");\nblock.setTransactionsNumber(10);\n\nSystem.out.println(block.getVersion()); // Output: 2\nSystem.out.println(block.getTimestamp()); // Output: 1631234567\nSystem.out.println(block.getParentId()); // Output: 1234567890abcdef\nSystem.out.println(block.getTransactionsNumber()); // Output: 10\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code is a model for a candidate block in the Ergo Node API, which can be null if the node is not mining or the candidate block is not ready.\n\n2. What is the significance of the Transactions class?\n- The Transactions class is a property of the CandidateBlock class and represents the transactions included in the candidate block.\n\n3. Can the values of any of the properties be null?\n- Yes, the values of some properties can be null, such as timestamp, stateRoot, adProofBytes, and votes.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/CandidateBlock.md"}}],["151",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/CollectionFormats.java)\n\nThe `CollectionFormats` class in the `org.ergoplatform.restapi.client` package provides a set of classes for formatting collections of parameters into different string formats. The purpose of this code is to provide a convenient way to format collections of parameters for use in REST API requests.\n\nThe `CSVParams` class represents a collection of parameters separated by commas. It has three constructors: one that takes no arguments, one that takes a `List` of `String` parameters, and one that takes a variable number of `String` parameters. It also has a `toString()` method that joins the parameters into a comma-separated string.\n\nThe `SSVParams` class extends `CSVParams` and represents a collection of parameters separated by spaces. It has the same constructors as `CSVParams`, but overrides the `toString()` method to join the parameters into a space-separated string.\n\nThe `TSVParams` class extends `CSVParams` and represents a collection of parameters separated by tabs. It has the same constructors as `CSVParams`, but overrides the `toString()` method to join the parameters into a tab-separated string.\n\nThe `PIPESParams` class extends `CSVParams` and represents a collection of parameters separated by pipes. It has the same constructors as `CSVParams`, but overrides the `toString()` method to join the parameters into a pipe-separated string.\n\nThese classes can be used in the larger project to format collections of parameters for use in REST API requests. For example, if a REST API requires a comma-separated list of parameters, an instance of `CSVParams` can be created and passed as a parameter in the API request. Similarly, if a REST API requires a space-separated list of parameters, an instance of `SSVParams` can be created and passed as a parameter in the API request. By providing these different formatting options, the `CollectionFormats` class makes it easier to work with REST APIs that have different requirements for parameter formatting.\n## Questions: \n 1. What is the purpose of the `CollectionFormats` class?\n    \n    `CollectionFormats` is a class that defines several nested classes that represent different formats for collections of parameters.\n\n2. What are the differences between the `CSVParams`, `SSVParams`, `TSVParams`, and `PIPESParams` classes?\n    \n    Each of these classes extends `CSVParams` and overrides the `toString()` method to join the list of parameters with a different delimiter (comma, space, tab, or pipe).\n\n3. What is the purpose of the `StringUtil` class?\n    \n    The `StringUtil` class is not shown in this code, but it is likely used to provide a utility method for joining an array of strings with a delimiter.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/CollectionFormats.md"}}],["152",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Commitment.java)\n\nThe `Commitment` class is part of the Ergo Node API and provides a basic trait for prover commitments. The class is auto-generated by the Swagger code generator program and should not be edited manually. \n\nThe `Commitment` class has six fields: `hint`, `pubkey`, `position`, `type`, `a`, and `b`. The `hint` field is an enum that can take one of three values: `cmtWithSecret`, `cmtReal`, or `cmtSimulated`. The `pubkey` field is of type `SigmaBoolean` and represents the public key of the commitment. The `position` field is a string that represents the position of the commitment. The `type` field is an enum that can take one of two values: `dlog` or `dht`. The `a` field is a string that represents a group element of the commitment, and the `b` field is a string that represents the `b` group element of the commitment (needed for DHT protocol only).\n\nThe `Commitment` class has getter and setter methods for each field. The `hint`, `pubkey`, and `position` fields are required, while the `type`, `a`, and `b` fields are optional. The `Commitment` class also has an `equals` method that compares two `Commitment` objects for equality, a `hashCode` method that returns a hash code value for the object, and a `toString` method that returns a string representation of the object.\n\nThe `Commitment` class can be used in the larger Ergo Node API project to represent prover commitments. For example, the `Commitment` class could be used in a method that generates a proof for a transaction. The `Commitment` object would be created with the necessary fields, and then passed to the proof generation method.\n## Questions: \n 1. What is the purpose of this code and what does it do?\n- This code defines a Java class called `Commitment` which represents a basic trait for prover commitments. It contains properties such as `hint`, `pubkey`, `position`, `type`, `a`, and `b`.\n\n2. What external libraries or dependencies does this code rely on?\n- This code relies on the `google-gson` and `io.swagger.v3.oas.annotations` libraries for JSON serialization and deserialization, and for OpenAPI schema annotations, respectively.\n\n3. What is the significance of the `HintEnum` and `TypeEnum` enums defined in this code?\n- The `HintEnum` enum represents the different types of hints that can be used for prover commitments, while the `TypeEnum` enum represents the different types of commitment protocols that can be used. These enums are used to set and get values for the `hint` and `type` properties of the `Commitment` class.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Commitment.md"}}],["153",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/CommitmentWithSecret.java)\n\nThis code defines a Java class called `CommitmentWithSecret` which extends another class called `Commitment`. The purpose of this class is to represent a commitment to a secret value along with the secret randomness used to generate the commitment. This class is generated automatically by the Swagger code generator program and should not be edited manually.\n\nThe `CommitmentWithSecret` class has a few methods that override methods from the `Commitment` class. The `equals` method checks if two `CommitmentWithSecret` objects are equal by calling the `equals` method of the superclass. The `hashCode` method returns the hash code of the superclass. The `toString` method returns a string representation of the `CommitmentWithSecret` object by calling the `toString` method of the superclass and appending it to a string.\n\nThis class may be used in the larger project to represent commitments to secret values with secret randomness. For example, if the project involves creating and verifying zero-knowledge proofs, this class may be used to represent the commitments used in the proofs. Here is an example of how this class may be used:\n\n```\nCommitmentWithSecret commitment = new CommitmentWithSecret();\ncommitment.setValue(\"secret value\");\ncommitment.setRandomness(\"secret randomness\");\n```\n\nIn this example, a new `CommitmentWithSecret` object is created and its `setValue` and `setRandomness` methods are called to set the secret value and randomness used to generate the commitment. This object can then be used in other parts of the project to generate and verify zero-knowledge proofs.\n## Questions: \n 1. What is the purpose of the `CommitmentWithSecret` class and how does it differ from the `Commitment` class it extends?\n- The `CommitmentWithSecret` class represents a commitment to a secret along with secret randomness, and it extends the `Commitment` class. It does not add any additional fields or methods, but overrides the `equals` and `hashCode` methods to compare based on the parent class.\n\n2. What is the `@Schema` annotation used for in this code?\n- The `@Schema` annotation is used to provide a description of the class for use in API documentation generated by the OpenAPI spec. In this case, it describes the purpose of the `CommitmentWithSecret` class.\n\n3. Why does the `toString` method call `toIndentedString` instead of `super.toString` directly?\n- The `toIndentedString` method is a private helper method that formats the output of the `toString` method by adding indentation to each line. By calling `toIndentedString` instead of `super.toString` directly, the output of the parent class's `toString` method is also indented.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/CommitmentWithSecret.md"}}],["154",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ContainsAssetPredicate.java)\n\nThe `ContainsAssetPredicate` class is part of the Ergo Node API and is used to represent a scanning predicate for searching for a specific asset in a transaction. This class extends the `ScanningPredicate` class and adds an `assetId` field to represent the ID of the asset being searched for.\n\nThis class is generated automatically by the Swagger code generator program and should not be edited manually. It includes methods for setting and getting the `assetId` field, as well as methods for checking equality and generating a string representation of the object.\n\nIn the larger project, this class may be used to create scanning predicates for searching for specific assets in transactions. For example, a developer could create a `ContainsAssetPredicate` object with a specific `assetId` and use it to search for transactions that contain that asset. This could be useful for tracking the movement of a particular asset or for verifying that a transaction contains the expected assets before it is broadcast to the network.\n\nHere is an example of how this class could be used in code:\n\n```\nContainsAssetPredicate predicate = new ContainsAssetPredicate();\npredicate.assetId(\"abcdef1234567890\");\n```\n\nThis code creates a new `ContainsAssetPredicate` object and sets its `assetId` field to \"abcdef1234567890\". This object could then be used to search for transactions that contain the asset with that ID.\n## Questions: \n 1. What is the purpose of this code?\n   - This code defines a Java class called `ContainsAssetPredicate` which extends another class called `ScanningPredicate`. It contains a field called `assetId` and methods to get and set its value.\n\n2. What is the relationship between `ContainsAssetPredicate` and `ScanningPredicate`?\n   - `ContainsAssetPredicate` extends `ScanningPredicate`, which means it inherits all of its fields and methods. This suggests that `ContainsAssetPredicate` is a more specific type of `ScanningPredicate`.\n\n3. What is the purpose of the `toIndentedString` method?\n   - The `toIndentedString` method is a private helper method that converts an object to a string with each line indented by 4 spaces. It is used in the `toString` method to format the output of the `ContainsAssetPredicate` class.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ContainsAssetPredicate.md"}}],["155",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ContainsPredicate.java)\n\nThe `ContainsPredicate` class is part of the Ergo Node API and is used to represent a scanning predicate that checks if a given register contains a specific byte sequence. This class extends the `ScanningPredicate` class, which provides additional functionality for scanning Ergo transactions.\n\nThe `ContainsPredicate` class has two properties: `register` and `bytes`. The `register` property is a string that specifies the register to scan, while the `bytes` property is a required string that specifies the byte sequence to search for.\n\nThis class provides methods to set and get the values of these properties. The `register` property can be set using the `register()` method, while the `bytes` property can be set using the `bytes()` method. Both methods return the `ContainsPredicate` object, which allows for method chaining.\n\nThe `equals()`, `hashCode()`, and `toString()` methods are also implemented in this class. These methods are used to compare two `ContainsPredicate` objects for equality, generate a hash code for the object, and convert the object to a string representation, respectively.\n\nOverall, the `ContainsPredicate` class is a useful tool for scanning Ergo transactions for specific byte sequences in a given register. It can be used in conjunction with other scanning predicates to create complex scanning rules for Ergo transactions. Here is an example of how this class can be used:\n\n```\nContainsPredicate predicate = new ContainsPredicate();\npredicate.register(\"R4\");\npredicate.bytes(\"0x1234567890abcdef\");\n``` \n\nThis code creates a new `ContainsPredicate` object and sets the `register` property to \"R4\" and the `bytes` property to \"0x1234567890abcdef\". This predicate can then be used to scan Ergo transactions for the specified byte sequence in the \"R4\" register.\n## Questions: \n 1. What is the purpose of this code?\n- This code is a Java class for a ContainsPredicate object used in the Ergo Node API. It extends the ScanningPredicate class and contains two properties: register and bytes.\n\n2. What is the significance of the ScanningPredicate class?\n- The ScanningPredicate class is a parent class of ContainsPredicate and likely contains shared properties and methods that are relevant to all scanning predicates used in the Ergo Node API.\n\n3. What is the expected format of the \"bytes\" property?\n- The \"bytes\" property is marked as required and is a string type, but without additional context it is unclear what format the string should be in.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ContainsPredicate.md"}}],["156",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/CryptoResult.java)\n\nThe `CryptoResult` class is part of the Ergo Node API and is used to represent the result of an `executeWithContext` request. Specifically, it represents the result of reducing a Sigma Boolean expression to a cryptographic value. \n\nThe class has two fields: `value` and `cost`. The `value` field is of type `SigmaBoolean` and represents the cryptographic value resulting from the reduction of the Sigma Boolean expression. The `cost` field is of type `Long` and represents the estimated cost of executing the contract.\n\nThe `CryptoResult` class provides methods for setting and getting the values of its fields. The `value` field is required and must be set using the `value` method. The `cost` field is also required and must be set using the `cost` method.\n\nThe class also provides methods for comparing instances of `CryptoResult` for equality and generating a string representation of an instance. These methods are used for debugging and testing purposes.\n\nIn the larger project, the `CryptoResult` class is used to represent the result of reducing a Sigma Boolean expression to a cryptographic value. This result is then used in other parts of the project to perform various operations, such as verifying transactions and executing smart contracts. For example, the `CryptoResult` class may be used in conjunction with the `Transaction` class to verify that a transaction is valid. \n\nOverall, the `CryptoResult` class is an important part of the Ergo Node API and is used to represent the result of reducing a Sigma Boolean expression to a cryptographic value.\n## Questions: \n 1. What is the purpose of this code?\n    \n    This code defines a Java class called `CryptoResult` that represents the result of an executeWithContext request in the Ergo Node API. It contains a SigmaBoolean value and an estimated cost of contract execution.\n\n2. What is the significance of the `@Schema` annotation?\n    \n    The `@Schema` annotation is used to provide metadata about the class and its properties for use in generating API documentation. It includes a description of the class and its properties.\n\n3. What is the purpose of the `toIndentedString` method?\n    \n    The `toIndentedString` method is a helper method used to convert an object to a string with each line indented by 4 spaces. It is used in the `toString` method to format the output of the `CryptoResult` class.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/CryptoResult.md"}}],["157",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/DhtSecret.java)\n\nThe `DhtSecret` class is a model class that represents a Diffie-Hellman tuple consisting of a secret exponent `w`, along with generators `g` and `h`, and group elements `u` and `v`. The purpose of this class is to provide a standardized way of representing this tuple in the Ergo Node API. \n\nThe class contains five private fields, each of which represents one of the tuple elements. These fields are annotated with `@SerializedName` and `@Schema` annotations, which provide metadata about the fields. The `@SerializedName` annotation specifies the name of the field in the serialized JSON representation of the object, while the `@Schema` annotation provides a description of the field, an example value, and whether the field is required or not.\n\nThe class also contains getter and setter methods for each field, which allow the fields to be accessed and modified. Additionally, the class contains methods for equality checking, hashing, and string representation.\n\nThis class can be used in the larger Ergo Node API project to represent Diffie-Hellman tuples in various API endpoints. For example, it could be used in an endpoint that generates a new DHT secret, or in an endpoint that retrieves an existing DHT secret. \n\nHere is an example of how this class could be used to create a new DHT secret:\n\n```\nDhtSecret secret = new DhtSecret()\n    .secret(\"433080ff80d0d52d7f8bfffff47f00807f44f680000949b800007f7f7ff1017f\")\n    .g(\"02a7955281885bf0f0ca4a48678848cad8dc5b328ce8bc1d4481d041c98e891ff3\")\n    .h(\"02a7955281885bf0f0ca4a48678848cad8dc5b328ce8bc1d4481d041c98e891ff3\")\n    .u(\"02a7955281885bf0f0ca4a48678848cad8dc5b328ce8bc1d4481d041c98e891ff3\")\n    .v(\"02a7955281885bf0f0ca4a48678848cad8dc5b328ce8bc1d4481d041c98e891ff3\");\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `DhtSecret` which represents a Diffie-Hellman tuple with secret exponent and generators.\n\n2. What dependencies does this code have?\n- This code depends on the `com.google.gson` and `io.swagger.v3.oas.annotations` libraries.\n\n3. Can the properties of this class be null?\n- No, all properties of this class (`secret`, `g`, `h`, `u`, and `v`) are marked as required in the OpenAPI schema annotations.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/DhtSecret.md"}}],["158",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/DlogCommitment.java)\n\nThe `DlogCommitment` class is part of the Ergo Node API and is used to model the randomness and commitment for the first step of the Schnorr protocol. The class contains two fields, `r` and `a`, which are both represented as hexadecimal strings. \n\nThe `r` field represents the big-endian 256-bit secret exponent used in the protocol, while the `a` field represents the generator for the Diffie-Hellman tuple (secp256k1 curve point). Both fields are required and have corresponding getter and setter methods.\n\nThis class is generated automatically by the Swagger code generator program and should not be edited manually. It is used to provide a standardized way of representing the randomness and commitment values required for the Schnorr protocol across all Ergo products.\n\nHere is an example of how this class might be used in the larger project:\n\n```java\nDlogCommitment commitment = new DlogCommitment()\n    .r(\"433080ff80d0d52d7f8bfffff47f00807f44f680000949b800007f7f7ff1017f\")\n    .a(\"02a7955281885bf0f0ca4a48678848cad8dc5b328ce8bc1d4481d041c98e891ff3\");\n\n// Use the commitment object in the Schnorr protocol\nSchnorrProtocol protocol = new SchnorrProtocol(commitment);\nprotocol.run();\n``` \n\nIn this example, a new `DlogCommitment` object is created with the required `r` and `a` values. This object is then passed to a `SchnorrProtocol` object, which uses the commitment values in the protocol. By using the `DlogCommitment` class to represent the commitment values, the code is more standardized and easier to maintain across different Ergo products.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `DlogCommitment` that represents randomness and commitment for the first step of the Schnorr protocol.\n\n2. What external libraries or dependencies does this code use?\n- This code uses the `com.google.gson` and `io.swagger.v3.oas` libraries for JSON serialization and OpenAPI schema annotations.\n\n3. Can the `r` and `a` fields be null or empty?\n- It is not specified in the code whether the `r` and `a` fields can be null or empty. However, the `@Schema` annotation for both fields specifies that they are required, so it is likely that they cannot be null or empty.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/DlogCommitment.md"}}],["159",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/EmissionInfo.java)\n\nThe `EmissionInfo` class is a model class that represents the emission information for a given height in the Ergo blockchain. It contains three fields: `minerReward`, `totalCoinsIssued`, and `totalRemainCoins`, which are all of type `Long`. \n\nThe `minerReward` field represents the reward that the miner of the block at the given height will receive. The `totalCoinsIssued` field represents the total number of coins that have been issued up to and including the given height. The `totalRemainCoins` field represents the total number of coins that remain to be issued after the given height.\n\nThis class is used in the Ergo Node API to provide information about the current state of the Ergo blockchain. It can be used by clients of the API to retrieve information about the current emission schedule of the Ergo blockchain, which can be useful for various purposes such as calculating the inflation rate of the Ergo coin.\n\nHere is an example of how this class might be used in the Ergo Node API:\n\n```java\nErgoApi ergoApi = new ErgoApi();\nEmissionInfo emissionInfo = ergoApi.getEmissionInfo(1000000);\nSystem.out.println(\"Miner reward at height 1000000: \" + emissionInfo.getMinerReward());\nSystem.out.println(\"Total coins issued at height 1000000: \" + emissionInfo.getTotalCoinsIssued());\nSystem.out.println(\"Total remain coins after height 1000000: \" + emissionInfo.getTotalRemainCoins());\n```\n\nIn this example, we create an instance of the `ErgoApi` class and use it to retrieve the emission information for height 1000000. We then print out the values of the `minerReward`, `totalCoinsIssued`, and `totalRemainCoins` fields of the `EmissionInfo` object.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `EmissionInfo` which contains information about the emission of a cryptocurrency called Ergo.\n\n2. What are the properties of the `EmissionInfo` class?\n- The `EmissionInfo` class has three properties: `minerReward`, `totalCoinsIssued`, and `totalRemainCoins`, all of which are of type `Long`.\n\n3. What is the purpose of the `toIndentedString` method?\n- The `toIndentedString` method is a private helper method that converts an object to a string with each line indented by 4 spaces, except for the first line. It is used in the `toString` method to format the output of the `EmissionInfo` class.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/EmissionInfo.md"}}],["160",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/EqualsPredicate.java)\n\nThe `EqualsPredicate` class is part of the Ergo Node API and is used to represent a scanning predicate for searching for a specific value in a register of a transaction. This class extends the `ScanningPredicate` class and adds two fields: `register` and `bytes`. The `register` field is a string that represents the name of the register to search in, while the `bytes` field is a string that represents the value to search for.\n\nThis class is generated automatically by the Swagger code generator program and should not be edited manually. It provides methods for setting and getting the values of the `register` and `bytes` fields, as well as methods for checking equality and generating a string representation of the object.\n\nThis class can be used in the larger Ergo Node API project to represent a scanning predicate for searching for a specific value in a register of a transaction. For example, the following code snippet shows how an `EqualsPredicate` object can be created and used to search for a specific value in a register:\n\n```\nEqualsPredicate predicate = new EqualsPredicate();\npredicate.register(\"R4\");\npredicate.bytes(\"1234567890abcdef\");\n\nList<Transaction> transactions = nodeApi.searchTransactions(predicate);\n```\n\nIn this example, an `EqualsPredicate` object is created with the `register` field set to \"R4\" and the `bytes` field set to \"1234567890abcdef\". This object is then passed to the `searchTransactions` method of the `nodeApi` object, which returns a list of transactions that match the predicate.\n## Questions: \n 1. What is the purpose of this code?\n- This code is a model for an EqualsPredicate object used in the Ergo Node API.\n\n2. What is the relationship between this code and other files in the ergo-appkit project?\n- It is unclear from this code snippet what the relationship is between this code and other files in the ergo-appkit project.\n\n3. What is the expected input and output of the methods in this code?\n- The expected input and output of the methods in this code are not explicitly stated, but can be inferred from the code comments and annotations. For example, the `getBytes()` method is annotated with `@Schema(required = true, description = \"\")`, indicating that it expects a non-null input and returns a String.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/EqualsPredicate.md"}}],["161",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ErgoLikeContext.java)\n\nThe `ErgoLikeContext` class is part of the `ergo-appkit` project and is used to represent the context of an Ergo transaction. It contains various fields that are used to evaluate the transaction script. \n\nThe `lastBlockUtxoRoot` field is an `AvlTreeData` object that represents the root of the UTXO set of the last block. The `headers` field is a list of `SigmaHeader` objects that represent the headers of the last few blocks in descending order. The `preHeader` field is a `PreHeader` object that represents the pre-header of the current block. The `dataBoxes` field is a list of `ErgoTransactionOutput` objects that correspond to the data inputs of the transaction. The `boxesToSpend` field is a list of `ErgoTransactionOutput` objects that correspond to the inputs of the transaction. The `spendingTransaction` field is an `ErgoLikeTransaction` object that represents the transaction being evaluated. The `selfIndex` field is an index of the box in `boxesToSpend` that contains the script being evaluated. The `extension` field is a prover-defined key-value pair that may be used inside a script. The `validationSettings` field is a string that represents the validation parameters passed to `Interpreter.verify` to detect soft-fork conditions. The `costLimit` field is a hard limit on the accumulated execution cost, and if exceeded, leads to a `CostLimitException` being thrown. The `initCost` field is the initial value of the execution cost already accumulated before `Interpreter.verify` is called.\n\nThis class is generated by the Swagger code generator program and should not be edited manually. It provides a convenient way to represent the context of an Ergo transaction and can be used in conjunction with other classes in the `ergo-appkit` project to build Ergo applications. \n\nExample usage:\n\n```java\nErgoLikeContext context = new ErgoLikeContext();\ncontext.lastBlockUtxoRoot(lastBlockUtxoRoot)\n       .headers(headers)\n       .preHeader(preHeader)\n       .dataBoxes(dataBoxes)\n       .boxesToSpend(boxesToSpend)\n       .spendingTransaction(spendingTransaction)\n       .selfIndex(selfIndex)\n       .extension(extension)\n       .validationSettings(validationSettings)\n       .costLimit(costLimit)\n       .initCost(initCost);\n```\n\nThis creates a new `ErgoLikeContext` object and sets its fields using the provided values. The resulting object can then be used to evaluate an Ergo transaction script.\n## Questions: \n 1. What is the purpose of the `ErgoLikeContext` class?\n- The `ErgoLikeContext` class is an API model for Ergo Node that contains various properties related to a transaction context.\n\n2. What are the required properties of the `ErgoLikeContext` class?\n- The required properties of the `ErgoLikeContext` class are `lastBlockUtxoRoot`, `headers`, `preHeader`, `dataBoxes`, `boxesToSpend`, `spendingTransaction`, `selfIndex`, `extension`, `validationSettings`, `costLimit`, and `initCost`.\n\n3. What is the purpose of the `validationSettings` property?\n- The `validationSettings` property is used to pass validation parameters to `Interpreter.verify` in order to detect soft-fork conditions.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ErgoLikeContext.md"}}],["162",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ErgoLikeTransaction.java)\n\nThe `ErgoLikeTransaction` class is part of the `ergo-appkit` project and is used to model an Ergo transaction. It contains four fields: `id`, `inputs`, `dataInputs`, and `outputs`. \n\nThe `id` field is a string that represents the transaction ID. The `inputs` field is a list of `ErgoTransactionInput` objects, which represent the inputs to the transaction. The `dataInputs` field is a list of `ErgoTransactionDataInput` objects, which represent the data inputs to the transaction. The `outputs` field is a list of `ErgoTransactionOutput` objects, which represent the outputs of the transaction.\n\nThis class is generated by the Swagger code generator program and should not be edited manually. It provides methods to set and get the values of its fields. For example, to set the `id` field, you can call the `id` method and pass in a string:\n\n```\nErgoLikeTransaction transaction = new ErgoLikeTransaction();\ntransaction.id(\"12345\");\n```\n\nTo add an input to the transaction, you can call the `addInputsItem` method and pass in an `ErgoTransactionInput` object:\n\n```\nErgoTransactionInput input = new ErgoTransactionInput();\ntransaction.addInputsItem(input);\n```\n\nSimilarly, to add a data input or an output to the transaction, you can call the `addDataInputsItem` or `addOutputsItem` method, respectively.\n\nOverall, the `ErgoLikeTransaction` class is an important part of the `ergo-appkit` project as it provides a way to model Ergo transactions and interact with them programmatically.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `ErgoLikeTransaction` that represents a transaction in the Ergo blockchain.\n\n2. What are the main properties of an `ErgoLikeTransaction` object?\n- An `ErgoLikeTransaction` object has four properties: `id`, `inputs`, `dataInputs`, and `outputs`. `id` is a string that uniquely identifies the transaction, while `inputs`, `dataInputs`, and `outputs` are lists of objects representing the inputs, data inputs, and outputs of the transaction, respectively.\n\n3. Can the properties of an `ErgoLikeTransaction` object be modified after it is created?\n- Yes, the properties of an `ErgoLikeTransaction` object can be modified using the setter methods provided (`setId()`, `setInputs()`, `setDataInputs()`, and `setOutputs()`), as well as the `addInputsItem()`, `addDataInputsItem()`, and `addOutputsItem()` methods for adding individual items to the corresponding lists.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ErgoLikeTransaction.md"}}],["163",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ErgoTransaction.java)\n\nThe `ErgoTransaction` class is a model class that represents an Ergo transaction. It contains information about the transaction's inputs, data inputs, outputs, and size in bytes. This class is generated automatically by the Swagger code generator program and should not be edited manually.\n\nThe `ErgoTransaction` class can be used in the larger project to represent Ergo transactions in a standardized way. For example, it can be used to deserialize JSON responses from the Ergo Node API into Java objects. Here is an example of how this class can be used:\n\n```java\nimport org.ergoplatform.restapi.client.ErgoTransaction;\nimport com.google.gson.Gson;\n\n// Assume that we have a JSON response from the Ergo Node API\nString jsonResponse = \"{\\\"id\\\":\\\"123\\\",\\\"inputs\\\":[],\\\"dataInputs\\\":[],\\\"outputs\\\":[],\\\"size\\\":100}\";\n\n// Deserialize the JSON response into an ErgoTransaction object\nGson gson = new Gson();\nErgoTransaction transaction = gson.fromJson(jsonResponse, ErgoTransaction.class);\n\n// Access the properties of the ErgoTransaction object\nString id = transaction.getId();\nList<ErgoTransactionInput> inputs = transaction.getInputs();\nList<ErgoTransactionDataInput> dataInputs = transaction.getDataInputs();\nList<ErgoTransactionOutput> outputs = transaction.getOutputs();\nInteger size = transaction.getSize();\n```\n\nIn this example, we first assume that we have a JSON response from the Ergo Node API. We then use the Gson library to deserialize the JSON response into an `ErgoTransaction` object. Finally, we access the properties of the `ErgoTransaction` object to get information about the transaction.\n\nOverall, the `ErgoTransaction` class is an important part of the Ergo Node API client library and can be used to represent Ergo transactions in a standardized way.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `ErgoTransaction` which represents an Ergo transaction and contains information about its inputs, data inputs, outputs, and size.\n\n2. What dependencies does this code have?\n- This code depends on the `com.google.gson` and `io.swagger.v3.oas.annotations` libraries.\n\n3. Can the properties of an `ErgoTransaction` object be modified after it is created?\n- Yes, the properties of an `ErgoTransaction` object can be modified using the setter methods provided in the class.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ErgoTransaction.md"}}],["164",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ErgoTransactionDataInput.java)\n\nThe code defines a Java class called `ErgoTransactionDataInput` which represents a data input for a transaction in the Ergo blockchain platform. The class has two fields: `boxId` and `extension`. The `boxId` field is a required string that represents the ID of the box (i.e., an unspent transaction output) that is being used as an input for the transaction. The `extension` field is an optional map of key-value pairs that can be used to attach additional data to the input.\n\nThe class provides methods to get and set the values of the fields, as well as a method to add a key-value pair to the `extension` map. The class also overrides the `equals`, `hashCode`, and `toString` methods for object comparison and string representation.\n\nThis class is part of the Ergo Node API and is used to model transaction inputs in Ergo transactions. It can be used by developers who are building applications on top of the Ergo platform to create and manipulate transactions. For example, a developer could create an instance of `ErgoTransactionDataInput`, set the `boxId` and `extension` fields, and then use this object to construct a transaction. Here is an example of how this class could be used:\n\n```\nErgoTransactionDataInput input = new ErgoTransactionDataInput();\ninput.setBoxId(\"1234567890abcdef\");\ninput.putExtensionItem(\"key1\", \"value1\");\ninput.putExtensionItem(\"key2\", \"value2\");\n```\n\nIn this example, we create a new `ErgoTransactionDataInput` object, set the `boxId` field to \"1234567890abcdef\", and add two key-value pairs to the `extension` map. The resulting object can then be used to create a transaction input.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `ErgoTransactionDataInput` which represents a data input for an Ergo transaction.\n\n2. What is the significance of the `extension` field?\n- The `extension` field is a map of key-value pairs that can be used to store additional data related to the transaction input.\n\n3. Can the `boxId` field be null?\n- No, the `boxId` field is marked as required in the OpenAPI schema and must have a non-null value.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ErgoTransactionDataInput.md"}}],["165",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ErgoTransactionInput.java)\n\nThe `ErgoTransactionInput` class is part of the Ergo Node API and is used to represent an input to a transaction on the Ergo blockchain. It contains three fields: `boxId`, `spendingProof`, and `extension`. \n\nThe `boxId` field is a required string that represents the ID of the box being spent as an input to the transaction. The `spendingProof` field is also required and represents the proof that the transaction is authorized to spend the box. The `extension` field is an optional map of key-value pairs that can be used to include additional information about the input.\n\nThis class is generated automatically by the Swagger code generator program and should not be edited manually. It includes methods to set and get the values of the fields, as well as methods to add and retrieve items from the `extension` map.\n\nThis class can be used in conjunction with other classes in the Ergo Node API to build and submit transactions on the Ergo blockchain. For example, a `ErgoTransaction` object could be created that contains one or more `ErgoTransactionInput` objects, along with one or more `ErgoTransactionOutput` objects, to represent a complete transaction. The `ErgoTransaction` object could then be submitted to the Ergo Node API to be included in the blockchain.\n\nExample usage:\n\n```\nErgoTransactionInput input = new ErgoTransactionInput()\n    .boxId(\"1234567890abcdef\")\n    .spendingProof(new SpendingProof())\n    .putExtensionItem(\"key1\", \"value1\")\n    .putExtensionItem(\"key2\", \"value2\");\n\nErgoTransaction transaction = new ErgoTransaction()\n    .inputs(Arrays.asList(input))\n    .outputs(Arrays.asList(output))\n    .fee(1000000L);\n\nErgoApi api = new ErgoApi();\napi.submitTransaction(transaction);\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `ErgoTransactionInput` that represents an input to an Ergo transaction, including the box ID, spending proof, and extension.\n\n2. What dependencies does this code have?\n- This code depends on the `com.google.gson` and `io.swagger.v3.oas.annotations` libraries.\n\n3. Can the `extension` field be null?\n- Yes, the `extension` field can be null. If it is not null, it is a map of string key-value pairs.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ErgoTransactionInput.md"}}],["166",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ErgoTransactionOutput.java)\n\nThe `ErgoTransactionOutput` class is part of the `ergo-appkit` project and is used to model the output of an Ergo transaction. It contains information about the output box, such as its ID, value, ErgoTree, creation height, assets, additional registers, transaction ID, and index.\n\nThe `ErgoTransactionOutput` class is generated automatically by the Swagger code generator program and should not be edited manually. It includes annotations such as `@SerializedName` and `@Schema` to specify the JSON field names and descriptions.\n\nThis class can be used in the larger `ergo-appkit` project to represent the output of an Ergo transaction. For example, it can be used to parse JSON responses from the Ergo Node API and convert them into Java objects. Here is an example of how this class can be used:\n\n```java\nimport org.ergoplatform.restapi.client.ErgoTransactionOutput;\nimport com.google.gson.Gson;\n\n// Parse JSON response from Ergo Node API\nString json = \"{ \\\"boxId\\\": \\\"abc123\\\", \\\"value\\\": 1000000, \\\"ergoTree\\\": \\\"{ ... }\\\", ... }\";\nGson gson = new Gson();\nErgoTransactionOutput output = gson.fromJson(json, ErgoTransactionOutput.class);\n\n// Access fields of ErgoTransactionOutput object\nString boxId = output.getBoxId();\nLong value = output.getValue();\nString ergoTree = output.getErgoTree();\n// ...\n```\n\nOverall, the `ErgoTransactionOutput` class is an important part of the `ergo-appkit` project and provides a convenient way to represent the output of an Ergo transaction in Java code.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `ErgoTransactionOutput` which represents an output of an Ergo transaction.\n\n2. What are the properties of an `ErgoTransactionOutput` object?\n- An `ErgoTransactionOutput` object has the following properties: `boxId`, `value`, `ergoTree`, `creationHeight`, `assets`, `additionalRegisters`, `transactionId`, and `index`.\n\n3. What is the purpose of the `toIndentedString` method?\n- The `toIndentedString` method is a helper method used to convert an object to a string with each line indented by 4 spaces. It is used in the `toString` method to format the output of the `ErgoTransactionOutput` object.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ErgoTransactionOutput.md"}}],["167",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ErgoTransactionUnsignedInput.java)\n\nThe `ErgoTransactionUnsignedInput` class is part of the Ergo Node API and is used to represent an unsigned input in an Ergo transaction. The class has two fields: `boxId` and `extension`. \n\nThe `boxId` field is a required string that represents the ID of the box that is being spent as an input in the transaction. \n\nThe `extension` field is an optional map of key-value pairs that can be used to include additional information about the input. The keys and values in the map are both strings. \n\nThe class provides getter and setter methods for both fields, as well as a convenience method `putExtensionItem` for adding items to the `extension` map. \n\nThis class is generated automatically by the Swagger code generator program and should not be edited manually. It can be used in conjunction with other classes in the Ergo Node API to build and submit Ergo transactions. \n\nExample usage:\n\n```\nErgoTransactionUnsignedInput input = new ErgoTransactionUnsignedInput()\n    .boxId(\"1234567890abcdef\")\n    .putExtensionItem(\"key1\", \"value1\")\n    .putExtensionItem(\"key2\", \"value2\");\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `ErgoTransactionUnsignedInput` that represents an unsigned input for an Ergo transaction.\n\n2. What dependencies does this code have?\n- This code depends on the `com.google.gson` and `io.swagger.v3.oas.annotations` libraries.\n\n3. Can the `extension` field be null?\n- Yes, the `extension` field can be null.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ErgoTransactionUnsignedInput.md"}}],["168",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ExecuteScript.java)\n\nThe `ExecuteScript` class is part of the Ergo Node API and is used to execute Sigma scripts. Sigma is a scripting language used in the Ergo blockchain platform. This class is generated automatically by the Swagger code generator program and should not be edited manually.\n\nThe `ExecuteScript` class has three properties: `script`, `namedConstants`, and `context`. The `script` property is a string that represents the Sigma script to be executed. The `namedConstants` property is an object that represents the environment for the compiler. The `context` property is an object of type `ErgoLikeContext` that represents the context in which the script is executed.\n\nThe `ExecuteScript` class has three methods: `script()`, `namedConstants()`, and `context()`. These methods are used to set the values of the `script`, `namedConstants`, and `context` properties, respectively. Each of these methods returns an instance of the `ExecuteScript` class, which allows for method chaining.\n\nThe `ExecuteScript` class also has several methods that are used for serialization and deserialization of the class. These methods are used to convert the `ExecuteScript` object to and from JSON format.\n\nThis class can be used in the larger project to execute Sigma scripts in the Ergo blockchain platform. An example of how this class can be used is as follows:\n\n```\nExecuteScript executeScript = new ExecuteScript()\n    .script(\"sigma script\")\n    .namedConstants(\"environment\")\n    .context(new ErgoLikeContext());\n\n// execute the script\nexecuteScript.execute();\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code is a Java class for executing a Sigma script in the Ergo Node API.\n\n2. What are the required parameters for executing a Sigma script?\n- The required parameters are the Sigma script itself and the environment for the compiler.\n\n3. Can the ErgoLikeContext object be null?\n- No, the ErgoLikeContext object is required and cannot be null.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ExecuteScript.md"}}],["169",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Extension.java)\n\nThe `Extension` class is part of the Ergo Node API and is used to represent an extension in the Ergo blockchain. An extension is a piece of data that can be attached to a transaction or block in the blockchain. \n\nThe `Extension` class has three properties: `headerId`, `digest`, and `fields`. The `headerId` property is a string that identifies the type of extension. The `digest` property is a string that represents the hash of the extension data. The `fields` property is a list of `KeyValueItem` objects, which represent key-value pairs of data that make up the extension.\n\nThe `Extension` class provides methods to get and set the values of its properties. The `getHeaderId()` method returns the value of the `headerId` property, the `getDigest()` method returns the value of the `digest` property, and the `getFields()` method returns the list of `KeyValueItem` objects in the `fields` property. The `setHeaderId()`, `setDigest()`, and `setFields()` methods are used to set the values of the `headerId`, `digest`, and `fields` properties, respectively. The `addFieldsItem()` method is used to add a `KeyValueItem` object to the `fields` list.\n\nThe `Extension` class also provides methods to override the `equals()`, `hashCode()`, and `toString()` methods. The `equals()` method compares two `Extension` objects for equality based on their `headerId`, `digest`, and `fields` properties. The `hashCode()` method returns a hash code for an `Extension` object based on its `headerId`, `digest`, and `fields` properties. The `toString()` method returns a string representation of an `Extension` object.\n\nIn the larger Ergo Node API project, the `Extension` class is used to represent extensions in the Ergo blockchain. It can be used to create, read, update, and delete extensions in the blockchain. For example, to create a new extension, a new `Extension` object can be created and its properties can be set using the `setHeaderId()`, `setDigest()`, and `addFieldsItem()` methods. The `Extension` object can then be added to a transaction or block in the blockchain.\n## Questions: \n 1. What is the purpose of this code?\n- This code is part of the Ergo Node API and defines a Java class called Extension that contains a headerId, digest, and a list of key-value records.\n\n2. What is the expected input and output of this code?\n- The input is a set of values for the headerId, digest, and fields of an Extension object. The output is an Extension object with those values.\n\n3. What is the significance of the @SerializedName and @Schema annotations?\n- The @SerializedName annotation is used to specify the name of the JSON property that corresponds to a Java field. The @Schema annotation is used to define metadata about a field, such as whether it is required and its description.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Extension.md"}}],["170",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/FeeHistogram.java)\n\nThis code defines a Java class called `FeeHistogram` that extends `java.util.ArrayList<FeeHistogramBin>`. The purpose of this class is to represent a fee histogram for transactions in a mempool. A fee histogram is a graphical representation of the distribution of transaction fees in a mempool. It shows how many transactions are paying a certain fee rate, and how much total fee is being paid at that rate.\n\nThe `FeeHistogram` class has three methods: `equals()`, `hashCode()`, and `toString()`. The `equals()` method checks if two `FeeHistogram` objects are equal by comparing their `super` properties. The `hashCode()` method returns the hash code of the `super` property. The `toString()` method returns a string representation of the `FeeHistogram` object.\n\nThis class is generated by the Swagger Codegen program, which is a tool that generates client libraries, server stubs, and documentation from an OpenAPI specification. The `@Schema` annotation is used to provide a description of the class for the OpenAPI specification.\n\nIn the larger project, this class can be used to represent fee histograms for transactions in a mempool. For example, if the project has a feature that displays the distribution of transaction fees in a mempool, the `FeeHistogram` class can be used to store and manipulate the data. The `FeeHistogramBin` class, which is not shown in this code snippet, is likely used to represent a single bin in the histogram.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a class called `FeeHistogram` which extends `java.util.ArrayList<FeeHistogramBin>` and represents a fee histogram for transactions in mempool.\n\n2. What version of the OpenAPI spec is this code based on?\n- This code is based on version 4.0.12 of the OpenAPI spec.\n\n3. Why does the `FeeHistogram` class override the `equals` and `hashCode` methods?\n- The `FeeHistogram` class overrides the `equals` and `hashCode` methods to ensure that two instances of the class are considered equal if they contain the same elements in the same order.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/FeeHistogram.md"}}],["171",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/FeeHistogramBin.java)\n\nThe `FeeHistogramBin` class is a model class that represents a fee histogram bin. It is used in the Ergo Node API to represent a bin in a histogram of transaction fees. The class has two properties: `nTxns` and `totalFee`. `nTxns` is an integer that represents the number of transactions in the bin, while `totalFee` is a long that represents the total fee of the transactions in the bin.\n\nThis class is generated automatically by the Swagger Codegen program and should not be edited manually. It is used by other classes in the Ergo Node API to represent fee histogram bins. For example, the `FeeHistogram` class contains an array of `FeeHistogramBin` objects.\n\nHere is an example of how the `FeeHistogramBin` class might be used in the Ergo Node API:\n\n```java\nFeeHistogramBin bin = new FeeHistogramBin();\nbin.setNTxns(10);\nbin.setTotalFee(1000000L);\n```\n\nIn this example, a new `FeeHistogramBin` object is created and its `nTxns` property is set to 10 and its `totalFee` property is set to 1000000.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `FeeHistogramBin` which represents a fee histogram bin.\n\n2. What external libraries or dependencies does this code use?\n- This code uses the `com.google.gson` and `io.swagger.v3.oas.annotations` libraries.\n\n3. Can this code be modified manually?\n- No, this code should not be edited manually as it is auto-generated by the Swagger code generator program.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/FeeHistogramBin.md"}}],["172",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/FullBlock.java)\n\nThe `FullBlock` class is part of the Ergo Node API and represents a block in the Ergo blockchain. It contains the header, transactions, and additional data (AD proofs and extension). The purpose of this class is to provide a standardized way to represent a block in the Ergo blockchain and to allow for easy serialization and deserialization of block data.\n\nThe `FullBlock` class has several methods that allow for setting and getting the different components of a block. The `header` method sets or gets the block header, which contains metadata about the block such as the block height, timestamp, and difficulty. The `blockTransactions` method sets or gets the block transactions, which are the transactions included in the block. The `adProofs` method sets or gets the additional data (AD) proofs, which are used to verify the correctness of the block. The `extension` method sets or gets the extension data, which can be used to store additional information about the block.\n\nThe `size` method gets the size of the block in bytes. This can be useful for optimizing block storage and transmission.\n\nOverall, the `FullBlock` class is an important part of the Ergo Node API and is used extensively throughout the Ergo ecosystem. It provides a standardized way to represent a block and allows for easy serialization and deserialization of block data. Below is an example of how the `FullBlock` class can be used to create a new block:\n\n```\nBlockHeader header = new BlockHeader();\nBlockTransactions transactions = new BlockTransactions();\nBlockADProofs adProofs = new BlockADProofs();\nExtension extension = new Extension();\nFullBlock block = new FullBlock()\n    .header(header)\n    .blockTransactions(transactions)\n    .adProofs(adProofs)\n    .extension(extension)\n    .size(1024);\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `FullBlock` which represents a block with header and transactions in the Ergo Node API.\n\n2. What are the properties of the `FullBlock` class?\n- The `FullBlock` class has properties such as `header`, `blockTransactions`, `adProofs`, `extension`, and `size`, which are all related to the block data.\n\n3. What is the purpose of the `toIndentedString` method?\n- The `toIndentedString` method is a private helper method that converts an object to a string with each line indented by 4 spaces, except for the first line. It is used in the `toString` method to format the output of the `FullBlock` class.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/FullBlock.md"}}],["173",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/GenerateCommitmentsRequest.java)\n\nThe `GenerateCommitmentsRequest` class is part of the Ergo Node API and is used to generate commitments to sign a transaction. This class is auto-generated by the Swagger code generator program and should not be edited manually. \n\nThe class has four fields: `tx`, `secrets`, `inputsRaw`, and `dataInputsRaw`. The `tx` field is an instance of the `UnsignedErgoTransaction` class and is required. The `secrets` field is an instance of the `GenerateCommitmentsRequestSecrets` class and is optional. The `inputsRaw` and `dataInputsRaw` fields are both lists of strings and are also optional. \n\nThe `tx` field represents the unsigned transaction for which commitments are being generated. The `secrets` field represents the secrets used to generate the commitments. The `inputsRaw` and `dataInputsRaw` fields are optional and represent the inputs and data inputs to be used in serialized form. \n\nThe `GenerateCommitmentsRequest` class has several methods that allow for setting and getting the values of its fields. The `tx()` method sets the value of the `tx` field and returns the instance of the class. The `secrets()` method sets the value of the `secrets` field and returns the instance of the class. The `inputsRaw()` method sets the value of the `inputsRaw` field and returns the instance of the class. The `addInputsRawItem()` method adds an item to the `inputsRaw` list and returns the instance of the class. The `dataInputsRaw()` method sets the value of the `dataInputsRaw` field and returns the instance of the class. The `addDataInputsRawItem()` method adds an item to the `dataInputsRaw` list and returns the instance of the class. \n\nThis class is used in the larger Ergo Node API project to generate commitments to sign a transaction. It can be used by developers who are building applications on top of the Ergo platform to ensure that transactions are signed correctly. \n\nExample usage:\n\n```\nUnsignedErgoTransaction tx = new UnsignedErgoTransaction();\nGenerateCommitmentsRequestSecrets secrets = new GenerateCommitmentsRequestSecrets();\nList<String> inputsRaw = new ArrayList<String>();\nList<String> dataInputsRaw = new ArrayList<String>();\n\nGenerateCommitmentsRequest request = new GenerateCommitmentsRequest()\n    .tx(tx)\n    .secrets(secrets)\n    .inputsRaw(inputsRaw)\n    .dataInputsRaw(dataInputsRaw);\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a request object for generating commitments to sign a transaction in the Ergo Node API.\n\n2. What are the required parameters for this request object?\n- The only required parameter is an UnsignedErgoTransaction object, which is set using the `tx` method.\n\n3. What are the optional parameters for this request object?\n- The optional parameters are `inputsRaw` and `dataInputsRaw`, which are lists of inputs to be used in serialized form, and `secrets`, which is an object of type GenerateCommitmentsRequestSecrets.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/GenerateCommitmentsRequest.md"}}],["174",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/GenerateCommitmentsRequestSecrets.java)\n\nThis code defines a Java class called `GenerateCommitmentsRequestSecrets` that represents external secrets used for signing. It is part of the Ergo Node API and is generated automatically by the Swagger code generator program. \n\nThe class has two instance variables: `dlog` and `dht`, both of which are lists. `dlog` is a sequence of secret exponents (DLOG secrets) and `dht` is a sequence of secret Diffie-Hellman tuple exponents (DHT secrets). The class provides methods to get and set these variables, as well as add items to the lists. \n\nThe purpose of this class is to provide a way to pass external secrets to the `GenerateCommitmentsRequest` class, which is used to generate commitments for a given transaction. These secrets are used for signing the transaction and are necessary for certain types of transactions. \n\nHere is an example of how this class might be used in the larger project:\n\n```\nGenerateCommitmentsRequestSecrets secrets = new GenerateCommitmentsRequestSecrets();\nsecrets.addDlogItem(\"secret1\");\nsecrets.addDlogItem(\"secret2\");\nDhtSecret dhtSecret = new DhtSecret();\ndhtSecret.setTuple(\"tuple1\");\ndhtSecret.setSecret(\"secret3\");\nsecrets.addDhtItem(dhtSecret);\n\nGenerateCommitmentsRequest request = new GenerateCommitmentsRequest();\nrequest.setSecrets(secrets);\n// use request to generate commitments for a transaction\n```\n\nIn this example, we create a new `GenerateCommitmentsRequestSecrets` object and add two DLOG secrets and one DHT secret to it. We then create a new `GenerateCommitmentsRequest` object and set its `secrets` variable to the `GenerateCommitmentsRequestSecrets` object we just created. Finally, we use the `GenerateCommitmentsRequest` object to generate commitments for a transaction.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `GenerateCommitmentsRequestSecrets` that represents external secrets used for signing in the Ergo Node API.\n\n2. What are the properties of the `GenerateCommitmentsRequestSecrets` class?\n- The class has two properties: `dlog`, which is a list of secret exponents (DLOG secrets), and `dht`, which is a list of secret Diffie-Hellman tuple exponents (DHT secrets).\n\n3. Can the properties of `GenerateCommitmentsRequestSecrets` be modified?\n- Yes, the properties can be modified using the `setDlog` and `setDht` methods, or by adding items to the `dlog` and `dht` lists using the `addDlogItem` and `addDhtItem` methods, respectively.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/GenerateCommitmentsRequestSecrets.md"}}],["175",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/HintExtractionRequest.java)\n\nThe `HintExtractionRequest` class is part of the Ergo Node API and is used to request the extraction of prover hints from a transaction. The purpose of this class is to provide a container for the necessary information required to extract prover hints from a transaction. The class contains the following fields:\n\n- `tx`: an instance of the `ErgoTransaction` class that represents the transaction from which to extract the prover hints.\n- `real`: a list of `SigmaBoolean` objects that represent the real signers of the transaction.\n- `simulated`: a list of `SigmaBoolean` objects that represent the simulated signers of the transaction.\n- `inputsRaw`: an optional list of inputs to be used in serialized form.\n- `dataInputsRaw`: an optional list of data inputs to be used in serialized form.\n\nThe `HintExtractionRequest` class provides methods to set and get the values of these fields. For example, the `tx` field can be set using the `tx(ErgoTransaction tx)` method, and retrieved using the `getTx()` method.\n\nThis class is generated automatically by the Swagger code generator program and should not be edited manually. It is used in the larger Ergo Node API project to facilitate the extraction of prover hints from transactions. An example usage of this class might look like:\n\n```\nHintExtractionRequest request = new HintExtractionRequest();\nrequest.tx(tx);\nrequest.real(realSigners);\nrequest.simulated(simulatedSigners);\nrequest.inputsRaw(inputsRaw);\nrequest.dataInputsRaw(dataInputsRaw);\n```\n\nWhere `tx`, `realSigners`, `simulatedSigners`, `inputsRaw`, and `dataInputsRaw` are all variables representing the necessary information to extract prover hints from a transaction.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class for a request to extract prover hints from a transaction in the Ergo Node API.\n\n2. What are the required parameters for creating an instance of the HintExtractionRequest class?\n- The required parameter is an instance of the ErgoTransaction class, which represents the transaction to extract prover hints from. \n\n3. What are the optional parameters for creating an instance of the HintExtractionRequest class?\n- The optional parameters are lists of SigmaBoolean objects representing the real and simulated signers of the transaction, as well as lists of serialized inputs and data inputs.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/HintExtractionRequest.md"}}],["176",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InfoApi.java)\n\nThis code defines an interface called `InfoApi` that is used to make HTTP requests to a server running the Ergo blockchain node. Specifically, it provides a method called `getNodeInfo()` that sends a GET request to the `/info` endpoint of the server and returns a `Call` object that can be used to execute the request asynchronously.\n\nThe `NodeInfo` class is used to represent the response from the server, which contains information about the node such as its version, network name, and synchronization status. The `Call` object returned by `getNodeInfo()` can be used to retrieve this information by calling its `execute()` method, which will send the request and return a `Response` object containing the deserialized `NodeInfo` object.\n\nThis interface is likely used in the larger project to provide information about the Ergo blockchain node to other parts of the application. For example, it could be used to display the node's version and synchronization status in a user interface, or to make decisions about how to interact with the node based on its network name. Here is an example of how this interface might be used in Java code:\n\n```\n// create a Retrofit instance to handle HTTP requests\nRetrofit retrofit = new Retrofit.Builder()\n    .baseUrl(\"http://localhost:9052/\")\n    .addConverterFactory(GsonConverterFactory.create())\n    .build();\n\n// create an instance of the InfoApi interface\nInfoApi infoApi = retrofit.create(InfoApi.class);\n\n// send a request to the node and retrieve the response\nCall<NodeInfo> call = infoApi.getNodeInfo();\nResponse<NodeInfo> response = call.execute();\n\n// check if the request was successful and print the node's version\nif (response.isSuccessful()) {\n    NodeInfo nodeInfo = response.body();\n    System.out.println(\"Node version: \" + nodeInfo.getVersion());\n} else {\n    ApiError error = ApiError.fromResponseBody(response.errorBody());\n    System.err.println(\"Request failed: \" + error.getMessage());\n}\n```\n## Questions: \n 1. What is the purpose of this code?\n   - This code defines an interface for making API calls to retrieve information about a node in the Ergo blockchain platform.\n\n2. What external libraries or dependencies does this code use?\n   - This code uses the Retrofit2 library for making HTTP requests and the OkHttp3 library for handling request and response bodies.\n\n3. What specific information about the node can be retrieved using this API?\n   - This API allows developers to retrieve general information about the node, such as its version number, network name, and synchronization status.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InfoApi.md"}}],["177",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InlineResponse200.java)\n\nThis code defines a Java class called `InlineResponse200` which represents a response object for an API endpoint in the Ergo Node API. The purpose of this class is to provide a model for the response data that is returned by the API endpoint. \n\nThe `InlineResponse200` class has a single field called `mnemonic` which is a string representing a mnemonic seed phrase. The `mnemonic` field is annotated with the `@Schema` annotation which indicates that it is a required field and provides a description of what the field represents. \n\nThe class also includes methods for getting and setting the `mnemonic` field, as well as methods for comparing two `InlineResponse200` objects for equality and generating a string representation of an `InlineResponse200` object. \n\nThis class is generated automatically by the Swagger Codegen program based on the OpenAPI specification for the Ergo Node API. It should not be edited manually, as any changes made to the class would be overwritten the next time the code is generated. \n\nIn the larger project, this class would be used by the client code that interacts with the Ergo Node API. When a request is made to the API endpoint that returns an `InlineResponse200` object, the client code would receive the response data as a JSON string and use a JSON parser to deserialize the string into an `InlineResponse200` object. The client code could then access the `mnemonic` field of the `InlineResponse200` object to retrieve the mnemonic seed phrase. \n\nExample usage:\n\n```\n// Make a request to the API endpoint that returns an InlineResponse200 object\nString responseJson = makeApiRequest();\n\n// Deserialize the response JSON into an InlineResponse200 object\nGson gson = new Gson();\nInlineResponse200 response = gson.fromJson(responseJson, InlineResponse200.class);\n\n// Access the mnemonic field of the InlineResponse200 object\nString mnemonic = response.getMnemonic();\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `InlineResponse200` which represents a response object with a single property `mnemonic`.\n\n2. What is the expected input and output of this code?\n- There is no input expected for this code. The output is an instance of the `InlineResponse200` class with a `mnemonic` property.\n\n3. What is the significance of the `@Schema` annotation?\n- The `@Schema` annotation is used to provide metadata about the `mnemonic` property, such as its description and whether it is required. This metadata can be used by tools that generate documentation or client code based on the API definition.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InlineResponse200.md"}}],["178",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InlineResponse2001.java)\n\nThe code defines a Java class called `InlineResponse2001` which is used to represent a response from an API endpoint. The class has a single field called `matched` which is a boolean value indicating whether a passphrase matches a wallet or not. The class also has getter and setter methods for the `matched` field, as well as methods for equality checking, hashing, and string representation.\n\nThis class is likely used in the larger project as a response object for an API endpoint that checks whether a passphrase matches a wallet. The `InlineResponse2001` object is returned by the endpoint with the `matched` field set to `true` if the passphrase matches the wallet, and `false` otherwise. Other parts of the project can then use this response object to determine whether a passphrase is valid or not.\n\nHere is an example of how this class might be used in the larger project:\n\n```java\n// Make a request to the API endpoint to check if a passphrase matches a wallet\nInlineResponse2001 response = api.checkPassphrase(passphrase);\n\n// Check if the passphrase matched the wallet\nif (response.isMatched()) {\n    System.out.println(\"Passphrase is valid!\");\n} else {\n    System.out.println(\"Passphrase is invalid.\");\n}\n```\n\nOverall, this code is a simple representation of a response object for an API endpoint in the larger `ergo-appkit` project.\n## Questions: \n 1. What is the purpose of this code?\n- This code is a model class for an API response object called InlineResponse2001, which contains a boolean value indicating whether a passphrase matches a wallet.\n\n2. What is the significance of the @SerializedName and @Schema annotations?\n- The @SerializedName annotation is used to specify the name of the JSON property that corresponds to the Java field, while the @Schema annotation is used to provide additional information about the field for documentation purposes.\n\n3. Why is the toString() method overridden in this class?\n- The toString() method is overridden to provide a string representation of the object for debugging and logging purposes. It generates a string that includes the value of the matched field.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InlineResponse2001.md"}}],["179",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InlineResponse2002.java)\n\nThe code defines a Java class called `InlineResponse2002` which represents a response object for the Ergo Node API. The class has four fields: `isInitialized`, `isUnlocked`, `changeAddress`, and `walletHeight`. \n\nThe `isInitialized` field is a boolean value that indicates whether the wallet is initialized or not. The `isUnlocked` field is also a boolean value that indicates whether the wallet is unlocked or not. The `changeAddress` field is a string that represents the address to which change should be sent. If the wallet is not initialized or locked, this field is empty. The `walletHeight` field is an integer that represents the last scanned height for the wallet.\n\nThe class provides getter and setter methods for each field, as well as an `equals` method, a `hashCode` method, and a `toString` method. The `toString` method generates a string representation of the object, which includes the values of all four fields.\n\nThis class is likely used as a response object for API calls that retrieve information about the state of the wallet. For example, an API call to retrieve the wallet status might return an instance of this class with the `isInitialized` and `isUnlocked` fields set to `true` if the wallet is initialized and unlocked, respectively. The `changeAddress` field would contain the address to which change should be sent, and the `walletHeight` field would contain the last scanned height for the wallet. \n\nHere is an example of how this class might be used in an API call:\n\n```\nInlineResponse2002 response = api.getWalletStatus();\nSystem.out.println(\"Wallet initialized: \" + response.isIsInitialized());\nSystem.out.println(\"Wallet unlocked: \" + response.isIsUnlocked());\nSystem.out.println(\"Change address: \" + response.getChangeAddress());\nSystem.out.println(\"Wallet height: \" + response.getWalletHeight());\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `InlineResponse2002` which represents a response object for the Ergo Node API.\n\n2. What are the properties of the `InlineResponse2002` class?\n- The `InlineResponse2002` class has four properties: `isInitialized`, `isUnlocked`, `changeAddress`, and `walletHeight`.\n\n3. What is the expected format of the `changeAddress` property?\n- The `changeAddress` property is expected to be a string representing an Ergo wallet address. It is empty when the wallet is not initialized or locked, and can be set via the `/wallet/updateChangeAddress` method.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InlineResponse2002.md"}}],["180",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InlineResponse2003.java)\n\nThis code defines a Java class called `InlineResponse2003` which is used to represent a response from the Ergo Node API. The class has a single field called `address` which is a string representing an address. The class also has getter and setter methods for the `address` field, as well as methods for equality checking, hashing, and string representation.\n\nThis class is generated automatically by the Swagger Codegen program, which takes an OpenAPI specification as input and generates client code in various programming languages. In this case, the `InlineResponse2003` class is generated from the OpenAPI spec version 4.0.12 for the Ergo Node API.\n\nThis class is likely used in conjunction with other classes generated by the Swagger Codegen program to make HTTP requests to the Ergo Node API and receive responses. For example, a client application might use the `InlineResponse2003` class to parse a response from the API that contains an address, and then use that address to perform some other action.\n\nHere is an example of how the `InlineResponse2003` class might be used in a client application:\n\n```java\nApiClient client = new ApiClient();\nInlineResponse2003 response = client.getAddress();\nString address = response.getAddress();\n// use the address to perform some other action\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `InlineResponse2003` that represents a response object with a single property `address`.\n\n2. What is the source of this code?\n- This code is auto-generated by the Swagger code generator program from an OpenAPI spec version 4.0.12.\n\n3. What is the expected input and output of this code?\n- This code does not have any input or output, as it only defines a Java class. However, the `InlineResponse2003` class is likely to be used as a response object in an API that returns an address as a string.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InlineResponse2003.md"}}],["181",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InlineResponse2004.java)\n\nThis code defines a Java class called `InlineResponse2004` which is used to represent a response from the Ergo Node API. The class has two fields: `derivationPath` and `address`, both of which are strings. The `derivationPath` field represents the derivation path of a secret, while the `address` field represents an address. \n\nThe class also has getter and setter methods for both fields, as well as methods for equality checking, hashing, and string conversion. The class is annotated with Swagger annotations, which provide additional information about the class and its fields. \n\nThis class is likely used in the larger Ergo Node API project to represent responses from API endpoints that return data related to secrets and addresses. For example, an API endpoint that generates a new secret and address might return an instance of this class with the `derivationPath` and `address` fields set to the appropriate values. \n\nDevelopers using the Ergo Node API can use this class to parse and work with responses from the API. For example, they might use the `getAddress()` method to retrieve the address from an instance of this class, or they might use the `toString()` method to convert an instance of this class to a string for logging or debugging purposes. \n\nOverall, this class is a simple but important part of the Ergo Node API project, providing a standardized way to represent responses related to secrets and addresses.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `InlineResponse2004` which has two properties: `derivationPath` and `address`.\n\n2. What is the expected input and output of this code?\n- The expected input is a string value for `derivationPath` and `address`. The output is an instance of the `InlineResponse2004` class.\n\n3. What is the significance of the `@Schema` annotation in this code?\n- The `@Schema` annotation is used to provide additional information about the properties of the `InlineResponse2004` class, such as their descriptions and whether they are required or not.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InlineResponse2004.md"}}],["182",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InlineResponse2005.java)\n\nThis code defines a Java class called `InlineResponse2005` which is used to represent a response from the Ergo Node API. Specifically, this response contains a single field called `rewardAddress` which is a string representing the address to which mining rewards are paid out. \n\nThe class includes a constructor, a getter and setter method for the `rewardAddress` field, and several methods for comparing and converting the object to a string. The `equals` method compares two `InlineResponse2005` objects for equality based on their `rewardAddress` fields, while the `hashCode` method generates a hash code for the object based on its `rewardAddress` field. The `toString` method generates a string representation of the object, including its `rewardAddress` field.\n\nThis class is likely used in conjunction with other classes and methods in the Ergo Node API to retrieve information about the Ergo blockchain. For example, a client application might make a request to the API to retrieve the reward address for a particular block or transaction, and receive an `InlineResponse2005` object as the response. The client application could then use the `getRewardAddress` method to extract the reward address from the response and use it for further processing. \n\nHere is an example of how this class might be used in a client application:\n\n```\nApiClient apiClient = new ApiClient();\nInlineResponse2005 response = apiClient.getBlockRewardAddress(blockId);\nString rewardAddress = response.getRewardAddress();\nSystem.out.println(\"The reward address for block \" + blockId + \" is \" + rewardAddress);\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `InlineResponse2005` which has a single property called `rewardAddress`.\n\n2. What is the expected input and output of this code?\n- There is no input expected for this code. The output is a Java class with a getter and setter method for the `rewardAddress` property.\n\n3. What is the significance of the annotations used in this code?\n- The `@SerializedName` annotation is used to specify the name of the JSON property that corresponds to the `rewardAddress` field when serialized and deserialized. The `@Schema` annotation is used to provide additional information about the `rewardAddress` field for documentation purposes. The `@JsonAdapter` annotation is used to specify a custom TypeAdapter for the class.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InlineResponse2005.md"}}],["183",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InlineResponse2006.java)\n\nThis code defines a Java class called `InlineResponse2006` which is used to represent a response from an API endpoint in the Ergo Node API. Specifically, this response contains a single field called `rewardAddress` which is a string representing a reward address. The purpose of this class is to provide a standardized way of representing this response in Java code.\n\nThe class contains a single constructor which takes no arguments, and a number of methods for getting and setting the `rewardAddress` field. The `getRewardAddress()` method returns the value of the `rewardAddress` field, while the `setRewardAddress(String rewardAddress)` method sets the value of the `rewardAddress` field to the given string.\n\nThe class also contains a number of methods for comparing instances of the class and generating string representations of instances of the class. These methods are used to ensure that instances of the class can be compared and printed in a standardized way.\n\nThis class is likely used in the larger Ergo Node API project to represent responses from API endpoints that return reward addresses. For example, a method in another class might make a request to an API endpoint and receive an instance of this class as a response. The method could then use the `getRewardAddress()` method to extract the reward address from the response and use it in further processing. \n\nExample usage:\n\n```\nInlineResponse2006 response = new InlineResponse2006();\nresponse.setRewardAddress(\"02a7955281885bf0f0ca4a48678848cad8dc5b328ce8bc1d4481d041c98e891ff3\");\nString rewardAddress = response.getRewardAddress();\nSystem.out.println(rewardAddress); // prints \"02a7955281885bf0f0ca4a48678848cad8dc5b328ce8bc1d4481d041c98e891ff3\"\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code is a model class for the Ergo Node API, specifically for the InlineResponse2006 object.\n\n2. What is the significance of the rewardAddress field?\n- The rewardAddress field is a String type that represents the reward address associated with the InlineResponse2006 object.\n\n3. Can the rewardAddress field be null?\n- Yes, the rewardAddress field can be null since it is not annotated with @NotNull or any other similar annotation.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InlineResponse2006.md"}}],["184",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InlineResponse2007.java)\n\nThe code defines a Java class called `InlineResponse2007` which is used to represent a response from the Ergo Node API. Specifically, this response contains a serialized Ergo tree. The class has a single field called `tree` which is a String representing the serialized Ergo tree. The `tree` field has a getter and a setter method to access and modify its value respectively. \n\nThe class also has methods to override the `equals`, `hashCode`, and `toString` methods inherited from the `Object` class. These methods are used to compare two instances of the `InlineResponse2007` class for equality, generate a hash code for an instance of the class, and generate a string representation of an instance of the class respectively. \n\nThe `InlineResponse2007` class is annotated with `@Schema` which is used to provide additional information about the class to the OpenAPI specification. Specifically, the `@Schema` annotation is used to provide an example value for the `tree` field and a description of what the field represents. \n\nThis class is generated automatically by the Swagger Codegen program and should not be edited manually. It is used by other classes in the Ergo Node API to represent responses that contain a serialized Ergo tree. \n\nExample usage:\n\n```java\nInlineResponse2007 response = new InlineResponse2007();\nresponse.setTree(\"02a7955281885bf0f0ca4a48678848cad8dc5b328ce8bc1d4481d041c98e891ff3\");\nString tree = response.getTree(); // returns \"02a7955281885bf0f0ca4a48678848cad8dc5b328ce8bc1d4481d041c98e891ff3\"\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `InlineResponse2007` which represents a response object with a single field `tree` that contains a serialized Ergo tree.\n\n2. What is the source of this code?\n- This code is auto-generated by the Swagger code generator program from an OpenAPI spec version 4.0.12.\n\n3. What is the expected input and output of this code?\n- This code does not have any input or output, but it defines a Java class that can be used to represent a response object with a single field `tree` that contains a serialized Ergo tree.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InlineResponse2007.md"}}],["185",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InlineResponse2008.java)\n\nThe code defines a Java class called `InlineResponse2008` which is used to represent a response from the Ergo Node API. Specifically, this response contains a single field called `bytes` which is a string representing base16-encoded bytes. The purpose of this class is to provide a standardized way of representing this type of response in Java code.\n\nThe class includes a constructor, a getter and a setter method for the `bytes` field, as well as methods for comparing two `InlineResponse2008` objects for equality and generating a hash code. Additionally, there is a `toString()` method which returns a string representation of the object.\n\nThis class is generated automatically by the Swagger code generator program, which is a tool for generating client libraries, server stubs, and documentation from OpenAPI specifications. In this case, the OpenAPI specification version is 4.0.12 and the contact email is `ergoplatform@protonmail.com`.\n\nIn the larger project, this class would be used by other Java code that interacts with the Ergo Node API. For example, if a Java application needs to retrieve data from the Ergo Node API, it might make an HTTP request to the API and receive a response in the form of an `InlineResponse2008` object. The application could then use the `getBytes()` method to extract the base16-encoded bytes from the response and process them as needed.\n\nExample usage:\n\n```\n// Make an HTTP request to the Ergo Node API\nHttpResponse<InlineResponse2008> response = Unirest.get(\"https://example.com/api/data\")\n    .asObject(InlineResponse2008.class);\n\n// Extract the bytes from the response\nString bytes = response.getBody().getBytes();\n\n// Process the bytes as needed\nbyte[] data = DatatypeConverter.parseHexBinary(bytes);\n```\n## Questions: \n 1. What is the purpose of this class?\n- This class is an auto-generated model class for the Ergo Node API.\n\n2. What is the `bytes` field used for?\n- The `bytes` field is a Base16-encoded string representing bytes.\n\n3. What is the purpose of the `equals`, `hashCode`, and `toString` methods?\n- These methods are used for object comparison, hashing, and string representation, respectively.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InlineResponse2008.md"}}],["186",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InputHints.java)\n\nThe code defines a Java class called `InputHints` which extends the `java.util.HashMap` class. This class is used to represent hints for inputs in the Ergo Node API. The `InputHints` class has a single field, which is a map of input indices to a list of hints for each input. \n\nThe purpose of this class is to provide additional information about inputs to the Ergo Node API. This information can be used to help the API make better decisions about how to handle inputs. For example, the hints could indicate whether an input is a coinbase input or a regular input, or whether it is a change output. \n\nThe `InputHints` class is annotated with the `@Schema` annotation, which provides a description of the class. The `equals`, `hashCode`, and `toString` methods are overridden to provide custom implementations for these methods. \n\nThis class is generated automatically by the Swagger code generator program, and should not be edited manually. \n\nHere is an example of how this class might be used in the larger Ergo Node API project:\n\n```java\nInputHints hints = new InputHints();\nhints.put(\"0\", Arrays.asList(\"coinbase\"));\nhints.put(\"1\", Arrays.asList(\"change\"));\n```\n\nIn this example, we create a new `InputHints` object and add two hints to it. The first hint indicates that the input at index 0 is a coinbase input, and the second hint indicates that the input at index 1 is a change output. These hints can then be passed to the Ergo Node API to provide additional information about the inputs.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a class called `InputHints` which extends `java.util.HashMap` and provides hints for inputs.\n\n2. What version of the OpenAPI spec is this code based on?\n- This code is based on version 4.0.12 of the OpenAPI spec.\n\n3. Why is there a `toString()` method and a `toIndentedString()` method in this class?\n- The `toString()` method returns a string representation of the object, while the `toIndentedString()` method formats the string with each line indented by 4 spaces for readability.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/InputHints.md"}}],["187",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/JSON.java)\n\nThe `JSON` class is responsible for creating and configuring a `Gson` object, which is a Java library used for serializing and deserializing Java objects to and from JSON. This class provides several `TypeAdapter` classes that are used to customize the serialization and deserialization of specific types, such as `java.util.Date`, `java.sql.Date`, `java.time.LocalDate`, and `java.time.OffsetDateTime`. \n\nThe `createGson()` method returns a `GsonBuilder` object that is used to create the `Gson` object. This method also registers several `TypeSelector` classes that are used to determine the appropriate class to deserialize JSON into based on a discriminator field. However, these `TypeSelector` classes are currently commented out and not being used.\n\nThe `JSON` constructor initializes the `Gson` object with the `TypeAdapter` classes for the supported types. The `setGson()` method can be used to set a custom `Gson` object if needed.\n\nThe `OffsetDateTimeTypeAdapter`, `LocalDateTypeAdapter`, `SqlDateTypeAdapter`, and `DateTypeAdapter` classes are `TypeAdapter` classes that are used to customize the serialization and deserialization of specific types. For example, the `OffsetDateTimeTypeAdapter` class is used to serialize and deserialize `java.time.OffsetDateTime` objects to and from JSON using a specified `DateTimeFormatter`. The `setOffsetDateTimeFormat()` and `setLocalDateFormat()` methods can be used to set custom `DateTimeFormatter` objects for `OffsetDateTime` and `LocalDate` types, respectively. The `setDateFormat()` and `setSqlDateFormat()` methods can be used to set custom `DateFormat` objects for `java.util.Date` and `java.sql.Date` types, respectively.\n\nOverall, this class provides a convenient way to create and configure a `Gson` object with custom serialization and deserialization behavior for specific types. It can be used in the larger project to handle JSON serialization and deserialization of objects used in the Ergo Node API. \n\nExample usage:\n\n```\nJSON json = new JSON();\nGson gson = json.getGson();\n\n// Serialize an object to JSON\nMyObject obj = new MyObject();\nString jsonStr = gson.toJson(obj);\n\n// Deserialize a JSON string to an object\nMyObject obj2 = gson.fromJson(jsonStr, MyObject.class);\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code is a Gson TypeAdapter for various date types used in the Ergo Node API.\n\n2. What external libraries or dependencies does this code use?\n- This code uses the Gson and GsonFire libraries.\n\n3. What is the significance of the commented out code in the `createGson()` method?\n- The commented out code registers type selectors for various classes, which would allow Gson to deserialize JSON into the correct class based on a discriminator field. However, these type selectors are currently not being used.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/JSON.md"}}],["188",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/KeyValueItem.java)\n\nThe code defines a class called `KeyValueItem` which extends the `java.util.ArrayList` class. This class is used to represent a list of key-value pairs. The purpose of this class is to provide a convenient way to store and manipulate key-value pairs in the Ergo Node API.\n\nThe `KeyValueItem` class provides methods for adding, removing, and retrieving key-value pairs. It also overrides the `equals`, `hashCode`, and `toString` methods of the `java.util.ArrayList` class to provide custom behavior for this class.\n\nThis class is used throughout the Ergo Node API to represent various types of data. For example, it may be used to represent the parameters of a request, or the properties of an object returned by the API.\n\nHere is an example of how this class might be used in the Ergo Node API:\n\n```\nKeyValueItem params = new KeyValueItem();\nparams.add(\"key1=value1\");\nparams.add(\"key2=value2\");\nparams.add(\"key3=value3\");\n\n// Send a request to the API with the parameters\nApiResponse response = api.someMethod(params);\n```\n\nIn this example, a new `KeyValueItem` object is created and populated with three key-value pairs. This object is then passed as a parameter to the `someMethod` method of the `api` object, which sends a request to the Ergo Node API with the specified parameters. The response from the API is stored in the `response` variable.\n## Questions: \n 1. What is the purpose of the `KeyValueItem` class?\n- The `KeyValueItem` class is a subclass of `java.util.ArrayList` and represents a list of key-value pairs.\n\n2. What version of the OpenAPI spec is this code based on?\n- This code is based on version 4.0.12 of the OpenAPI spec.\n\n3. Why is the `toString()` method overridden in this class?\n- The `toString()` method is overridden to provide a custom string representation of the `KeyValueItem` object.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/KeyValueItem.md"}}],["189",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/MerkleProof.java)\n\nThe `MerkleProof` class is part of the Ergo Node API and is used to represent a Merkle proof for a leaf, which is an array of bytes (e.g. a transaction identifier). This class is auto-generated by the Swagger code generator program and should not be edited manually.\n\nThe `MerkleProof` class has two properties: `leaf` and `levels`. The `leaf` property is a base16-encoded Merkle tree leaf bytes. The `levels` property is a list of lists that represents the Merkle proof levels. Each level is a list of nodes that are hashed together to produce the parent node of the next level. The last level contains only the root node.\n\nThis class provides methods to set and get the `leaf` and `levels` properties. The `leaf` property can be set using the `leaf` method, and the `levels` property can be set using the `levels` method. The `addLevelsItem` method can be used to add a new level to the `levels` property.\n\nThis class also provides methods to check for equality and calculate the hash code of an object. The `toString` method returns a string representation of the `MerkleProof` object.\n\nThis class can be used in the larger project to represent Merkle proofs for leaves in the Ergo blockchain. For example, it can be used to verify that a transaction is included in a block by checking its Merkle proof against the Merkle tree root of the block. Here is an example of how this class can be used:\n\n```\nMerkleProof proof = new MerkleProof();\nproof.leaf(\"cd665e49c834b0c25574fcb19a158d836f3f2aad8e91ac195f972534c25449b3\");\nproof.addLevelsItem(Arrays.asList(\"018b7ae20a4acd23e3f1bf38671ce97103ad96d8f1c780b5e5e865e4873ae16337\", 0));\n```\n\nThis creates a new `MerkleProof` object with a leaf of `cd665e49c834b0c25574fcb19a158d836f3f2aad8e91ac195f972534c25449b3` and a single level with a node of `018b7ae20a4acd23e3f1bf38671ce97103ad96d8f1c780b5e5e865e4873ae16337` and an index of `0`.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `MerkleProof` which represents a Merkle proof for a leaf, and contains a base16-encoded Merkle tree leaf bytes and a list of levels.\n\n2. What dependencies does this code have?\n- This code depends on the `com.google.gson` and `io.swagger.v3.oas.annotations` libraries.\n\n3. Can this code be modified manually?\n- No, this code should not be modified manually as it is auto-generated by the Swagger code generator program.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/MerkleProof.md"}}],["190",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/MiningApi.java)\n\nThe `MiningApi` interface is part of the `ergo-appkit` project and provides methods for interacting with a mining node on the Ergo blockchain. The purpose of this code is to define an API for requesting and submitting mining-related information to the node.\n\nThe interface contains five methods, each with a specific purpose. The first two methods, `miningReadMinerRewardAddress` and `miningReadMinerRewardPubkey`, are used to read the miner's reward address and public key, respectively. These methods return `Call` objects that can be executed asynchronously using Retrofit2.\n\nThe third method, `miningRequestBlockCandidate`, is used to request a block candidate from the mining node. This method returns a `Call` object that can be executed asynchronously to retrieve a `WorkMessage` object containing the block candidate.\n\nThe fourth method, `miningRequestBlockCandidateWithMandatoryTransactions`, is similar to the third method, but it also includes a list of mandatory transactions that must be included in the block. This method takes a list of `ErgoTransaction` objects as a parameter and returns a `WorkMessage` object.\n\nThe fifth and final method, `miningSubmitSolution`, is used to submit a solution for the current block candidate. This method takes a `PowSolutions` object as a parameter and returns a `Void` object.\n\nOverall, this interface provides a convenient way for developers to interact with a mining node on the Ergo blockchain. For example, a developer could use these methods to request a block candidate, add transactions to the block, and submit a solution for the block. Here is an example of how to use the `miningReadMinerRewardAddress` method:\n\n```\nMiningApi miningApi = retrofit.create(MiningApi.class);\nCall<InlineResponse2005> call = miningApi.miningReadMinerRewardAddress();\ncall.enqueue(new Callback<InlineResponse2005>() {\n    @Override\n    public void onResponse(Call<InlineResponse2005> call, Response<InlineResponse2005> response) {\n        if (response.isSuccessful()) {\n            InlineResponse2005 rewardAddress = response.body();\n            System.out.println(\"Miner reward address: \" + rewardAddress.getAddress());\n        } else {\n            ApiError error = ApiErrorUtils.parseError(response);\n            System.out.println(\"Error: \" + error.getMessage());\n        }\n    }\n\n    @Override\n    public void onFailure(Call<InlineResponse2005> call, Throwable t) {\n        System.out.println(\"Error: \" + t.getMessage());\n    }\n});\n```\n## Questions: \n 1. What is the purpose of this code?\n   - This code defines an interface for interacting with a mining API, including methods for reading miner reward information, requesting block candidates, and submitting solutions.\n2. What external libraries or dependencies does this code use?\n   - This code imports several classes from the `org.ergoplatform.restapi.client` package, as well as classes from the `retrofit2` and `okhttp3` libraries.\n3. What HTTP methods are used in this code?\n   - This code uses GET and POST HTTP methods for making requests to the mining API.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/MiningApi.md"}}],["191",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/NipopowApi.java)\n\nThe `NipopowApi` interface is part of the `ergo-appkit` project and provides methods for constructing PoPow headers and proofs. The purpose of this code is to define an API for interacting with the Nipopow protocol, which is a proof-of-work consensus algorithm used by the Ergo blockchain. \n\nThe interface contains four methods, each of which corresponds to a different endpoint in the Nipopow API. The first two methods, `getPopowHeaderByHeight` and `getPopowHeaderById`, are used to construct PoPow headers. The `getPopowHeaderByHeight` method takes an integer parameter `height` and returns the PoPow header for the block at that height. The `getPopowHeaderById` method takes a string parameter `headerId` and returns the PoPow header for the block with that ID. \n\nThe other two methods, `getPopowProof` and `getPopowProofByHeaderId`, are used to construct PoPoW proofs. The `getPopowProof` method takes two BigDecimal parameters, `minChainLength` and `suffixLength`, and returns the PoPoW proof for the given parameters. The `getPopowProofByHeaderId` method takes three BigDecimal parameters, `minChainLength`, `suffixLength`, and `headerId`, and returns the PoPoW proof for the given parameters and header ID. \n\nAll four methods return a `Call` object, which is part of the Retrofit2 library used by this project. The `Call` object is used to make HTTP requests to the Nipopow API and receive responses. \n\nOverall, this code provides a convenient way for developers to interact with the Nipopow protocol and construct PoPow headers and proofs for the Ergo blockchain. Here is an example of how the `getPopowHeaderByHeight` method might be used:\n\n```\nNipopowApi nipopowApi = retrofit.create(NipopowApi.class);\nCall<PopowHeader> call = nipopowApi.getPopowHeaderByHeight(1000);\nResponse<PopowHeader> response = call.execute();\nPopowHeader header = response.body();\n```\n## Questions: \n 1. What is the purpose of this code?\n   - This code defines an interface for making API calls related to Nipopow (Non-Interactive Proof-of-Proof-of-Work) in the Ergo blockchain platform.\n\n2. What external libraries or dependencies does this code use?\n   - This code uses the Retrofit2 and OkHttp3 libraries for making HTTP requests and handling responses.\n\n3. What API endpoints are available through this interface?\n   - This interface provides four API endpoints: `getPopowHeaderByHeight`, `getPopowHeaderById`, `getPopowProof`, and `getPopowProofByHeaderId`. These endpoints allow the user to construct PoPow headers and proofs for the Ergo blockchain.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/NipopowApi.md"}}],["192",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/NipopowProof.java)\n\nThe `NipopowProof` class is part of the Ergo Node API and is used to represent a Non-Interactive Proof of Proof-of-Work (Nipopow) proof. The NipopowProof class contains five fields: `m`, `k`, `prefix`, `suffixHead`, and `suffixTail`. \n\nThe `m` field is a BigDecimal that represents the security parameter, which is the minimum -level superchain length. The `k` field is also a BigDecimal that represents the security parameter, which is the minimum suffix length (k >= 1). The `prefix` field is a list of `PopowHeader` objects that represent the proof prefix headers. The `suffixHead` field is a `PopowHeader` object that represents the suffix head. The `suffixTail` field is a list of `BlockHeader` objects that represent the tail of the proof suffix headers.\n\nThe purpose of this class is to provide a standardized way to represent Nipopow proofs in the Ergo Node API. This class can be used to serialize and deserialize Nipopow proofs to and from JSON. For example, the following code can be used to serialize a `NipopowProof` object to JSON:\n\n```\nNipopowProof proof = new NipopowProof();\n// set fields\nGson gson = new Gson();\nString json = gson.toJson(proof);\n```\n\nThe resulting JSON string can then be sent to the Ergo Node API. Similarly, the following code can be used to deserialize a JSON string to a `NipopowProof` object:\n\n```\nString json = \"{\\\"m\\\":1,\\\"k\\\":1,\\\"prefix\\\":[],\\\"suffixHead\\\":{},\\\"suffixTail\\\":[]}\";\nGson gson = new Gson();\nNipopowProof proof = gson.fromJson(json, NipopowProof.class);\n```\n\nOverall, the `NipopowProof` class is an important part of the Ergo Node API and provides a standardized way to represent Nipopow proofs.\n## Questions: \n 1. What is the purpose of this code and what does it do?\n- This code is a model for NipopowProof in the Ergo Node API. It contains fields for security parameters and proof headers.\n\n2. What are the required parameters for creating an instance of NipopowProof?\n- The required parameters are m (min -level superchain length), k (min suffix length), prefix (proof prefix headers), suffixHead (header of the proof suffix), and suffixTail (tail of the proof suffix headers).\n\n3. Can the fields in an instance of NipopowProof be modified after creation?\n- Yes, the fields can be modified using the setter methods provided in the class.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/NipopowProof.md"}}],["193",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/NodeApi.java)\n\nThis code defines an interface called `NodeApi` that is used to make HTTP requests to a server running the Ergo blockchain node. The interface is annotated with Retrofit2 annotations that specify the HTTP method, endpoint, and expected response type for each method. \n\nThe `nodeShutdown()` method is the only method defined in this interface. It sends a POST request to the `/node/shutdown` endpoint to shut down the Ergo node. The method returns a `Call` object that can be used to execute the request asynchronously and receive a response. The response type is `Void`, indicating that no response body is expected.\n\nThis interface can be used by other classes in the Ergo Appkit project to interact with the Ergo node. For example, a class that manages the Ergo node's lifecycle could use the `nodeShutdown()` method to gracefully shut down the node when necessary. \n\nHere is an example of how this interface could be used in a Java class:\n\n```\nimport org.ergoplatform.restapi.client.NodeApi;\nimport retrofit2.Call;\nimport retrofit2.Callback;\nimport retrofit2.Response;\nimport retrofit2.Retrofit;\nimport retrofit2.converter.gson.GsonConverterFactory;\n\npublic class ErgoNodeManager {\n  private NodeApi nodeApi;\n\n  public ErgoNodeManager(String baseUrl) {\n    Retrofit retrofit = new Retrofit.Builder()\n        .baseUrl(baseUrl)\n        .addConverterFactory(GsonConverterFactory.create())\n        .build();\n\n    nodeApi = retrofit.create(NodeApi.class);\n  }\n\n  public void shutdownNode() {\n    Call<Void> call = nodeApi.nodeShutdown();\n    call.enqueue(new Callback<Void>() {\n      @Override\n      public void onResponse(Call<Void> call, Response<Void> response) {\n        // Handle successful response\n      }\n\n      @Override\n      public void onFailure(Call<Void> call, Throwable t) {\n        // Handle error\n      }\n    });\n  }\n}\n```\n\nIn this example, the `ErgoNodeManager` class uses the `NodeApi` interface to shut down the Ergo node. The `shutdownNode()` method creates a `Call` object using the `nodeShutdown()` method and enqueues it to be executed asynchronously. The `onResponse()` and `onFailure()` methods of the `Callback` object are used to handle the response or error from the server.\n## Questions: \n 1. What is the purpose of this code?\n   This code defines an interface for making a POST request to shut down a node in the Ergo blockchain platform using Retrofit2.\n\n2. What dependencies are required to use this code?\n   This code requires the Retrofit2 and OkHttp3 libraries to be imported.\n\n3. Are there any potential errors that could occur when using this code?\n   Yes, there is a possibility of receiving an ApiError response if the node shutdown request fails for any reason.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/NodeApi.md"}}],["194",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/NodeInfo.java)\n\nThe `NodeInfo` class in the `ergo-appkit` project represents the information about an Ergo node. This information includes details such as the node's name, app version, network type, current state, and various block-related data. The class is auto-generated by the Swagger code generator from the Ergo Node API specification.\n\nThe `NodeInfo` class contains several fields, such as `name`, `appVersion`, `fullHeight`, `headersHeight`, `bestFullHeaderId`, `previousFullHeaderId`, `bestHeaderId`, `stateRoot`, `stateType`, `stateVersion`, `isMining`, `peersCount`, `unconfirmedCount`, `difficulty`, `currentTime`, `launchTime`, `headersScore`, `fullBlocksScore`, `genesisBlockId`, `restApiUrl`, and `parameters`. These fields store various information about the node, such as its name, version, current height of the full and header chain, best header and full header IDs, state root, state type and version, mining status, number of connected peers, unconfirmed transaction count, difficulty, current and launch time, header and full block scores, genesis block ID, REST API URL, and node parameters.\n\nThe `StateTypeEnum` enum is used to represent the state type of the node, which can be either \"digest\" or \"utxo\". The `Adapter` class within `StateTypeEnum` is used to convert the state type between its string representation and the enum value.\n\nThe `NodeInfo` class provides getter and setter methods for each field, as well as `equals`, `hashCode`, and `toString` methods for object comparison and representation. This class can be used in the larger project to interact with the Ergo Node API and retrieve or update information about the node.\n## Questions: \n 1. **What is the purpose of the `NodeInfo` class?**\n\n   The `NodeInfo` class represents information about a node in the Ergo network. It contains various properties such as the node's name, app version, height, header information, state, mining status, and other related data.\n\n2. **What is the `StateTypeEnum` enum used for?**\n\n   The `StateTypeEnum` enum is used to represent the type of state the node is in. It has two possible values: `DIGEST` and `UTXO`, which represent the digest state and the unspent transaction output (UTXO) state, respectively.\n\n3. **How is the `network` property used in the `NodeInfo` class?**\n\n   The `network` property is used to store the type of network the node is connected to. It can have values like \"mainnet\", \"testnet\", or \"devnet\", representing the main network, test network, or development network, respectively.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/NodeInfo.md"}}],["195",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/OrPredicate.java)\n\nThe code defines a Java class called `OrPredicate` which extends another class called `ScanningPredicate`. The purpose of this class is to represent a logical OR operation between multiple scanning predicates. \n\nThe `OrPredicate` class has a single field called `args`, which is a list of `ScanningPredicate` objects. This list represents the scanning predicates that are being OR-ed together. The `args` field can be set using the `args` method, which takes a list of `ScanningPredicate` objects, or by calling the `addArgsItem` method, which adds a single `ScanningPredicate` object to the list.\n\nThe `OrPredicate` class also overrides several methods from the `Object` class, including `equals`, `hashCode`, and `toString`. These methods are used to compare `OrPredicate` objects, generate hash codes for `OrPredicate` objects, and generate string representations of `OrPredicate` objects, respectively.\n\nThis class is likely used in the larger project to represent complex scanning predicates that require logical operations like OR. For example, if a scanning operation needs to find all items that match either a certain condition or another condition, an `OrPredicate` object can be used to represent this logic. \n\nHere is an example of how an `OrPredicate` object might be used in the larger project:\n\n```\nScanningPredicate predicate1 = new ScanningPredicate();\nScanningPredicate predicate2 = new ScanningPredicate();\nOrPredicate orPredicate = new OrPredicate();\norPredicate.addArgsItem(predicate1);\norPredicate.addArgsItem(predicate2);\n```\n\nIn this example, two `ScanningPredicate` objects are created and added to an `OrPredicate` object using the `addArgsItem` method. This creates an `OrPredicate` object that represents the logical OR of the two `ScanningPredicate` objects.\n## Questions: \n 1. What is the purpose of this code?\n- This code is a model for an OrPredicate in the Ergo Node API, which is used to scan for certain conditions in the blockchain.\n\n2. What is the relationship between OrPredicate and ScanningPredicate?\n- OrPredicate extends ScanningPredicate, meaning that OrPredicate inherits all of the properties and methods of ScanningPredicate.\n\n3. What is the significance of the @Schema annotation?\n- The @Schema annotation is used to provide metadata about the OrPredicate class, specifically that the args field is required and to provide a description of the field. This metadata can be used by tools that generate documentation or client code based on the API.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/OrPredicate.md"}}],["196",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Parameters.java)\n\nThe `Parameters` class is part of the Ergo Node API and is used to define the parameters for the Ergo blockchain. These parameters are used to set the rules for the blockchain, such as the maximum block size, the validation cost per transaction input, and the storage fee coefficient. \n\nThe class contains several fields, each representing a different parameter. These fields include `height`, `storageFeeFactor`, `minValuePerByte`, `maxBlockSize`, `maxBlockCost`, `blockVersion`, `tokenAccessCost`, `inputCost`, `dataInputCost`, and `outputCost`. Each field has a corresponding getter and setter method, allowing the values to be retrieved and modified as needed.\n\nThe `Parameters` class is used throughout the Ergo Node API to define the parameters for various blockchain operations. For example, when creating a new transaction, the `inputCost`, `dataInputCost`, and `outputCost` parameters are used to calculate the transaction fee. Similarly, the `maxBlockSize` parameter is used to limit the size of each block in the blockchain.\n\nOverall, the `Parameters` class is an important part of the Ergo Node API, allowing developers to define the rules and parameters for the Ergo blockchain. By modifying these parameters, developers can customize the blockchain to meet their specific needs. \n\nExample usage:\n\n```java\nParameters params = new Parameters();\nparams.setMaxBlockSize(1048576);\nparams.setInputCost(100);\nparams.setOutputCost(100);\nparams.setDataInputCost(100);\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `Parameters` that contains various parameters used in the Ergo Node API.\n\n2. What are some of the parameters that are included in this class?\n- Some of the parameters included in this class are `height`, `storageFeeFactor`, `minValuePerByte`, `maxBlockSize`, `maxBlockCost`, `blockVersion`, `tokenAccessCost`, `inputCost`, `dataInputCost`, and `outputCost`.\n\n3. Can the values of these parameters be modified?\n- Yes, the values of these parameters can be modified using the setter methods provided in the class.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Parameters.md"}}],["197",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/PaymentRequest.java)\n\nThe `PaymentRequest` class is part of the Ergo Node API and is used to generate a payment transaction to a given address. This class contains fields for the address, payment amount, assets list, and registers. \n\nThe `address` field is a required string that specifies the address to which the payment transaction will be sent. The `value` field is a required long that specifies the payment amount. The `assets` field is an optional list of `Asset` objects that represent additional assets to be included in the transaction. The `registers` field is an optional `Registers` object that represents the registers to be included in the transaction.\n\nThis class provides methods to set and get the values of these fields. The `address` field can be set using the `address` method, the `value` field can be set using the `value` method, the `assets` field can be set using the `assets` method or by adding individual `Asset` objects using the `addAssetsItem` method, and the `registers` field can be set using the `registers` method.\n\nThe `PaymentRequest` class also overrides the `equals`, `hashCode`, and `toString` methods for object comparison and string representation.\n\nThis class is used in the larger Ergo Node API project to generate payment transactions to a given address. An example usage of this class would be to create a `PaymentRequest` object with the desired address, payment amount, and any additional assets or registers, and then pass this object to a method that generates the payment transaction.\n## Questions: \n 1. What is the purpose of this code?\n- This code is a Java class that represents a payment request for the Ergo Node API.\n\n2. What are the required parameters for a payment request?\n- The required parameter for a payment request is the address of the recipient, which is specified using the `address` field.\n\n3. What is the purpose of the `assets` and `registers` fields?\n- The `assets` field is used to specify a list of assets to be included in the transaction, while the `registers` field is used to specify additional data to be included in the transaction.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/PaymentRequest.md"}}],["198",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Peer.java)\n\nThe `Peer` class is part of the Ergo Node API and is used to model a peer in the Ergo network. The class contains fields for the peer's address, name, REST API URL, last message, last handshake, and connection type. The `ConnectionTypeEnum` enum is used to represent the type of connection, which can be either incoming or outgoing.\n\nThe `Peer` class provides getters and setters for each field, allowing other classes to access and modify the peer's properties. The `toString()` method is also overridden to provide a string representation of the peer object.\n\nThis class is generated automatically by the Swagger code generator program and should not be edited manually. It is used by other classes in the Ergo Node API to represent a peer in the network. For example, the `PeersApi` class uses the `Peer` class to return a list of peers in the network.\n\nExample usage:\n\n```java\n// create a new peer object\nPeer peer = new Peer();\n\n// set the peer's address\npeer.setAddress(\"127.0.0.1:5673\");\n\n// set the peer's name\npeer.setName(\"mynode\");\n\n// set the peer's REST API URL\npeer.setRestApiUrl(\"http://127.0.0.1:9052\");\n\n// set the peer's last message time\npeer.setLastMessage(123456789L);\n\n// set the peer's last handshake time\npeer.setLastHandshake(1234567890L);\n\n// set the peer's connection type\npeer.setConnectionType(ConnectionTypeEnum.INCOMING);\n\n// print the peer object\nSystem.out.println(peer.toString());\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `Peer` that represents a peer node in the Ergo blockchain network.\n\n2. What is the significance of the `ConnectionTypeEnum` enum?\n- The `ConnectionTypeEnum` enum defines the type of connection between two peer nodes, either incoming or outgoing.\n\n3. What is the purpose of the `toIndentedString` method?\n- The `toIndentedString` method is a helper method that converts an object to a string with each line indented by 4 spaces, except the first line. It is used in the `toString` method to format the output of the `Peer` class.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Peer.md"}}],["199",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/PeersApi.java)\n\nThe code provided is an interface for interacting with the Peers API of the Ergo Platform. The Peers API provides functionality for managing and monitoring the network peers of the Ergo blockchain. \n\nThe interface defines five methods for interacting with the Peers API. The first method, `connectToPeer`, allows a user to add an address to the list of known peers. The method takes a JSON string as input and returns a `Call` object that can be used to execute the request asynchronously. \n\nThe second method, `getAllPeers`, returns a list of all known peers. This method takes no input and returns a `Call` object that can be used to execute the request asynchronously. \n\nThe third method, `getBlacklistedPeers`, returns a list of blacklisted peers. This method takes no input and returns a `Call` object that can be used to execute the request asynchronously. \n\nThe fourth method, `getConnectedPeers`, returns a list of currently connected peers. This method takes no input and returns a `Call` object that can be used to execute the request asynchronously. \n\nThe fifth method, `getPeersStatus`, returns the last incoming message timestamp and the current network time. This method takes no input and returns a `Call` object that can be used to execute the request asynchronously. \n\nOverall, this interface provides a convenient way for developers to interact with the Peers API of the Ergo Platform. Developers can use these methods to manage and monitor the network peers of the Ergo blockchain. \n\nExample usage:\n\n```\n// create a Retrofit instance\nRetrofit retrofit = new Retrofit.Builder()\n    .baseUrl(\"https://ergoplatform.com/api/v1/\")\n    .build();\n\n// create an instance of the PeersApi interface\nPeersApi peersApi = retrofit.create(PeersApi.class);\n\n// get all known peers\nCall<List<Peer>> allPeersCall = peersApi.getAllPeers();\nResponse<List<Peer>> allPeersResponse = allPeersCall.execute();\nList<Peer> allPeers = allPeersResponse.body();\n\n// connect to a peer\nString peerAddress = \"127.0.0.1:9053\";\nString requestBody = \"{\\\"address\\\": \\\"\" + peerAddress + \"\\\"}\";\nCall<Void> connectToPeerCall = peersApi.connectToPeer(requestBody);\nResponse<Void> connectToPeerResponse = connectToPeerCall.execute();\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines an interface for making API calls related to managing peers in the Ergo blockchain network.\n\n2. What external libraries or dependencies does this code use?\n- This code uses the Retrofit2 library for making HTTP requests and the OkHttp3 library for handling request and response bodies.\n\n3. What API endpoints are available through this interface?\n- This interface provides methods for connecting to a peer, getting all known peers, getting blacklisted peers, getting connected peers, and getting the last incoming message timestamp and current network time.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/PeersApi.md"}}],["200",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/PeersStatus.java)\n\nThe `PeersStatus` class is a model class that represents the status of a peer in the Ergo network. It contains two fields: `lastIncomingMessage` and `currentNetworkTime`. \n\nThe `lastIncomingMessage` field is a `Long` that represents the timestamp of the last incoming message from the peer. The `currentNetworkTime` field is a required `Long` that represents the current network time of the peer.\n\nThis class is generated by the Swagger code generator program and should not be edited manually. It is used in the Ergo Node API to represent the status of a peer in the network. \n\nHere is an example of how this class might be used in the larger project:\n\n```java\nPeersStatus peerStatus = new PeersStatus();\npeerStatus.lastIncomingMessage(1625678900L);\npeerStatus.currentNetworkTime(1625678910L);\n```\n\nIn this example, a new `PeersStatus` object is created and the `lastIncomingMessage` and `currentNetworkTime` fields are set to specific values. This object can then be used to represent the status of a peer in the Ergo network.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `PeersStatus` that represents the status of peers in the Ergo Node API.\n\n2. What is the significance of the `@SerializedName` and `@Schema` annotations?\n- The `@SerializedName` annotation is used to specify the name of the JSON property that corresponds to a Java field. The `@Schema` annotation is used to provide additional information about a field, such as its description and whether it is required.\n\n3. Why is the `toIndentedString` method private?\n- The `toIndentedString` method is only used internally by the `toString` method to format the output string. It is not intended to be called directly by external code, so it is made private to prevent misuse.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/PeersStatus.md"}}],["201",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/PopowHeader.java)\n\nThe `PopowHeader` class is a model class that represents a header for a Proof of Proof of Work (PoPoW) block in the Ergo blockchain. It contains two fields: `header` and `interlinks`. The `header` field is an instance of the `BlockHeader` class, which represents the header of a block in the Ergo blockchain. The `interlinks` field is a list of strings that represents the interlinks of the PoPoW block.\n\nThe purpose of this class is to provide a standardized way of representing PoPoW headers in the Ergo blockchain. It can be used by other classes in the Ergo Appkit project that need to work with PoPoW headers. For example, it could be used by a class that verifies PoPoW proofs for Ergo blocks.\n\nHere is an example of how this class could be used:\n\n```\n// Create a new PoPoW header\nBlockHeader header = new BlockHeader();\nPopowHeader popowHeader = new PopowHeader();\npopowHeader.setHeader(header);\n\n// Add interlinks to the PoPoW header\nList<String> interlinks = new ArrayList<String>();\ninterlinks.add(\"interlink1\");\ninterlinks.add(\"interlink2\");\npopowHeader.setInterlinks(interlinks);\n\n// Print the PoPoW header\nSystem.out.println(popowHeader.toString());\n```\n\nThis would output the following:\n\n```\nclass PopowHeader {\n    header: BlockHeader@<hash>,\n    interlinks: [interlink1, interlink2]\n}\n```\n\nOverall, the `PopowHeader` class provides a simple and standardized way of representing PoPoW headers in the Ergo blockchain, which can be used by other classes in the Ergo Appkit project.\n## Questions: \n 1. What is the purpose of this code?\n- This code is a Java class for the PopowHeader model in the Ergo Node API, which includes a BlockHeader and an array of interlinks.\n\n2. What is the significance of the @Schema annotation?\n- The @Schema annotation is used to provide metadata about the PopowHeader class, including a description of the header and interlinks properties.\n\n3. What is the purpose of the equals() and hashCode() methods?\n- The equals() and hashCode() methods are used to compare two PopowHeader objects for equality based on their header and interlinks properties.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/PopowHeader.md"}}],["202",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/PowSolutions.java)\n\nThe `PowSolutions` class is a model class that represents an object containing all components of a proof-of-work (PoW) solution. It is part of the Ergo Node API and is used to share models between all Ergo products. The class is generated automatically by the Swagger code generator program and should not be edited manually.\n\nThe `PowSolutions` class has four properties: `pk`, `w`, `n`, and `d`. The `pk` property is a base16-encoded public key, while the `w` property is a string that represents a value used in the PoW solution. The `n` property is also a string that represents a value used in the PoW solution. Finally, the `d` property is a BigInteger that represents a value used in the PoW solution.\n\nThe `PowSolutions` class provides getter and setter methods for each property, allowing other classes to access and modify the values of these properties. The class also provides methods for equality checking, hashing, and string representation.\n\nThis class can be used in the larger project to represent PoW solutions in the Ergo Node API. For example, it can be used in conjunction with other classes to create and validate PoW solutions. Here is an example of how the `PowSolutions` class might be used in code:\n\n```java\nPowSolutions powSolutions = new PowSolutions();\npowSolutions.setPk(\"0350e25cee8562697d55275c96bb01b34228f9bd68fd9933f2a25ff195526864f5\");\npowSolutions.setW(\"0366ea253123dfdb8d6d9ca2cb9ea98629e8f34015b1e4ba942b1d88badfcc6a12\");\npowSolutions.setN(\"0000000000000000\");\npowSolutions.setD(new BigInteger(\"987654321\"));\n\n// Use the powSolutions object to create and validate PoW solutions\n```\n\nIn this example, a new `PowSolutions` object is created and its properties are set using the setter methods. The object can then be used to create and validate PoW solutions.\n## Questions: \n 1. What is the purpose of this code?\n- This code is a Java class that represents an object containing all components of pow solution for the Ergo Node API.\n\n2. What are the required fields for an instance of PowSolutions?\n- An instance of PowSolutions requires a base16-encoded public key (pk), a string (w), a string (n), and a BigInteger (d).\n\n3. Can an instance of PowSolutions be modified after it is created?\n- Yes, an instance of PowSolutions can be modified after it is created by calling the appropriate setter methods for each field.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/PowSolutions.md"}}],["203",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/PreHeader.java)\n\nThis code defines a Java class called `PreHeader` that represents a pre-header of a block in the Ergo blockchain. The pre-header contains metadata about the block, such as its timestamp, version, difficulty target, height, parent block ID, votes, and miner public key. \n\nThe class has getters and setters for each of these fields, as well as methods for chaining setters together. It also overrides the `equals`, `hashCode`, and `toString` methods for comparing instances of the class and generating string representations of them.\n\nThis class is likely used in the larger Ergo project to represent pre-headers of blocks in the blockchain. It may be used by other classes or modules that need to manipulate or analyze block metadata. For example, it could be used by a mining module to construct new blocks, or by a validation module to verify the correctness of existing blocks. \n\nHere is an example of how this class could be used to create a new block pre-header:\n\n```\nPreHeader preHeader = new PreHeader()\n    .timestamp(1631234567)\n    .version(1)\n    .nBits(19857408L)\n    .height(667)\n    .parentId(\"0000000000000000000abcde1234567890abcdef1234567890abcdef1234567\")\n    .votes(\"0000000000000000000000000000000000000000000000000000000000000000\")\n    .minerPk(\"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\");\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `PreHeader` which represents a pre-header of a block in the Ergo blockchain.\n\n2. What are the required fields for a `PreHeader` object?\n- The required fields for a `PreHeader` object are `timestamp`, `version`, `nBits`, `height`, `parentId`, and `votes`.\n\n3. What is the format of the `minerPk` field?\n- The `minerPk` field is a string that represents the public key of the miner who mined the block. It is in hexadecimal format.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/PreHeader.md"}}],["204",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ProofOfUpcomingTransactions.java)\n\nThis code defines a Java class called `ProofOfUpcomingTransactions` that represents a proof that a block corresponding to a given header without Proof-of-Work contains some transactions. The class has two properties: `msgPreimage` and `txProofs`. \n\nThe `msgPreimage` property is a string that represents a base16-encoded serialized header without Proof-of-Work. The `txProofs` property is a list of `MerkleProof` objects that represent Merkle proofs of transactions included in the block (not necessarily all the block transactions). \n\nThe class provides getter and setter methods for both properties. It also overrides the `equals`, `hashCode`, and `toString` methods inherited from the `Object` class. \n\nThis class is part of the Ergo Node API and is used to provide proof that a block contains transactions without requiring the full Proof-of-Work. It can be used in conjunction with other classes in the API to verify the validity of a block and its transactions. \n\nExample usage:\n\n```java\nProofOfUpcomingTransactions proof = new ProofOfUpcomingTransactions();\nproof.setMsgPreimage(\"0112e03c6d39d32509855be7cee9b62ff921f7a0cf6883e232474bd5b54d816dd056f846980d34c3b23098bdcf41222f8cdee5219224aa67750055926c3a2310a483accc4f9153e7a760615ea972ac67911cff111f8c17f563d6147205f58f85133ae695d1d4157e4aecdbbb29952cfa42b75129db55bddfce3bc53b8fd5b5465f10d8be8ddda62ed3b86afb0497ff2d381ed884bdae5287d20667def224a28d2b6e3ebfc78709780702c70bd8df0e000000\");\nMerkleProof txProof = new MerkleProof();\ntxProof.setProof(\"proof\");\nproof.addTxProofsItem(txProof);\n```\n## Questions: \n 1. What is the purpose of this class and how does it relate to the Ergo Node API?\n- This class represents a proof that a block corresponding to a given header without PoW contains some transactions. It is part of the Ergo Node API and its purpose is to provide a way to verify the validity of upcoming transactions.\n\n2. What is the format of the msgPreimage field and why is it important?\n- The msgPreimage field is a Base16-encoded serialized header without Proof-of-Work. It is important because it allows for the verification of the header without the need for PoW, which can be computationally expensive.\n\n3. What is the purpose of the txProofs field and what kind of data does it contain?\n- The txProofs field contains Merkle proofs of transactions included into blocks (not necessarily all the block transactions). Its purpose is to provide a way to verify the validity of the transactions included in the block.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ProofOfUpcomingTransactions.md"}}],["205",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Registers.java)\n\nThis code defines a class called `Registers` which extends the `java.util.HashMap` class. The purpose of this class is to represent the registers of an Ergo box. An Ergo box is a data structure used in the Ergo blockchain to store and transfer value. Each box has a set of registers which can be used to store additional data. \n\nThe `Registers` class provides a way to represent these registers as a key-value map where the keys are strings and the values are also strings. The class overrides the `equals`, `hashCode`, and `toString` methods of the `HashMap` class to provide custom behavior specific to Ergo box registers. \n\nThis class is part of the Ergo Node API and is generated automatically by the Swagger code generator program. It is not intended to be edited manually. \n\nIn the larger project, this class can be used to represent the registers of an Ergo box in Java code. For example, if a developer wants to create a new Ergo box with custom registers, they can create a new instance of the `Registers` class and populate it with the desired key-value pairs. They can then pass this `Registers` object to the constructor of an `ErgoBox` object to create a new box with the specified registers. \n\nExample usage:\n\n```\nRegisters registers = new Registers();\nregisters.put(\"R4\", \"hello\");\nregisters.put(\"R5\", \"world\");\n\nErgoBox box = new ErgoBox(value, script, height, registers);\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a class called `Registers` which extends `java.util.HashMap` and represents Ergo box registers.\n\n2. What version of the OpenAPI spec is this code based on?\n- This code is based on version 4.0.12 of the OpenAPI spec.\n\n3. Why is there a `toString()` method defined in this class?\n- The `toString()` method is defined to provide a string representation of the `Registers` object, including its superclass `HashMap`.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Registers.md"}}],["206",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/RequestsHolder.java)\n\nThe `RequestsHolder` class is part of the Ergo Node API and is used to hold multiple transaction requests and a transaction fee. This class is generated automatically by the Swagger code generator program and should not be edited manually. \n\nThe `RequestsHolder` class has four properties: `requests`, `fee`, `inputsRaw`, and `dataInputsRaw`. The `requests` property is a list of transaction requests, where each request is an instance of `AnyOfRequestsHolderRequestsItems`. The `fee` property is the transaction fee, represented as a `Long`. The `inputsRaw` property is a list of inputs to be used in serialized form, and the `dataInputsRaw` property is a list of data inputs to be used in serialized form. \n\nThe `RequestsHolder` class provides methods to set and get the values of its properties. The `requests` property can be set using the `requests` method, which takes a list of `AnyOfRequestsHolderRequestsItems` as an argument. The `addRequestsItem` method can be used to add a single `AnyOfRequestsHolderRequestsItems` to the `requests` list. The `fee` property can be set using the `fee` method, which takes a `Long` as an argument. The `inputsRaw` property can be set using the `inputsRaw` method, which takes a list of `String`s as an argument. The `addInputsRawItem` method can be used to add a single `String` to the `inputsRaw` list. The `dataInputsRaw` property can be set using the `dataInputsRaw` method, which takes a list of `String`s as an argument. The `addDataInputsRawItem` method can be used to add a single `String` to the `dataInputsRaw` list. \n\nOverall, the `RequestsHolder` class is used to hold multiple transaction requests and a transaction fee, along with lists of inputs and data inputs in serialized form. This class is likely used in the larger Ergo Node API project to facilitate the creation and submission of multiple transactions at once. \n\nExample usage:\n\n```\nRequestsHolder requestsHolder = new RequestsHolder();\nrequestsHolder.addRequestsItem(request1);\nrequestsHolder.addRequestsItem(request2);\nrequestsHolder.fee(1000000L);\nrequestsHolder.addInputsRawItem(input1);\nrequestsHolder.addInputsRawItem(input2);\nrequestsHolder.addDataInputsRawItem(dataInput1);\nrequestsHolder.addDataInputsRawItem(dataInput2);\n```\n## Questions: \n 1. What is the purpose of the `RequestsHolder` class?\n- The `RequestsHolder` class holds many transaction requests and transaction fee.\n\n2. What are the possible values for the `requests` field?\n- The `requests` field is a sequence of transaction requests, and its possible values are instances of `AnyOfRequestsHolderRequestsItems`.\n\n3. Can the `inputsRaw` and `dataInputsRaw` fields be null?\n- Yes, both `inputsRaw` and `dataInputsRaw` fields can be null.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/RequestsHolder.md"}}],["207",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Scan.java)\n\nThe `Scan` class is part of the Ergo Node API and provides a model for a scanning operation. It contains three properties: `scanName`, `scanId`, and `trackingRule`. \n\nThe `scanName` property is a string that represents the name of the scan. The `scanId` property is an integer that represents the unique identifier of the scan. The `trackingRule` property is an instance of the `ScanningPredicate` class, which represents the predicate used to track the scan.\n\nThe `Scan` class provides getter and setter methods for each property, allowing the properties to be accessed and modified as needed. It also provides methods for equality checking, hashing, and string representation.\n\nThis class can be used in the larger Ergo Node API project to represent a scanning operation. For example, it could be used to create a new scan by setting the `scanName` and `trackingRule` properties and then sending the `Scan` object to the server. It could also be used to retrieve information about an existing scan by retrieving the `scanId` property and sending a request to the server with that ID.\n\nExample usage:\n\n```java\n// Create a new scan\nScan scan = new Scan()\n    .scanName(\"My Scan\")\n    .trackingRule(new ScanningPredicate());\n\n// Send the scan to the server\nScan createdScan = api.createScan(scan);\n\n// Retrieve information about an existing scan\nScan existingScan = api.getScanById(123);\nSystem.out.println(existingScan.getScanName());\n```\n## Questions: \n 1. What is the purpose of the `Scan` class?\n    \n    The `Scan` class is part of the Ergo Node API and represents a scanning operation with a name, ID, and tracking rule.\n\n2. What is the `ScanningPredicate` class and how is it related to `Scan`?\n    \n    The `ScanningPredicate` class is used as the tracking rule for a `Scan` object. It defines a predicate that is used to filter the results of a scan.\n\n3. Why is there a `toIndentedString` method in the `Scan` class?\n    \n    The `toIndentedString` method is used to convert an object to a string with each line indented by 4 spaces. It is used in the `toString` method to format the output of the `Scan` object.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Scan.md"}}],["208",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ScanApi.java)\n\nThe `ScanApi` interface defines methods for interacting with the Ergo blockchain through the Ergo Appkit. The methods in this interface allow for registering and deregistering scans, adding boxes to scans, and listing unspent boxes for a given scan. \n\nThe `addBox` method adds a box to a scan and writes it to the database if it is not already there. The `deregisterScan` method stops tracking and deregisters a scan. The `listAllScans` method lists all registered scans. The `listUnspentScans` method lists boxes that are not spent for a given scan, with optional parameters for minimum confirmations and inclusion height. The `registerScan` method registers a new scan. Finally, the `scanStopTracking` method stops tracking a box related to a scan.\n\nThese methods can be used to build applications that interact with the Ergo blockchain. For example, an application that needs to track unspent boxes for a specific scan can use the `listUnspentScans` method to retrieve the necessary information. Similarly, an application that needs to add a box to a scan can use the `addBox` method to accomplish this. \n\nHere is an example of how the `listUnspentScans` method can be used:\n\n```java\nScanApi scanApi = retrofit.create(ScanApi.class);\nCall<List<WalletBox>> call = scanApi.listUnspentScans(scanId, minConfirmations, minInclusionHeight);\nResponse<List<WalletBox>> response = call.execute();\nList<WalletBox> unspentBoxes = response.body();\n```\n\nIn this example, `scanId` is the identifier of the scan for which unspent boxes should be retrieved, `minConfirmations` is the minimum number of confirmations required for a box to be considered unspent (default is 0), and `minInclusionHeight` is the minimum inclusion height required for a box to be considered unspent (default is 0). The `execute` method is called on the `Call` object to make the API request, and the resulting `List` of `WalletBox` objects is retrieved from the response body.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines an interface for making API calls related to scanning and tracking boxes in the Ergo blockchain.\n\n2. What are the required parameters for the `addBox` method?\n- The `addBox` method requires a `ScanIdsBox` object to be passed in the request body.\n\n3. What is the response type for the `listAllScans` method?\n- The `listAllScans` method returns a `Call` object that wraps a list of `Scan` objects.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ScanApi.md"}}],["209",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ScanId.java)\n\nThe code represents a Java class called `ScanId` which is a part of the Ergo Node API. The purpose of this class is to model a scan ID which is used to identify a specific scan in the Ergo blockchain. The class has a single field called `scanId` which is an integer representing the ID of the scan. \n\nThe class provides a getter and a setter method for the `scanId` field. The `getScanId()` method returns the value of the `scanId` field, while the `setScanId()` method sets the value of the `scanId` field. \n\nThe class also provides methods for equality checking, hashing, and string representation. The `equals()` method checks if two `ScanId` objects are equal by comparing their `scanId` fields. The `hashCode()` method returns a hash code value for the `ScanId` object based on its `scanId` field. The `toString()` method returns a string representation of the `ScanId` object, including its `scanId` field.\n\nThis class can be used in the larger Ergo Node API project to represent a scan ID in various API requests and responses. For example, a request to get information about a specific scan may include a `ScanId` object as a parameter, while a response from the API may include a `ScanId` object as a field in a JSON object. \n\nHere is an example of how this class can be used:\n\n```\nScanId scanId = new ScanId();\nscanId.setScanId(12345);\nint id = scanId.getScanId();\nSystem.out.println(\"Scan ID: \" + id);\n```\n\nThis code creates a new `ScanId` object, sets its `scanId` field to 12345, gets the value of the `scanId` field using the `getScanId()` method, and prints it to the console. The output will be \"Scan ID: 12345\".\n## Questions: \n 1. What is the purpose of this code?\n- This code is a Java class for a model called ScanId in the Ergo Node API.\n\n2. What is the significance of the @SerializedName and @Schema annotations?\n- The @SerializedName annotation is used to specify the name of the JSON property that corresponds to the Java field. The @Schema annotation is used to provide additional information about the field for documentation purposes.\n\n3. Why is the toString() method overridden in this class?\n- The toString() method is overridden to provide a string representation of the ScanId object for debugging and logging purposes.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ScanId.md"}}],["210",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ScanIdBoxId.java)\n\nThe `ScanIdBoxId` class is a model class that represents a combination of a scan ID and a box ID. It is used in the Ergo Node API to provide a unique identifier for a box that has been scanned. \n\nThe class has two private instance variables: `scanId` and `boxId`. `scanId` is an integer that represents the ID of the scan that the box was a part of, while `boxId` is a string that represents the ID of the box itself. \n\nThe class provides getter and setter methods for both instance variables, as well as an `equals` method that compares two `ScanIdBoxId` objects for equality based on their `scanId` and `boxId` values. It also provides a `hashCode` method for generating a hash code based on the `scanId` and `boxId` values, and a `toString` method for generating a string representation of the object.\n\nThis class is used in other parts of the Ergo Node API to uniquely identify scanned boxes. For example, it may be used in a request to retrieve information about a specific box that has been scanned, or to update the status of a box that has been scanned. \n\nExample usage:\n\n```\nScanIdBoxId scanIdBoxId = new ScanIdBoxId();\nscanIdBoxId.setScanId(123);\nscanIdBoxId.setBoxId(\"abc123\");\n\nSystem.out.println(scanIdBoxId.getScanId()); // Output: 123\nSystem.out.println(scanIdBoxId.getBoxId()); // Output: abc123\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `ScanIdBoxId` which has two properties: `scanId` and `boxId`.\n\n2. What is the expected input and output of this code?\n- The input is an integer `scanId` and a string `boxId`. The output is an instance of the `ScanIdBoxId` class with the `scanId` and `boxId` properties set.\n\n3. Can the `scanId` and `boxId` properties be null?\n- The `scanId` property cannot be null as it is marked as required in the `@Schema` annotation. The `boxId` property is not marked as required and can be null.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ScanIdBoxId.md"}}],["211",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ScanIdsBox.java)\n\nThe `ScanIdsBox` class is part of the Ergo Node API and is used to represent an Ergo box with associated scans. The class contains two fields: `scanIds` and `box`. The `scanIds` field is a list of integers representing the identifiers of the associated scans, while the `box` field is an instance of the `ErgoTransactionOutput` class representing the Ergo box.\n\nThe `ScanIdsBox` class provides methods to set and get the values of these fields. The `scanIds` field can be set using the `scanIds` method, which takes a list of integers as input. The `addScanIdsItem` method can be used to add individual integers to the `scanIds` list. The `getScanIds` method returns the list of scan IDs.\n\nThe `box` field can be set using the `box` method, which takes an instance of the `ErgoTransactionOutput` class as input. The `getBox` method returns the `ErgoTransactionOutput` instance.\n\nThe `ScanIdsBox` class also provides methods to override the `equals`, `hashCode`, and `toString` methods inherited from the `Object` class. The `equals` method compares two `ScanIdsBox` instances for equality based on the values of their `scanIds` and `box` fields. The `hashCode` method returns a hash code value for the `ScanIdsBox` instance based on the values of its `scanIds` and `box` fields. The `toString` method returns a string representation of the `ScanIdsBox` instance, including the values of its `scanIds` and `box` fields.\n\nThis class can be used in the larger project to represent an Ergo box with associated scans. It can be used to create, modify, and query Ergo boxes with associated scans. For example, the `ScanIdsBox` class can be used to create a new Ergo box with associated scans by setting the `scanIds` and `box` fields and passing the resulting `ScanIdsBox` instance to a method that creates a new Ergo box. Similarly, the `ScanIdsBox` class can be used to modify an existing Ergo box with associated scans by retrieving the `ScanIdsBox` instance representing the box, modifying its `scanIds` and/or `box` fields, and passing the modified `ScanIdsBox` instance to a method that updates the Ergo box. Finally, the `ScanIdsBox` class can be used to query an existing Ergo box with associated scans by retrieving the `ScanIdsBox` instance representing the box and accessing its `scanIds` and `box` fields.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `ScanIdsBox` which represents an Ergo box with associated scans.\n\n2. What external libraries or dependencies does this code use?\n- This code uses the `com.google.gson` and `io.swagger.v3.oas.annotations` libraries.\n\n3. Can the properties `scanIds` and `box` be null?\n- It is not specified in the code whether these properties can be null or not.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ScanIdsBox.md"}}],["212",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ScanRequest.java)\n\nThe `ScanRequest` class is part of the Ergo Node API and is used to create a request to scan the blockchain for specific transactions. The class has two properties: `scanName` and `trackingRule`. The `scanName` property is a string that represents the name of the scan. The `trackingRule` property is an instance of the `ScanningPredicate` class, which is used to define the criteria for the scan.\n\nThe `ScanRequest` class has two methods for setting the values of its properties: `scanName` and `trackingRule`. These methods return the instance of the `ScanRequest` class, which allows for method chaining. The `getScanName` and `getTrackingRule` methods are used to retrieve the values of the `scanName` and `trackingRule` properties, respectively.\n\nThe `equals` and `hashCode` methods are used to compare two instances of the `ScanRequest` class for equality. The `toString` method returns a string representation of the `ScanRequest` instance.\n\nThis class is generated by the Swagger Codegen program and should not be edited manually. It is used in the larger Ergo Node API project to create requests for scanning the blockchain. An example of how this class may be used in the larger project is shown below:\n\n```\nScanRequest request = new ScanRequest()\n    .scanName(\"myScan\")\n    .trackingRule(new ScanningPredicate()\n        .property(\"output.value\")\n        .operator(\">\")\n        .value(\"1000000\"));\n```\n\nThis code creates a new `ScanRequest` instance with a `scanName` of \"myScan\" and a `trackingRule` that looks for transactions with an output value greater than 1000000. This request can then be sent to the Ergo Node API to scan the blockchain for matching transactions.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `ScanRequest` which is used to represent a request to scan a resource.\n\n2. What is the significance of the `ScanningPredicate` class?\n- The `ScanningPredicate` class is used as a type for the `trackingRule` field in the `ScanRequest` class, and represents a predicate used to filter resources during a scan.\n\n3. Why is the `ScanRequest` class generated by a code generator program?\n- The `ScanRequest` class is generated by the Swagger code generator program, which automatically generates code based on an OpenAPI specification. This ensures consistency and accuracy in the generated code.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ScanRequest.md"}}],["213",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ScanningPredicate.java)\n\nThe code defines a Java class called `ScanningPredicate` which is used in the Ergo Node API. The purpose of this class is to represent a scanning predicate, which is a string that specifies a condition that must be met in order for a transaction to be included in a block. The `ScanningPredicate` class has a single field called `predicate` which is a string that represents the scanning predicate.\n\nThe class has a constructor that takes no arguments, and a `predicate` method that takes a string argument and sets the `predicate` field to that value. The class also has a `getPredicate` method that returns the value of the `predicate` field.\n\nThe class overrides the `equals`, `hashCode`, and `toString` methods. The `equals` method compares two `ScanningPredicate` objects for equality based on the value of their `predicate` fields. The `hashCode` method returns a hash code for the `ScanningPredicate` object based on the value of its `predicate` field. The `toString` method returns a string representation of the `ScanningPredicate` object, including the value of its `predicate` field.\n\nThis class is used in the Ergo Node API to specify a scanning predicate when querying the blockchain for transactions. For example, the following code snippet shows how to create a `ScanningPredicate` object and use it to query the blockchain for transactions that meet the specified condition:\n\n```\nScanningPredicate predicate = new ScanningPredicate();\npredicate.predicate(\"INPUTS.size > 2\");\n\nList<Transaction> transactions = api.getTransactionsByScanPredicate(predicate);\n```\n\nIn this example, a `ScanningPredicate` object is created with the condition `INPUTS.size > 2`. This condition specifies that the transaction must have more than two inputs in order to be included in the result set. The `getTransactionsByScanPredicate` method is then called on the Ergo Node API with the `ScanningPredicate` object as an argument. This method returns a list of `Transaction` objects that meet the specified condition.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `ScanningPredicate` which has a single property called `predicate`.\n\n2. What is the expected input for the `predicate` property?\n- The `predicate` property is marked as required and is expected to be a string.\n\n3. Why is there a `toString()` method in this class?\n- The `toString()` method is used to convert an instance of the `ScanningPredicate` class to a string representation. This is useful for debugging and logging purposes.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ScanningPredicate.md"}}],["214",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ScriptApi.java)\n\nThe `ScriptApi` interface defines a set of methods for interacting with the Ergo blockchain's script functionality. The methods allow for the conversion of an address to a hex-encoded Sigma byte array constant which contains script bytes, as well as the conversion of an address to a hex-encoded serialized ErgoTree (script). Additionally, the interface provides methods for executing a script with context, creating a P2SAddress from Sigma source, and creating a P2SHAddress from Sigma source.\n\nThe `addressToBytes` method takes an address as a parameter and returns a `Call` object that can be used to asynchronously retrieve an `InlineResponse2008` object. This object contains the hex-encoded Sigma byte array constant which contains script bytes for the given address.\n\nThe `addressToTree` method is similar to `addressToBytes`, but instead returns a hex-encoded serialized ErgoTree (script) for the given address.\n\nThe `executeWithContext` method takes an `ExecuteScript` object as a parameter and returns a `Call` object that can be used to asynchronously retrieve a `CryptoResult` object. This method executes a script with context, allowing for the evaluation of a script with a given set of inputs.\n\nThe `scriptP2SAddress` and `scriptP2SHAddress` methods both take a `SourceHolder` object as a parameter and return a `Call` object that can be used to asynchronously retrieve an `AddressHolder` object. These methods create a P2SAddress or P2SHAddress from Sigma source, respectively.\n\nOverall, this interface provides a set of methods for interacting with the Ergo blockchain's script functionality, allowing for the conversion of addresses to scripts, the execution of scripts with context, and the creation of P2SAddress and P2SHAddress objects from Sigma source. Below is an example of how the `addressToBytes` method can be used:\n\n```\nScriptApi scriptApi = retrofit.create(ScriptApi.class);\nCall<InlineResponse2008> call = scriptApi.addressToBytes(\"9f5e7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d7d\");\nInlineResponse2008 response = call.execute().body();\n```\n## Questions: \n 1. What is the purpose of this code?\n   - This code defines an interface `ScriptApi` for making REST API calls related to executing and creating scripts in the Ergo blockchain platform.\n\n2. What external libraries or dependencies does this code use?\n   - This code uses the Retrofit2 and OkHttp3 libraries for making HTTP requests and handling responses.\n\n3. What are some examples of API calls that can be made using this interface?\n   - Examples of API calls that can be made using this interface include converting an address to a serialized ErgoTree, executing a script with context, and creating P2SAddress and P2SHAddress from Sigma source.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/ScriptApi.md"}}],["215",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/SecretProven.java)\n\nThe `SecretProven` class is part of the Ergo Node API and is used to represent a secret that has been proven. It contains information about the secret, including the hint, challenge, public key, proof, and position. \n\nThe `hint` field is an enum that can have two values: `PROOFREAL` or `PROOFSIMULATED`. This field indicates whether the proof is real or simulated. The `challenge` field is a string that represents the challenge that was used to generate the proof. The `pubkey` field is a `SigmaBoolean` object that represents the public key used to generate the proof. The `proof` field is a string that represents the proof itself. Finally, the `position` field is a string that represents the position of the secret in the proof.\n\nThis class is used in the larger Ergo Node API project to represent secrets that have been proven. It can be used to serialize and deserialize JSON objects that represent secrets. For example, the following code can be used to create a `SecretProven` object from a JSON string:\n\n```\nString json = \"{\\\"hint\\\":\\\"PROOFREAL\\\",\\\"challenge\\\":\\\"challenge\\\",\\\"pubkey\\\":{\\\"sigmaProp\\\":{\\\"value\\\":true}},\\\"proof\\\":\\\"proof\\\",\\\"position\\\":\\\"position\\\"}\";\nSecretProven secretProven = new Gson().fromJson(json, SecretProven.class);\n```\n\nThis code creates a `SecretProven` object from a JSON string that contains the hint, challenge, public key, proof, and position fields. The `Gson` library is used to deserialize the JSON string into a `SecretProven` object.\n\nOverall, the `SecretProven` class is an important part of the Ergo Node API project and is used to represent secrets that have been proven. It provides a convenient way to serialize and deserialize JSON objects that represent secrets.\n## Questions: \n 1. What is the purpose of the `SecretProven` class?\n- The `SecretProven` class is part of the Ergo Node API and represents a secret that has been proven.\n\n2. What is the `HintEnum` enum used for?\n- The `HintEnum` enum is used to specify whether the proof is real or simulated.\n\n3. What is the `SigmaBoolean` class used for?\n- The `SigmaBoolean` class is used to represent a boolean expression in Sigma protocols. In this context, it is used to represent a public key.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/SecretProven.md"}}],["216",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/SerializedBox.java)\n\nThe `SerializedBox` class is part of the Ergo Node API and is used to represent a serialized box. A box in Ergo is a data structure that holds assets and can be locked by a script. The purpose of this class is to provide a standardized way of serializing and deserializing boxes in the Ergo platform.\n\nThe class has two fields: `boxId` and `bytes`. `boxId` is a string that represents the unique identifier of the box, while `bytes` is a string that represents the serialized bytes of the box. The `boxId` field is required, while the `bytes` field is optional.\n\nThe class provides getter and setter methods for both fields, as well as methods for equality checking, hashing, and string representation.\n\nThis class can be used in the larger Ergo Node API project to represent serialized boxes in requests and responses. For example, a request to create a new box might include a `SerializedBox` object in the request body, while a response to a query for box information might include a list of `SerializedBox` objects.\n\nHere is an example of how this class might be used in a request to create a new box:\n\n```\nSerializedBox newBox = new SerializedBox();\nnewBox.boxId(\"12345\");\nnewBox.bytes(\"ABCDEF123456\");\n\n// Use newBox in request body\n```\n\nIn this example, a new `SerializedBox` object is created and its `boxId` and `bytes` fields are set. The `newBox` object can then be used in the request body to create a new box.\n## Questions: \n 1. What is the purpose of this code?\n- This code is a model for a SerializedBox in the Ergo Node API.\n\n2. What is the significance of the @SerializedName and @Schema annotations?\n- The @SerializedName annotation is used to specify the serialized name of a field in JSON. The @Schema annotation is used to provide additional information about a field for documentation purposes.\n\n3. What is the purpose of the equals and hashCode methods?\n- The equals and hashCode methods are used for object comparison and hashing, respectively. They are necessary for certain operations such as adding objects to collections.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/SerializedBox.md"}}],["217",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/SigmaBoolean.java)\n\nThe `SigmaBoolean` class is part of the Ergo Node API and is used to represent sigma proposition expressions. Sigma is a scripting language used in the Ergo blockchain to define transaction validation rules. The `SigmaBoolean` class is an algebraic data type that can represent different types of sigma expressions. \n\nThe class has six fields: `op`, `h`, `g`, `u`, `v`, and `condition`. The `op` field is an integer that represents the sigma opcode. The `h`, `g`, `u`, and `v` fields are strings that represent different types of sigma expressions. The `condition` field is a boolean that represents whether the sigma expression is a condition.\n\nThe class provides getter and setter methods for each field. The `toString()` method is overridden to provide a string representation of the object. The `equals()` and `hashCode()` methods are also overridden to provide equality comparison based on the object's fields.\n\nThis class is generated by the Swagger Codegen program and should not be edited manually. It is used in the larger Ergo Node API project to represent sigma expressions in transactions. Here is an example of how this class might be used in the Ergo Node API:\n\n```java\nSigmaBoolean sigmaBoolean = new SigmaBoolean()\n    .op(1)\n    .h(\"hash\")\n    .g(\"group\")\n    .u(\"u\")\n    .v(\"v\")\n    .condition(true);\n```\n\nThis creates a new `SigmaBoolean` object with the `op` field set to 1, the `h` field set to \"hash\", the `g` field set to \"group\", the `u` field set to \"u\", the `v` field set to \"v\", and the `condition` field set to true.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a class called `SigmaBoolean` which is an algebraic data type of sigma proposition expressions. It contains various fields and methods to manipulate those fields.\n\n2. What is the significance of the `op` field?\n- The `op` field represents the Sigma opCode and is required according to the schema. It is an integer value.\n\n3. What is the purpose of the `toString()` method?\n- The `toString()` method is used to convert the `SigmaBoolean` object to a string representation. It is used for debugging and logging purposes.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/SigmaBoolean.md"}}],["218",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/SigmaBooleanAndPredicate.java)\n\nThe code defines a class called `SigmaBooleanAndPredicate` which extends another class called `SigmaBoolean`. This class is part of the Ergo Node API and is used to represent a boolean AND predicate in the Sigma protocol. The purpose of this class is to provide a way to create and manipulate SigmaBooleanAndPredicate objects in Java code.\n\nThe class has a single field called `args` which is a list of SigmaBoolean objects. This list represents the arguments of the AND predicate. The class provides methods to add and retrieve elements from this list.\n\nThe class also overrides several methods from the parent class, including `equals`, `hashCode`, and `toString`. These methods are used to compare SigmaBooleanAndPredicate objects, generate hash codes for them, and convert them to strings, respectively.\n\nThis class is generated automatically by the Swagger code generator program and should not be edited manually. It is used in the larger Ergo Node API project to represent SigmaBoolean objects in Java code. Here is an example of how this class might be used:\n\n```\nSigmaBooleanAndPredicate predicate = new SigmaBooleanAndPredicate();\npredicate.addArgsItem(new SigmaBoolean());\npredicate.addArgsItem(new SigmaBoolean());\nSystem.out.println(predicate.getArgs().size()); // Output: 2\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code is a model class for SigmaBooleanAndPredicate in the Ergo Node API, which extends the SigmaBoolean class and contains a list of SigmaBoolean arguments.\n\n2. What is the significance of the @SerializedName and @Schema annotations?\n- The @SerializedName annotation is used to specify the name of the serialized JSON property for the annotated field, while the @Schema annotation is used to provide additional information about the field for documentation purposes.\n\n3. What is the purpose of the equals() and hashCode() methods in this class?\n- The equals() and hashCode() methods are used to compare instances of SigmaBooleanAndPredicate based on their argument lists and superclass properties, and are necessary for proper functioning of collections and other data structures that rely on object equality.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/SigmaBooleanAndPredicate.md"}}],["219",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/SigmaBooleanOrPredicate.java)\n\nThe `SigmaBooleanOrPredicate` class is part of the Ergo Node API and is used to represent a boolean OR predicate in the Sigma protocol. This class extends the `SigmaBoolean` class and adds a list of `SigmaBoolean` objects as arguments to the OR predicate. \n\nThe purpose of this class is to provide a way to represent complex boolean expressions in the Sigma protocol. The `SigmaBooleanOrPredicate` class can be used to construct complex boolean expressions by combining multiple `SigmaBoolean` objects using the OR operator. \n\nFor example, suppose we have two `SigmaBoolean` objects `A` and `B`. We can create a new `SigmaBooleanOrPredicate` object that represents the boolean expression `(A OR B)` as follows:\n\n```\nSigmaBooleanOrPredicate orPredicate = new SigmaBooleanOrPredicate();\norPredicate.addArgsItem(A);\norPredicate.addArgsItem(B);\n```\n\nThis creates a new `SigmaBooleanOrPredicate` object with `A` and `B` as arguments to the OR predicate. \n\nThe `SigmaBooleanOrPredicate` class provides methods to add new arguments to the OR predicate (`addArgsItem`) and to retrieve the list of arguments (`getArgs`). It also overrides the `equals`, `hashCode`, and `toString` methods to provide a way to compare and print `SigmaBooleanOrPredicate` objects. \n\nOverall, the `SigmaBooleanOrPredicate` class is an important part of the Ergo Node API and provides a way to represent complex boolean expressions in the Sigma protocol.\n## Questions: \n 1. What is the purpose of this code and how does it fit into the overall ergo-appkit project?\n- This code is part of the Ergo Node API and provides a model for a SigmaBooleanOrPredicate. It is generated automatically by the Swagger code generator program.\n\n2. What is a SigmaBooleanOrPredicate and how is it used in the Ergo Node API?\n- A SigmaBooleanOrPredicate is a type of SigmaBoolean that contains a list of SigmaBoolean arguments. It is used in the Ergo Node API to represent a logical OR operation between multiple SigmaBoolean expressions.\n\n3. Are there any other classes or methods in the Ergo Node API that interact with SigmaBooleanOrPredicate objects?\n- It is unclear from this code alone whether there are other classes or methods that interact with SigmaBooleanOrPredicate objects. Further investigation of the Ergo Node API documentation or codebase would be necessary to determine this.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/SigmaBooleanOrPredicate.md"}}],["220",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/SigmaBooleanThresholdPredicate.java)\n\nThis code defines a class called `SigmaBooleanThresholdPredicate` which extends another class called `SigmaBoolean`. The purpose of this class is to represent a threshold predicate in the Ergo platform. A threshold predicate is a type of logical expression that evaluates to true if a certain number of sub-expressions are true. In this case, the `SigmaBooleanThresholdPredicate` class contains a list of `SigmaBoolean` objects called `args`, which represent the sub-expressions that are evaluated by the threshold predicate.\n\nThe `SigmaBooleanThresholdPredicate` class has methods for getting and setting the `args` list, as well as adding new `SigmaBoolean` objects to the list. It also overrides several methods from the `Object` class, including `equals()`, `hashCode()`, and `toString()`, to provide custom behavior for these methods when working with `SigmaBooleanThresholdPredicate` objects.\n\nThis class is part of the Ergo Node API, which provides a set of models and methods for interacting with the Ergo platform. It may be used in conjunction with other classes and methods in the API to build applications that interact with the Ergo blockchain. For example, a developer might use this class to create a threshold predicate that evaluates a set of conditions before allowing a transaction to be executed on the Ergo blockchain.\n\nHere is an example of how this class might be used in a larger project:\n\n```\n// create a new threshold predicate with two sub-expressions\nSigmaBooleanThresholdPredicate predicate = new SigmaBooleanThresholdPredicate()\n    .addArgsItem(new SigmaBooleanCondition1())\n    .addArgsItem(new SigmaBooleanCondition2());\n\n// evaluate the predicate\nboolean result = predicate.evaluate();\n\n// use the result to determine whether to execute a transaction\nif (result) {\n    ErgoTransaction tx = new ErgoTransaction();\n    // add inputs and outputs to the transaction\n    // ...\n    ErgoNode.submitTransaction(tx);\n}\n```\n## Questions: \n 1. What is the purpose of this code file?\n- This code file is part of the Ergo Node API and contains a class called SigmaBooleanThresholdPredicate.\n\n2. What is the relationship between SigmaBooleanThresholdPredicate and SigmaBoolean?\n- SigmaBooleanThresholdPredicate extends SigmaBoolean, meaning it inherits properties and methods from the SigmaBoolean class.\n\n3. What is the purpose of the args field in SigmaBooleanThresholdPredicate?\n- The args field is a list of SigmaBoolean objects and is used to store arguments for the SigmaBooleanThresholdPredicate.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/SigmaBooleanThresholdPredicate.md"}}],["221",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/SigmaHeader.java)\n\nThe `SigmaHeader` class in the `ergo-appkit` project represents the block header format used for the sigma ErgoLikeContext. This class is auto-generated by the swagger code generator program and should not be edited manually.\n\nThe `SigmaHeader` class contains various fields related to a block header, such as `id`, `timestamp`, `version`, `adProofsRoot`, `adProofsId`, `stateRoot`, `transactionsRoot`, `transactionsId`, `nBits`, `extensionHash`, `extensionRoot`, `extensionId`, `height`, `size`, `parentId`, `powSolutions`, `votes`, `minerPk`, `powOnetimePk`, `powNonce`, and `powDistance`. Each field has its respective getter and setter methods, as well as a method to set the field value in a chained manner.\n\nFor example, to create a new `SigmaHeader` object with specific values, you can use the following code:\n\n```java\nSigmaHeader header = new SigmaHeader()\n    .id(\"someId\")\n    .timestamp(123456789)\n    .version(1)\n    .adProofsRoot(\"someAdProofsRoot\")\n    .adProofsId(\"someAdProofsId\")\n    .stateRoot(new AvlTreeData())\n    .transactionsRoot(\"someTransactionsRoot\")\n    .transactionsId(\"someTransactionsId\")\n    .nBits(19857408L)\n    .extensionHash(\"someExtensionHash\")\n    .extensionRoot(\"someExtensionRoot\")\n    .extensionId(\"someExtensionId\")\n    .height(667)\n    .size(667)\n    .parentId(\"someParentId\")\n    .powSolutions(new PowSolutions())\n    .votes(\"someVotes\")\n    .minerPk(\"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\")\n    .powOnetimePk(\"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\")\n    .powNonce(\"somePowNonce\")\n    .powDistance(new BigDecimal(\"123456789\"));\n```\n\nThis class is used in the larger project to represent and manipulate block header data in the Ergo blockchain. It provides a convenient way to access and modify block header properties, which can be useful when working with Ergo's blockchain data.\n## Questions: \n 1. **Question**: What is the purpose of the `SigmaHeader` class?\n   **Answer**: The `SigmaHeader` class represents the block header format used for sigma ErgoLikeContext in the Ergo Node API. It contains various fields related to the block header, such as id, timestamp, version, stateRoot, and more.\n\n2. **Question**: How is the `SigmaHeader` class generated?\n   **Answer**: The `SigmaHeader` class is auto-generated by the Swagger Code Generator program, as mentioned in the comments at the beginning of the code. It is based on the OpenAPI spec version 4.0.12.\n\n3. **Question**: What are the required fields in the `SigmaHeader` class?\n   **Answer**: The required fields in the `SigmaHeader` class are timestamp, version, adProofsRoot, stateRoot, transactionsRoot, nBits, extensionHash, height, and votes. These fields are marked with the `@Schema(required = true)` annotation.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/SigmaHeader.md"}}],["222",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/SourceHolder.java)\n\nThe `SourceHolder` class is a model class that represents a Sigma source to be compiled. It is used in the Ergo Node API to provide a way to pass Sigma source code to the server for compilation. \n\nThe class has a single field, `source`, which is a string representing the Sigma source code. The `source` field is annotated with `@Schema` to indicate that it is a required field for the API. The class also has a getter and setter method for the `source` field.\n\nThe `SourceHolder` class overrides the `equals`, `hashCode`, and `toString` methods to provide a way to compare instances of the class, generate a hash code for an instance, and generate a string representation of an instance, respectively.\n\nThis class is generated by the Swagger code generator program and should not be edited manually. It is used in the larger Ergo Node API project to provide a standardized way to pass Sigma source code to the server for compilation. \n\nExample usage:\n\n```java\nSourceHolder sourceHolder = new SourceHolder();\nsourceHolder.setSource(\"HEIGHT > 1000\");\nString source = sourceHolder.getSource(); // \"HEIGHT > 1000\"\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `SourceHolder` which has a single field called `source` and methods to get and set its value.\n\n2. What is the expected input for the `source` field?\n- The `source` field is expected to contain a Sigma source code that will be compiled.\n\n3. Why is there a `toIndentedString` method in this class?\n- The `toIndentedString` method is used to convert an object to a string with each line indented by 4 spaces, which is useful for formatting output in a readable way. It is used in the `toString` method to format the output of the `SourceHolder` object.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/SourceHolder.md"}}],["223",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/SpendingProof.java)\n\nThe code defines a Java class called `SpendingProof` which represents a spending proof for a transaction input. The class has two instance variables: `proofBytes` and `extension`. `proofBytes` is a string that represents the spending proof in bytes. `extension` is a map of key-value pairs that represent variables to be put into context. \n\nThe class has getter and setter methods for both instance variables. The `getProofBytes()` method returns the `proofBytes` instance variable, while the `getExtension()` method returns the `extension` instance variable. The `setProofBytes()` and `setExtension()` methods set the values of the `proofBytes` and `extension` instance variables respectively. \n\nThe class also has an `equals()` method that compares two `SpendingProof` objects for equality based on their `proofBytes` and `extension` instance variables. The `hashCode()` method returns a hash code for the `SpendingProof` object based on its `proofBytes` and `extension` instance variables. The `toString()` method returns a string representation of the `SpendingProof` object.\n\nThis class is part of the Ergo Node API and is used to represent spending proofs for transaction inputs. It can be used in conjunction with other classes in the Ergo Node API to build and manipulate transactions. For example, the `SpendingProof` class can be used to create a spending proof for a transaction input, which can then be added to a transaction using other classes in the Ergo Node API. \n\nExample usage:\n\n```\nSpendingProof spendingProof = new SpendingProof();\nspendingProof.setProofBytes(\"proofBytes\");\nMap<String, String> extension = new HashMap<>();\nextension.put(\"key1\", \"value1\");\nextension.put(\"key2\", \"value2\");\nspendingProof.setExtension(extension);\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a SpendingProof class for transaction input in the Ergo Node API.\n\n2. What is the format of the spending proof bytes?\n- The spending proof bytes are represented as a string.\n\n3. What is the purpose of the extension field?\n- The extension field is a map of variables to be put into context.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/SpendingProof.md"}}],["224",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/StringUtil.java)\n\nThe `StringUtil` class provides two utility methods for working with strings. The first method, `containsIgnoreCase`, takes an array of strings and a value to search for, and returns true if the array contains the value (case-insensitive comparison). If the value is null, the method returns true if any element in the array is also null. This method can be useful for checking if a certain value is present in an array of strings, regardless of case.\n\nExample usage:\n```\nString[] fruits = {\"apple\", \"banana\", \"orange\"};\nboolean containsApple = StringUtil.containsIgnoreCase(fruits, \"Apple\"); // returns true\nboolean containsGrape = StringUtil.containsIgnoreCase(fruits, \"grape\"); // returns false\n```\n\nThe second method, `join`, takes an array of strings and a separator, and returns a string that concatenates all the elements in the array with the separator in between. This method can be useful for constructing strings from arrays of values.\n\nExample usage:\n```\nString[] words = {\"hello\", \"world\", \"!\"};\nString sentence = StringUtil.join(words, \" \"); // returns \"hello world !\"\n```\n\nNote that the `join` method is implemented using a `StringBuilder` to efficiently concatenate the strings. The method also handles the case where the input array is empty, returning an empty string in that case.\n\nOverall, the `StringUtil` class provides simple but useful string manipulation methods that can be used throughout the larger project.\n## Questions: \n 1. What is the purpose of this code file?\n- This code file is a StringUtil class that contains two methods for checking if an array contains a value (with case-insensitive comparison) and joining an array of strings with a separator.\n\n2. Why is the containsIgnoreCase method checking for null values?\n- The containsIgnoreCase method is checking for null values because if both the value and the string in the array are null, it should return true.\n\n3. Why does the join method mention the possibility of being replaced by a utility method from commons-lang or guava?\n- The join method mentions the possibility of being replaced by a utility method from commons-lang or guava because those libraries might have a similar method that can be used instead, and if one of those libraries is added as a dependency, it would be more efficient to use their method instead of this custom implementation.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/StringUtil.md"}}],["225",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/TransactionHintsBag.java)\n\nThe `TransactionHintsBag` class is part of the Ergo Node API and provides a model for prover hints extracted from a transaction. The purpose of this class is to store two lists of `InputHints` objects: `secretHints` and `publicHints`. \n\n`InputHints` objects contain hints for inputs of a transaction, which can be used by a prover to construct a proof of correctness for the transaction. The `secretHints` list contains hints that contain secrets and should not be shared, while the `publicHints` list contains hints that only contain public data and can be shared freely.\n\nThis class provides methods to add and retrieve `InputHints` objects from both lists. The `addSecretHintsItem` and `addPublicHintsItem` methods allow for adding new `InputHints` objects to their respective lists. The `getSecretHints` and `getPublicHints` methods retrieve the entire lists of `InputHints` objects.\n\nThe class also provides methods for overriding the default `equals`, `hashCode`, and `toString` methods. The `equals` method compares two `TransactionHintsBag` objects for equality based on the equality of their `secretHints` and `publicHints` lists. The `hashCode` method returns a hash code value for the object based on the hash codes of its `secretHints` and `publicHints` lists. The `toString` method returns a string representation of the object, including its `secretHints` and `publicHints` lists.\n\nThis class can be used in the larger Ergo Node API project to represent prover hints extracted from a transaction. It can be used to store and retrieve `InputHints` objects for inputs of a transaction, and to distinguish between hints that contain secrets and hints that only contain public data.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `TransactionHintsBag` that contains two lists of `InputHints` objects, one for secret hints and one for public hints, extracted from a transaction.\n\n2. What is the expected input and output of this code?\n- This code does not have any input or output, as it only defines a class and its properties and methods.\n\n3. What is the significance of the `InputHints` class?\n- The `InputHints` class is used to represent hints extracted from a transaction, which can be used to help construct a proof of correctness for the transaction. The `TransactionHintsBag` class contains two lists of `InputHints` objects, one for secret hints and one for public hints.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/TransactionHintsBag.md"}}],["226",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/TransactionSigningRequest.java)\n\nThe `TransactionSigningRequest` class is part of the Ergo Node API and is used to request the signing of a transaction with provided secrets. This class is generated automatically by the Swagger code generator program and should not be edited manually. \n\nThe `TransactionSigningRequest` class has five properties: `tx`, `inputsRaw`, `dataInputsRaw`, `hints`, and `secrets`. \n\nThe `tx` property is of type `UnsignedErgoTransaction` and is required. It represents the unsigned transaction that needs to be signed. \n\nThe `inputsRaw` property is an optional list of inputs to be used in serialized form. \n\nThe `dataInputsRaw` property is also an optional list of inputs to be used in serialized form. \n\nThe `hints` property is of type `TransactionHintsBag` and is optional. It represents a bag of hints that can be used to optimize the signing process. \n\nThe `secrets` property is of type `TransactionSigningRequestSecrets` and is required. It represents the secrets that will be used to sign the transaction. \n\nThe `TransactionSigningRequest` class has methods to set and get the values of its properties. For example, the `tx` property can be set using the `tx(UnsignedErgoTransaction tx)` method and retrieved using the `getTx()` method. \n\nThis class can be used in the larger project to request the signing of a transaction with provided secrets. An example usage of this class would be to create an instance of `TransactionSigningRequest` with the required properties set and then pass it to a method that will sign the transaction. \n\nOverall, the `TransactionSigningRequest` class is an important part of the Ergo Node API and is used to request the signing of a transaction with provided secrets.\n## Questions: \n 1. What is the purpose of this code?\n- This code is a request to sign a transaction with secrets provided.\n\n2. What dependencies does this code have?\n- This code has dependencies on the following libraries: `java.util`, `com.google.gson`, `io.swagger.v3.oas.annotations`, and `org.ergoplatform.restapi.client`.\n\n3. What is the expected input and output of this code?\n- The expected input is an `UnsignedErgoTransaction` object and optional lists of inputs and data inputs in serialized form. The expected output is a signed transaction.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/TransactionSigningRequest.md"}}],["227",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/TransactionSigningRequestSecrets.java)\n\nThe code defines a Java class called `TransactionSigningRequestSecrets` that represents secrets used for signing transactions in the Ergo platform. The class has two instance variables: `dlog` and `dht`, both of which are lists of strings and `DhtSecret` objects respectively. \n\nThe `dlog` variable represents a sequence of secret exponents (DLOG secrets) used for signing transactions. The `dht` variable represents a sequence of secret Diffie-Hellman tuple exponents (DHT secrets) used for signing transactions. \n\nThe class provides methods for setting and getting the values of these instance variables. The `addDlogItem` and `addDhtItem` methods allow for adding new items to the `dlog` and `dht` lists respectively. \n\nThe class also provides methods for overriding the `equals`, `hashCode`, and `toString` methods inherited from the `Object` class. These methods are used for comparing instances of the `TransactionSigningRequestSecrets` class, generating hash codes for instances of the class, and generating string representations of instances of the class respectively.\n\nThis class is likely used in the larger Ergo platform project to represent the secrets used for signing transactions. It can be instantiated and used to store and retrieve DLOG and DHT secrets for signing transactions. \n\nExample usage:\n\n```\nTransactionSigningRequestSecrets secrets = new TransactionSigningRequestSecrets();\nsecrets.addDlogItem(\"secret1\");\nsecrets.addDhtItem(new DhtSecret(\"secret2\", \"secret3\"));\nSystem.out.println(secrets.getDlog()); // prints [\"secret1\"]\nSystem.out.println(secrets.getDht()); // prints [DhtSecret(secret1, secret2)]\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `TransactionSigningRequestSecrets` that contains lists of secret exponents and Diffie-Hellman tuple exponents used for signing.\n\n2. What dependencies does this code have?\n- This code depends on the `com.google.gson` and `io.swagger.v3.oas.annotations` libraries.\n\n3. Can the lists of secrets be modified after they are set?\n- Yes, the `dlog` and `dht` lists can be modified after they are set using the `addDlogItem` and `addDhtItem` methods, respectively.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/TransactionSigningRequestSecrets.md"}}],["228",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Transactions.java)\n\nThis code defines a Java class called `Transactions` which extends the `java.util.ArrayList` class and represents a list of Ergo transactions. The purpose of this class is to provide a convenient way to work with a collection of Ergo transactions in Java code. \n\nThe class includes methods to check for equality and calculate a hash code based on the contents of the list. It also includes a `toString()` method that returns a string representation of the list. \n\nThis class is generated automatically by the Swagger code generator program, which is a tool that generates client libraries and server stubs from OpenAPI specifications. The `@Schema` annotation is used to provide a description of the class for the OpenAPI specification. \n\nIn the larger project, this class can be used to represent a list of Ergo transactions returned by the Ergo Node API. For example, if a Java application needs to retrieve a list of transactions from the Ergo Node API, it can use the `Transactions` class to represent that list. \n\nHere is an example of how this class might be used in Java code:\n\n```\nimport org.ergoplatform.restapi.client.Transactions;\nimport org.ergoplatform.restapi.client.ErgoTransaction;\n\n// Retrieve a list of Ergo transactions from the API\nList<ErgoTransaction> transactionList = api.getTransactions();\n\n// Create a Transactions object from the list\nTransactions transactions = new Transactions();\ntransactions.addAll(transactionList);\n\n// Print out the list of transactions\nSystem.out.println(transactions.toString());\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a class called `Transactions` which extends `java.util.ArrayList<ErgoTransaction>` and provides methods for converting the object to a string and checking for equality.\n\n2. What is the relationship between `Transactions` and `ErgoTransaction`?\n- `Transactions` is a list of `ErgoTransaction` objects, as specified by the line `public class Transactions extends java.util.ArrayList<ErgoTransaction>`.\n\n3. Why is there a comment at the beginning of the code mentioning Swagger?\n- The comment mentions Swagger because this class was auto-generated by the Swagger code generator program, as indicated by the line `NOTE: This class is auto generated by the swagger code generator program.`.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/Transactions.md"}}],["229",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/TransactionsApi.java)\n\nThe `TransactionsApi` interface in the `org.ergoplatform.restapi.client` package provides methods for interacting with the Ergo blockchain's transaction-related functionality. \n\nThe `checkTransaction` method checks whether an Ergo transaction is valid and its inputs are in the UTXO set without sending it over the network. It takes an `ErgoTransaction` object as input and returns the transaction identifier if the transaction passes the checks.\n\nThe `getExpectedWaitTime` method returns the expected wait time for a transaction with a specified fee and size. It takes the transaction fee (in nanoErgs) and size (in bytes) as input and returns the expected wait time in milliseconds.\n\nThe `getFeeHistogram` method returns a histogram of the wait time and the number of transactions and sum of fees for transactions in the mempool. It takes the number of bins in the histogram and the maximal wait time in milliseconds as input and returns a `FeeHistogram` object.\n\nThe `getRecommendedFee` method returns the recommended fee (in nanoErgs) for a transaction with a specified size (in bytes) to be processed in a specified time (in minutes). It takes the maximum transaction wait time and transaction size as input and returns the recommended fee.\n\nThe `getUnconfirmedTransactions` method returns the current pool of unconfirmed transactions. It takes the number of items in the list to return and the number of items in the list to skip as input and returns a `Transactions` object.\n\nThe `getUnconfirmedTransactionById` method returns an unconfirmed transaction from the pool by transaction ID. It takes the transaction ID as input and returns an `ErgoTransaction` object.\n\nThe `getUnconfirmedTransactionsByErgoTree` method finds unconfirmed transactions by ErgoTree hex of one of its output or input boxes (if present in UtxoState). It takes the ErgoTree hex representation with surrounding quotes, the number of items in the list to return, and the number of items in the list to skip as input and returns a `Transactions` object.\n\nThe `sendTransaction` method submits an Ergo transaction to the unconfirmed pool to send it over the network. It takes an `ErgoTransaction` object as input and returns the transaction identifier.\n\nOverall, this interface provides a set of methods for interacting with Ergo transactions, including checking transaction validity, getting expected wait times and recommended fees, and submitting transactions to the network. These methods can be used in the larger Ergo project to build applications that interact with the Ergo blockchain. \n\nExample usage:\n\n```\n// create a Retrofit instance\nRetrofit retrofit = new Retrofit.Builder()\n    .baseUrl(\"https://ergo-node.com/api/v1/\")\n    .addConverterFactory(GsonConverterFactory.create())\n    .build();\n\n// create an instance of the TransactionsApi interface\nTransactionsApi transactionsApi = retrofit.create(TransactionsApi.class);\n\n// check a transaction\nErgoTransaction transaction = new ErgoTransaction();\n// set the transaction inputs and outputs\nCall<String> call = transactionsApi.checkTransaction(transaction);\nString transactionId = call.execute().body();\n\n// get the expected wait time for a transaction\nint fee = 1000000; // 1 Erg\nint size = 1000; // 1 KB\nCall<Long> call = transactionsApi.getExpectedWaitTime(fee, size);\nlong waitTime = call.execute().body();\n\n// get the fee histogram\nint bins = 10;\nlong maxtime = 60000;\nCall<FeeHistogram> call = transactionsApi.getFeeHistogram(bins, maxtime);\nFeeHistogram histogram = call.execute().body();\n\n// get the recommended fee for a transaction\nint waitTime = 10; // 10 minutes\nint size = 1000; // 1 KB\nCall<Integer> call = transactionsApi.getRecommendedFee(waitTime, size);\nint fee = call.execute().body();\n\n// get the current pool of unconfirmed transactions\nint limit = 50;\nint offset = 0;\nCall<Transactions> call = transactionsApi.getUnconfirmedTransactions(limit, offset);\nTransactions transactions = call.execute().body();\n\n// get an unconfirmed transaction by ID\nString txId = \"12345\";\nCall<ErgoTransaction> call = transactionsApi.getUnconfirmedTransactionById(txId);\nErgoTransaction transaction = call.execute().body();\n\n// find unconfirmed transactions by ErgoTree hex\nString ergoTreeHex = \"\\\"0008cd...\\\"\";\nint limit = 50;\nint offset = 0;\nCall<Transactions> call = transactionsApi.getUnconfirmedTransactionsByErgoTree(ergoTreeHex, limit, offset);\nTransactions transactions = call.execute().body();\n\n// send a transaction\nErgoTransaction transaction = new ErgoTransaction();\n// set the transaction inputs and outputs\nCall<String> call = transactionsApi.sendTransaction(transaction);\nString transactionId = call.execute().body();\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines an interface for interacting with Ergo transactions through an API.\n\n2. What are the parameters for the `getFeeHistogram` method?\n- The `getFeeHistogram` method takes two optional parameters: `bins`, which specifies the number of bins in the histogram (default is 10), and `maxtime`, which specifies the maximal wait time in milliseconds (default is 60000).\n\n3. What is the expected return type of the `checkTransaction` method?\n- The `checkTransaction` method returns a `Call` object that wraps a `String` representing the transaction identifier if the transaction passes the validity checks.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/TransactionsApi.md"}}],["230",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/UnsignedErgoTransaction.java)\n\nThe `UnsignedErgoTransaction` class is part of the Ergo Node API and is used to represent an unsigned Ergo transaction. This class is generated automatically by the Swagger code generator program and should not be edited manually. \n\nThe purpose of this class is to provide a model for an unsigned Ergo transaction that can be used by other parts of the Ergo platform. It contains four fields: `id`, `inputs`, `dataInputs`, and `outputs`. \n\nThe `id` field is a string that represents the ID of the transaction. The `inputs` field is a list of `ErgoTransactionUnsignedInput` objects that represent the unsigned inputs of the transaction. The `dataInputs` field is a list of `ErgoTransactionDataInput` objects that represent the data inputs of the transaction. Finally, the `outputs` field is a list of `ErgoTransactionOutput` objects that represent the outputs of the transaction.\n\nThis class can be used to create an unsigned Ergo transaction that can be signed and broadcasted to the Ergo network. Here is an example of how this class can be used:\n\n```\nUnsignedErgoTransaction transaction = new UnsignedErgoTransaction();\ntransaction.setId(\"12345\");\ntransaction.addInputsItem(new ErgoTransactionUnsignedInput());\ntransaction.addDataInputsItem(new ErgoTransactionDataInput());\ntransaction.addOutputsItem(new ErgoTransactionOutput());\n```\n\nIn this example, a new `UnsignedErgoTransaction` object is created and its `id`, `inputs`, `dataInputs`, and `outputs` fields are set. The `addInputsItem`, `addDataInputsItem`, and `addOutputsItem` methods are used to add new inputs, data inputs, and outputs to the transaction, respectively.\n\nOverall, the `UnsignedErgoTransaction` class provides a useful model for representing an unsigned Ergo transaction and can be used by other parts of the Ergo platform to create and broadcast transactions.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class for an unsigned Ergo transaction, including its inputs, data inputs, and outputs.\n\n2. What dependencies does this code have?\n- This code depends on the Gson library for JSON serialization and deserialization, and the io.swagger.v3.oas.annotations library for OpenAPI annotations.\n\n3. Can the properties of an UnsignedErgoTransaction object be null?\n- Yes, the id, inputs, dataInputs, and outputs properties can all be null.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/UnsignedErgoTransaction.md"}}],["231",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/UtilsApi.java)\n\nThe `UtilsApi` interface is part of the `ergo-appkit` project and provides a set of utility functions that can be used to interact with the Ergo blockchain. The interface defines six methods that can be used to perform various operations such as converting an address to its raw representation, checking the validity of an address, generating an Ergo address from an ErgoTree, generating a random seed, returning the Blake2b hash of a message, and generating a Pay-To-Public-Key address from a hex-encoded raw public key.\n\nThe `addressToRaw` method takes an address as input and returns its raw representation in hex-encoded serialized curve point format. This method can be used to extract the public key from an address.\n\nThe `checkAddressValidity` method takes an address as input and returns an `AddressValidity` object that indicates whether the address is valid or not. This method can be used to validate an address before using it in a transaction.\n\nThe `ergoTreeToAddress` method takes an ErgoTree in hex-encoded format as input and returns the corresponding Ergo address. This method can be used to derive an address from an ErgoTree.\n\nThe `getRandomSeed` method returns a random seed of 32 bytes. This method can be used to generate a random seed for use in a transaction.\n\nThe `getRandomSeedWithLength` method takes a length in bytes as input and returns a random seed of the specified length. This method can be used to generate a random seed of a specific length for use in a transaction.\n\nThe `hashBlake2b` method takes a message as input and returns its Blake2b hash. This method can be used to compute the hash of a message.\n\nThe `rawToAddress` method takes a hex-encoded raw public key as input and returns the corresponding Pay-To-Public-Key address. This method can be used to generate an address from a raw public key.\n\nOverall, the `UtilsApi` interface provides a set of utility functions that can be used to interact with the Ergo blockchain. These functions can be used to perform various operations such as validating addresses, generating random seeds, computing hashes, and deriving addresses from ErgoTrees and raw public keys.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines an interface for making API calls related to various utility functions in the Ergo blockchain platform, such as converting addresses and generating random seeds.\n\n2. What external libraries or dependencies does this code use?\n- This code uses the Retrofit2 and OkHttp3 libraries for making HTTP requests and handling responses.\n\n3. What API endpoints are available through this interface?\n- This interface provides methods for calling the following API endpoints: `utils/addressToRaw/{address}`, `utils/address/{address}`, `utils/ergoTreeToAddress/{ergoTreeHex}`, `utils/seed`, `utils/seed/{length}`, `utils/hash/blake2b`, and `utils/rawToAddress/{pubkeyHex}`.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/UtilsApi.md"}}],["232",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/UtxoApi.java)\n\nThe code above is an interface for interacting with the UTXO (Unspent Transaction Output) API of the Ergo blockchain platform. The interface provides methods for retrieving information about boxes (i.e., unspent transaction outputs) on the Ergo blockchain.\n\nThe `UtxoApi` interface has five methods, each of which corresponds to a different endpoint on the Ergo UTXO API. The first method, `genesisBoxes()`, retrieves all the genesis boxes (i.e., boxes that existed before the very first block) on the Ergo blockchain. The method returns a `Call` object that can be used to execute the API request and retrieve the response.\n\nThe second method, `getBoxById()`, retrieves the contents of a box with a given ID. The method takes a `boxId` parameter, which is the ID of the box to retrieve, and returns a `Call` object that can be used to execute the API request and retrieve the response.\n\nThe third method, `getBoxByIdBinary()`, retrieves the serialized contents of a box with a given ID. The method takes a `boxId` parameter, which is the ID of the box to retrieve, and returns a `Call` object that can be used to execute the API request and retrieve the response.\n\nThe fourth method, `getBoxWithPoolById()`, retrieves the contents of a box with a given ID from both the UTXO set and the mempool. The method takes a `boxId` parameter, which is the ID of the box to retrieve, and returns a `Call` object that can be used to execute the API request and retrieve the response.\n\nThe fifth method, `getBoxWithPoolByIdBinary()`, retrieves the serialized contents of a box with a given ID from both the UTXO set and the mempool. The method takes a `boxId` parameter, which is the ID of the box to retrieve, and returns a `Call` object that can be used to execute the API request and retrieve the response.\n\nOverall, this interface provides a convenient way to interact with the Ergo UTXO API and retrieve information about boxes on the Ergo blockchain. Here is an example of how to use the `getBoxById()` method to retrieve the contents of a box with ID \"abc123\":\n\n```\nUtxoApi utxoApi = retrofit.create(UtxoApi.class);\nCall<ErgoTransactionOutput> call = utxoApi.getBoxById(\"abc123\");\nResponse<ErgoTransactionOutput> response = call.execute();\nErgoTransactionOutput boxContents = response.body();\n```\n## Questions: \n 1. What is the purpose of this code?\n    \n    This code defines an interface for making API calls to retrieve information about unspent transaction outputs (UTXOs) in the Ergo blockchain.\n\n2. What external libraries or dependencies does this code use?\n    \n    This code uses the Retrofit2 and OkHttp3 libraries for making HTTP requests and handling responses.\n\n3. What specific API endpoints are available through this interface?\n    \n    This interface provides methods for retrieving information about UTXOs by ID, including their contents and serialized data, as well as a method for retrieving all genesis boxes. There are also methods for retrieving UTXOs from both the UTXO set and mempool.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/UtxoApi.md"}}],["233",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/WalletApi.java)\n\nThe `WalletApi` interface in the `org.ergoplatform.restapi.client` package is part of the Ergo Appkit project and provides a set of API methods to interact with the Ergo wallet. These methods allow developers to perform various wallet-related operations such as creating, restoring, locking, and unlocking wallets, managing wallet addresses and keys, and handling wallet transactions.\n\nSome key methods in the `WalletApi` interface include:\n\n- `addBox(ScanIdsBox body)`: Adds a box to scans and writes it to the database if it's not already there.\n- `checkSeed(Body2 body)`: Checks if the mnemonic phrase corresponds to the wallet seed.\n- `getWalletStatus()`: Retrieves the wallet status.\n- `walletAddresses()`: Gets wallet addresses.\n- `walletBalances()`: Gets the total amount of confirmed Ergo tokens and assets.\n- `walletBoxes(Integer minConfirmations, Integer minInclusionHeight)`: Gets a list of all wallet-related boxes, both spent and unspent.\n- `walletInit(Body body)`: Initializes a new wallet with a randomly generated seed.\n- `walletRestore(Body1 body)`: Creates a new wallet from an existing mnemonic seed.\n- `walletLock()`: Locks the wallet.\n- `walletUnlock(Body3 body)`: Unlocks the wallet.\n- `walletTransactionGenerate(RequestsHolder body)`: Generates an arbitrary transaction from an array of requests.\n- `walletTransactionSign(TransactionSigningRequest body)`: Signs an arbitrary unsigned transaction with wallet secrets and provided secrets.\n\nThese methods can be used in the larger project to manage and interact with Ergo wallets, enabling developers to build applications that require wallet functionality. For example, a developer could use the `walletInit()` method to create a new wallet, then use the `walletAddresses()` method to retrieve the wallet's addresses, and finally use the `walletTransactionGenerate()` method to create a new transaction.\n## Questions: \n 1. **Question:** What is the purpose of the `WalletApi` interface?\n   **Answer:** The `WalletApi` interface defines the methods for interacting with the wallet-related REST API endpoints, such as adding a box to scans, checking the wallet seed, extracting hints from a transaction, and managing wallet transactions.\n\n2. **Question:** What are the different types of request bodies used in the `WalletApi` interface?\n   **Answer:** The `WalletApi` interface uses various request bodies such as `ScanIdsBox`, `Body`, `Body1`, `Body2`, `Body3`, `Body4`, `Body5`, `HintExtractionRequest`, `GenerateCommitmentsRequest`, `PaymentRequest`, `RequestsHolder`, `TransactionSigningRequest`, and `BoxesRequestHolder`.\n\n3. **Question:** How are the API methods in the `WalletApi` interface annotated to specify the HTTP method and headers?\n   **Answer:** The API methods in the `WalletApi` interface are annotated using Retrofit2 annotations such as `@GET`, `@POST`, `@Headers`, `@retrofit2.http.Query`, and `@retrofit2.http.Body` to specify the HTTP method, headers, and other request parameters.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/WalletApi.md"}}],["234",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/WalletBox.java)\n\nThe `WalletBox` class is part of the Ergo Node API and is used to represent a box in a wallet. A box is a basic unit of storage in the Ergo blockchain and contains a certain amount of tokens and data. The `WalletBox` class contains information about the box, such as its address, creation and spending transactions, and the number of confirmations it has received.\n\nThe `WalletBox` class has several properties, including `box`, which is an instance of the `ErgoTransactionOutput` class and represents the output of a transaction that created the box. The `confirmationsNum` property is an integer that represents the number of confirmations the box has received. The `address` property is a string that represents the address of the box. The `creationTransaction` and `spendingTransaction` properties are strings that represent the IDs of the transactions that created and spent the box, respectively. The `spendingHeight` and `inclusionHeight` properties are integers that represent the heights of the blocks in which the spending and creation transactions were included, respectively. The `onchain` and `spent` properties are boolean values that indicate whether the box is on the main chain and whether it has been spent, respectively. The `creationOutIndex` property is an integer that represents the index of the output in the transaction that created the box. Finally, the `scans` property is a list of integers that represent the scan identifiers the box relates to.\n\nThe `WalletBox` class provides getters and setters for each of its properties, allowing developers to easily access and modify the information stored in the class. For example, to get the address of a `WalletBox` object, the `getAddress()` method can be called. To set the address of a `WalletBox` object, the `setAddress()` method can be called.\n\nOverall, the `WalletBox` class is an important part of the Ergo Node API and is used to represent a box in a wallet. It provides a convenient way for developers to access and modify the information associated with a box.\n## Questions: \n 1. What is the purpose of the `WalletBox` class?\n- The `WalletBox` class is a model for a box in a wallet, containing information such as its transaction output, address, and spending status.\n\n2. What is the significance of the `onchain` field?\n- The `onchain` field is a boolean flag that indicates whether the box was created on the main chain.\n\n3. What is the purpose of the `scans` field?\n- The `scans` field is a list of scan identifiers that the box relates to. It is not clear from this code what a \"scan\" refers to, so further investigation may be necessary.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/WalletBox.md"}}],["235",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/WalletTransaction.java)\n\nThe `WalletTransaction` class is part of the `ergo-appkit` project and is used to represent a transaction with additional information. This class is generated automatically by the Swagger code generator program and should not be edited manually. \n\nThe `WalletTransaction` class has several properties that describe a transaction, including `id`, `inputs`, `dataInputs`, `outputs`, `inclusionHeight`, `numConfirmations`, `scans`, and `size`. \n\nThe `id` property is a string that uniquely identifies the transaction. The `inputs` property is a list of `ErgoTransactionInput` objects that represent the inputs to the transaction. The `dataInputs` property is a list of `ErgoTransactionDataInput` objects that represent the data inputs to the transaction. The `outputs` property is a list of `ErgoTransactionOutput` objects that represent the outputs of the transaction. \n\nThe `inclusionHeight` property is an integer that represents the height of the block in which the transaction was included. The `numConfirmations` property is an integer that represents the number of confirmations the transaction has received. The `scans` property is a list of integers that represent the scan identifiers the transaction relates to. Finally, the `size` property is an integer that represents the size of the transaction in bytes.\n\nThis class can be used to represent a transaction in the Ergo blockchain and can be used in conjunction with other classes in the `ergo-appkit` project to build applications that interact with the Ergo blockchain. For example, a developer could use this class to create a wallet application that displays transaction information to the user. \n\nHere is an example of how to create a `WalletTransaction` object:\n\n```\nErgoTransactionInput input = new ErgoTransactionInput();\nErgoTransactionDataInput dataInput = new ErgoTransactionDataInput();\nErgoTransactionOutput output = new ErgoTransactionOutput();\n\nList<ErgoTransactionInput> inputs = new ArrayList<>();\ninputs.add(input);\n\nList<ErgoTransactionDataInput> dataInputs = new ArrayList<>();\ndataInputs.add(dataInput);\n\nList<ErgoTransactionOutput> outputs = new ArrayList<>();\noutputs.add(output);\n\nWalletTransaction transaction = new WalletTransaction()\n    .id(\"transactionId\")\n    .inputs(inputs)\n    .dataInputs(dataInputs)\n    .outputs(outputs)\n    .inclusionHeight(20998)\n    .numConfirmations(1)\n    .scans(Arrays.asList(1, 2, 3))\n    .size(100);\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `WalletTransaction` that represents a transaction with additional information such as inclusion height, number of confirmations, and scan identifiers.\n\n2. What external libraries or dependencies does this code use?\n- This code uses the `com.google.gson` and `io.swagger.v3.oas.annotations` libraries.\n\n3. What are some of the key attributes and methods of the `WalletTransaction` class?\n- Some key attributes of the `WalletTransaction` class include `id`, `inputs`, `dataInputs`, `outputs`, `inclusionHeight`, `numConfirmations`, `scans`, and `size`. Some key methods include getters and setters for these attributes, as well as `addInputsItem()`, `addDataInputsItem()`, and `addOutputsItem()` methods for adding items to the corresponding lists.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/WalletTransaction.md"}}],["236",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/WorkMessage.java)\n\nThe `WorkMessage` class is part of the Ergo Node API and provides a model for block candidate related data that can be used by an external miner to perform work. This class contains five fields: `msg`, `b`, `h`, `pk`, and `proof`. \n\nThe `msg` field is a string that represents the base16-encoded block header bytes without PoW solution. The `b` field is a BigInteger that represents the work target value. The `h` field is an integer that represents the work target value. The `pk` field is a string that represents the base16-encoded miner public key. The `proof` field is an instance of the `ProofOfUpcomingTransactions` class, which is another model class in the Ergo Node API.\n\nThis class provides getter and setter methods for each field, allowing the user to set and retrieve the values of each field. Additionally, the class provides methods for converting the object to a string and for checking equality between two `WorkMessage` objects.\n\nThis class can be used in the larger project by creating instances of `WorkMessage` and passing them to other parts of the Ergo Node API that require block candidate related data for external miners to perform work. For example, a miner could use an instance of `WorkMessage` to perform work on a block candidate and submit the result to the Ergo network. \n\nExample usage:\n\n```\nWorkMessage workMessage = new WorkMessage()\n    .msg(\"0350e25cee8562697d55275c96bb01b34228f9bd68fd9933f2a25ff195526864f5\")\n    .b(new BigInteger(\"987654321\"))\n    .h(12345)\n    .pk(\"0350e25cee8562697d55275c96bb01b34228f9bd68fd9933f2a25ff195526864f5\")\n    .proof(new ProofOfUpcomingTransactions());\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines a Java class called `WorkMessage` that contains block candidate related data for external miners to perform work.\n\n2. What are the required fields for a `WorkMessage` object?\n- A `WorkMessage` object requires a `msg` field (base16-encoded block header bytes without PoW solution), a `b` field (work target value), an `h` field (work target value), a `pk` field (base16-encoded miner public key), and a `proof` field (an object of type `ProofOfUpcomingTransactions`).\n\n3. What is the purpose of the `equals`, `hashCode`, and `toString` methods in this class?\n- The `equals` method compares two `WorkMessage` objects for equality based on their `msg`, `b`, `pk`, and `proof` fields.\n- The `hashCode` method generates a hash code for a `WorkMessage` object based on its `msg`, `b`, `pk`, and `proof` fields.\n- The `toString` method generates a string representation of a `WorkMessage` object that includes its `msg`, `b`, `pk`, and `proof` fields.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/WorkMessage.md"}}],["237",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/auth/ApiKeyAuth.java)\n\nThe `ApiKeyAuth` class is responsible for adding an API key to outgoing HTTP requests. It implements the `Interceptor` interface from the OkHttp library, which allows it to intercept and modify requests before they are sent. \n\nThe class takes two arguments in its constructor: `location` and `paramName`. `location` specifies where the API key should be added - either as a query parameter or a header. `paramName` specifies the name of the query parameter or header that should be used to send the API key.\n\nThe API key itself is stored as a private field in the class, and can be set using the `setApiKey` method. The `getApiKey` method can be used to retrieve the current API key.\n\nThe `intercept` method is where the actual modification of the request takes place. If the `location` is set to \"query\", the API key is added as a query parameter to the request URL. If the URL already has a query string, the API key is appended as an additional parameter. If the `location` is set to \"header\", the API key is added as a header to the request.\n\nThis class can be used in the larger project to authenticate requests to an API that requires an API key. By adding an instance of this class to an OkHttp client, all outgoing requests will automatically include the API key. For example:\n\n```\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(new ApiKeyAuth(\"header\", \"X-Api-Key\"))\n        .build();\n\nRequest request = new Request.Builder()\n        .url(\"https://api.example.com/some-endpoint\")\n        .build();\n\nResponse response = client.newCall(request).execute();\n```\n## Questions: \n 1. What is the purpose of this code?\n    \n    This code defines a class called `ApiKeyAuth` that implements the `Interceptor` interface from the OkHttp library. It is used to add an API key to outgoing HTTP requests either as a query parameter or a header.\n\n2. What parameters does the `ApiKeyAuth` constructor take?\n    \n    The `ApiKeyAuth` constructor takes two parameters: `location`, which is a string indicating whether the API key should be added as a query parameter or a header, and `paramName`, which is a string indicating the name of the query parameter or header that the API key should be added to.\n\n3. What does the `intercept` method do?\n    \n    The `intercept` method is called by OkHttp when an HTTP request is being sent. It checks the `location` parameter to determine whether the API key should be added as a query parameter or a header, and then modifies the request accordingly. If the `location` is \"query\", it adds the API key as a query parameter to the request URL. If the `location` is \"header\", it adds the API key as a header to the request.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/auth/ApiKeyAuth.md"}}],["238",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/org/ergoplatform/restapi/client/auth/HttpBasicAuth.java)\n\nThe `HttpBasicAuth` class in the `org.ergoplatform.restapi.client.auth` package is responsible for adding HTTP Basic Authentication headers to outgoing requests made by the `OkHttpClient` instance. This class implements the `Interceptor` interface from the `okhttp3` library, which allows it to intercept and modify outgoing requests before they are sent to the server.\n\nThe class has three instance variables: `username`, `password`, and `credentials`. The `username` and `password` variables store the username and password for the Basic Authentication header, respectively. The `credentials` variable is a convenience method for setting both the `username` and `password` at the same time.\n\nThe `intercept` method is the heart of this class. It takes an `Interceptor.Chain` object as a parameter, which represents the chain of interceptors that will be applied to the request. It then retrieves the original request from the chain and checks if it already has an Authorization header. If it does not, it creates a new request with the Authorization header set to the Basic Authentication credentials using the `Credentials.basic` method from the `okhttp3` library. Finally, it returns the result of calling `chain.proceed(request)`, which sends the modified request down the interceptor chain.\n\nThis class can be used in conjunction with an `OkHttpClient` instance to add Basic Authentication headers to outgoing requests. Here's an example of how to use it:\n\n```\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(new HttpBasicAuth())\n        .build();\n\nRequest request = new Request.Builder()\n        .url(\"https://example.com/api\")\n        .build();\n\nResponse response = client.newCall(request).execute();\n```\n\nIn this example, we create a new `OkHttpClient` instance and add an instance of `HttpBasicAuth` as an interceptor. We then create a new `Request` object with the desired URL and send it using the `OkHttpClient`. The `HttpBasicAuth` interceptor will automatically add the Basic Authentication header to the request before it is sent.\n## Questions: \n 1. What is the purpose of this code?\n    \n    This code defines a class called `HttpBasicAuth` that implements the `Interceptor` interface from the OkHttp library. It adds HTTP Basic authentication credentials to outgoing requests if they don't already have them.\n\n2. How does this code handle requests that already have authorization headers?\n    \n    If the request already has an authorization header (e.g. for Basic auth), the code does nothing and simply proceeds with the request as-is.\n\n3. What library or libraries does this code depend on?\n    \n    This code depends on the OkHttp library for handling HTTP requests and responses.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/auth/HttpBasicAuth.md"}}],["239",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/java-client-generated/src/main/java/org/ergoplatform/restapi/client/auth)\n\nThe `org.ergoplatform.restapi.client.auth` package contains two classes, `ApiKeyAuth` and `HttpBasicAuth`, which are responsible for adding authentication information to outgoing HTTP requests made by the `OkHttpClient` instance. Both classes implement the `Interceptor` interface from the `okhttp3` library, allowing them to intercept and modify requests before they are sent to the server.\n\nThe `ApiKeyAuth` class is used for APIs that require an API key for authentication. It takes two arguments in its constructor: `location` and `paramName`. `location` specifies where the API key should be added - either as a query parameter or a header. `paramName` specifies the name of the query parameter or header that should be used to send the API key. The API key itself is stored as a private field in the class and can be set using the `setApiKey` method. The `intercept` method modifies the request by adding the API key to the specified location.\n\nExample usage of `ApiKeyAuth`:\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(new ApiKeyAuth(\"header\", \"X-Api-Key\"))\n        .build();\n\nRequest request = new Request.Builder()\n        .url(\"https://api.example.com/some-endpoint\")\n        .build();\n\nResponse response = client.newCall(request).execute();\n```\n\nThe `HttpBasicAuth` class is used for APIs that require HTTP Basic Authentication. It has three instance variables: `username`, `password`, and `credentials`. The `intercept` method retrieves the original request from the interceptor chain and checks if it already has an Authorization header. If it does not, it creates a new request with the Authorization header set to the Basic Authentication credentials using the `Credentials.basic` method from the `okhttp3` library.\n\nExample usage of `HttpBasicAuth`:\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(new HttpBasicAuth())\n        .build();\n\nRequest request = new Request.Builder()\n        .url(\"https://example.com/api\")\n        .build();\n\nResponse response = client.newCall(request).execute();\n```\n\nIn both examples, we create a new `OkHttpClient` instance and add an instance of the respective authentication interceptor. We then create a new `Request` object with the desired URL and send it using the `OkHttpClient`. The authentication interceptor will automatically add the required authentication information to the request before it is sent.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/client/auth/summary.md"}}],["240",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/java-client-generated/src/main/java/org/ergoplatform/restapi)\n\nThe `.autodoc/docs/json/java-client-generated/src/main/java/org/ergoplatform/restapi` folder contains the Java classes that are generated from the Ergo Platform REST API specification. These classes are used to interact with the Ergo blockchain through the REST API, allowing developers to easily integrate Ergo functionality into their Java applications.\n\n### Files\n\n1. `ApiClient.java`: This file contains the `ApiClient` class, which is responsible for managing the communication with the Ergo REST API. It handles HTTP requests, authentication, and serialization/deserialization of JSON data.\n\n2. `ApiException.java`: This file contains the `ApiException` class, which is a custom exception class used to handle errors that occur during API calls. It provides detailed information about the error, such as the HTTP status code and the error message.\n\n3. `Configuration.java`: This file contains the `Configuration` class, which is used to configure the `ApiClient`. It allows developers to set various options, such as the API base path, authentication credentials, and timeouts.\n\n4. `GsonAdaptersModel.java`: This file contains the `GsonAdaptersModel` class, which is used to register custom Gson type adapters for the serialization and deserialization of JSON data. This ensures that the Java classes can be correctly mapped to the JSON data returned by the Ergo REST API.\n\n5. `Pair.java`: This file contains the `Pair` class, which is a simple utility class used to store a pair of values. It is used internally by the `ApiClient` class to manage query parameters and form data.\n\n6. `ProgressRequestBody.java` and `ProgressResponseBody.java`: These files contain the `ProgressRequestBody` and `ProgressResponseBody` classes, which are used to monitor the progress of file uploads and downloads during API calls. They extend the OkHttp `RequestBody` and `ResponseBody` classes and provide progress callbacks.\n\n### Usage\n\nTo use the Java client generated from the Ergo REST API, you would first create an instance of the `ApiClient` class and configure it using the `Configuration` class. For example:\n\n```java\nConfiguration config = new Configuration();\nconfig.setApiKey(\"your_api_key\");\nconfig.setBasePath(\"https://api.ergoplatform.com\");\n\nApiClient apiClient = new ApiClient(config);\n```\n\nNext, you would use the `ApiClient` instance to make API calls. For example, to get the balance of an address:\n\n```java\nString address = \"9f4QF8AD1nQ3nJahQVkM6c8qiuyhM1i8Kgh8Dt6hP8Xf8gsgg5u\";\nApiResponse<Balance> response = apiClient.invokeAPI(\"/addresses/\" + address + \"/balance\", \"GET\", null, null, null, null, null, \"application/json\", null, new TypeToken<Balance>(){}.getType());\n\nBalance balance = response.getData();\nSystem.out.println(\"Balance: \" + balance.getConfirmed().getNanoErgs());\n```\n\nThis code snippet demonstrates how to configure the `ApiClient`, make an API call to get the balance of an address, and extract the balance information from the response.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/restapi/summary.md"}}],["241",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/java-client-generated/src/main/java/org/ergoplatform)\n\nThe `.autodoc/docs/json/java-client-generated/src/main/java/org/ergoplatform` folder contains essential components for interacting with the Ergo blockchain explorer API and the Ergo Platform REST API. These components handle JSON serialization and deserialization, formatting collections of strings, adding authentication information to HTTP requests, and managing communication with the Ergo REST API.\n\n### Ergo Blockchain Explorer API\n\nThe `explorer` subfolder provides components for interacting with the Ergo blockchain explorer API. The `DefaultApi.java` interface offers methods for fetching balances, transactions, blocks, and tokens. For example:\n\n```java\nDefaultApi api = new DefaultApi();\nString address = \"9f4QF8AD1nQ3nJahQVkM6c5jmBvG4Df6MAzvp8uss6R4XNt8vGt\";\nApiResponse<ConfirmedBalance> response = api.getApiV1AddressesP1BalanceConfirmed(address, 10);\n```\n\nThe `ExplorerApiClient.java` class is a wrapper around the Retrofit library, providing a convenient way to interact with a RESTful API. The `JSON.java` class is responsible for creating and configuring a `Gson` object for JSON serialization and deserialization. The `StringUtil.java` class provides utility methods for working with arrays of strings.\n\nThe `auth` subfolder contains classes for adding authentication information to HTTP requests made by the Ergo Explorer client, such as `ApiKeyAuth` and `HttpBasicAuth`.\n\n### Ergo Platform REST API\n\nThe `restapi` subfolder contains Java classes generated from the Ergo Platform REST API specification. These classes are used to interact with the Ergo blockchain through the REST API, allowing developers to easily integrate Ergo functionality into their Java applications.\n\nThe `ApiClient.java` class manages communication with the Ergo REST API, handling HTTP requests, authentication, and JSON serialization/deserialization. The `Configuration.java` class is used to configure the `ApiClient`. For example:\n\n```java\nConfiguration config = new Configuration();\nconfig.setApiKey(\"your_api_key\");\nconfig.setBasePath(\"https://api.ergoplatform.com\");\n\nApiClient apiClient = new ApiClient(config);\n```\n\nTo make API calls, you would use the `ApiClient` instance. For example, to get the balance of an address:\n\n```java\nString address = \"9f4QF8AD1nQ3nJahQVkM6c8qiuyhM1i8Kgh8Dt6hP8Xf8gsgg5u\";\nApiResponse<Balance> response = apiClient.invokeAPI(\"/addresses/\" + address + \"/balance\", \"GET\", null, null, null, null, null, \"application/json\", null, new TypeToken<Balance>(){}.getType());\n\nBalance balance = response.getData();\nSystem.out.println(\"Balance: \" + balance.getConfirmed().getNanoErgs());\n```\n\nThis code snippet demonstrates how to configure the `ApiClient`, make an API call to get the balance of an address, and extract the balance information from the response.\n\nOverall, this folder provides essential components for interacting with the Ergo blockchain explorer API and the Ergo Platform REST API, handling JSON serialization and deserialization, formatting collections of strings, adding authentication information to HTTP requests, and managing communication with the Ergo REST API.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/ergoplatform/summary.md"}}],["242",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/java-client-generated/src/main/java/org)\n\nThe `.autodoc/docs/json/java-client-generated/src/main/java/org` folder contains essential components for interacting with the Ergo blockchain explorer API and the Ergo Platform REST API. These components handle JSON serialization and deserialization, formatting collections of strings, adding authentication information to HTTP requests, and managing communication with the Ergo REST API.\n\n### Ergo Blockchain Explorer API\n\nThe `explorer` subfolder provides components for interacting with the Ergo blockchain explorer API. The `DefaultApi.java` interface offers methods for fetching balances, transactions, blocks, and tokens. For example:\n\n```java\nDefaultApi api = new DefaultApi();\nString address = \"9f4QF8AD1nQ3nJahQVkM6c5jmBvG4Df6MAzvp8uss6R4XNt8vGt\";\nApiResponse<ConfirmedBalance> response = api.getApiV1AddressesP1BalanceConfirmed(address, 10);\n```\n\nThe `ExplorerApiClient.java` class is a wrapper around the Retrofit library, providing a convenient way to interact with a RESTful API. The `JSON.java` class is responsible for creating and configuring a `Gson` object for JSON serialization and deserialization. The `StringUtil.java` class provides utility methods for working with arrays of strings.\n\nThe `auth` subfolder contains classes for adding authentication information to HTTP requests made by the Ergo Explorer client, such as `ApiKeyAuth` and `HttpBasicAuth`.\n\n### Ergo Platform REST API\n\nThe `restapi` subfolder contains Java classes generated from the Ergo Platform REST API specification. These classes are used to interact with the Ergo blockchain through the REST API, allowing developers to easily integrate Ergo functionality into their Java applications.\n\nThe `ApiClient.java` class manages communication with the Ergo REST API, handling HTTP requests, authentication, and JSON serialization/deserialization. The `Configuration.java` class is used to configure the `ApiClient`. For example:\n\n```java\nConfiguration config = new Configuration();\nconfig.setApiKey(\"your_api_key\");\nconfig.setBasePath(\"https://api.ergoplatform.com\");\n\nApiClient apiClient = new ApiClient(config);\n```\n\nTo make API calls, you would use the `ApiClient` instance. For example, to get the balance of an address:\n\n```java\nString address = \"9f4QF8AD1nQ3nJahQVkM6c8qiuyhM1i8Kgh8Dt6hP8Xf8gsgg5u\";\nApiResponse<Balance> response = apiClient.invokeAPI(\"/addresses/\" + address + \"/balance\", \"GET\", null, null, null, null, null, \"application/json\", null, new TypeToken<Balance>(){}.getType());\n\nBalance balance = response.getData();\nSystem.out.println(\"Balance: \" + balance.getConfirmed().getNanoErgs());\n```\n\nThis code snippet demonstrates how to configure the `ApiClient`, make an API call to get the balance of an address, and extract the balance information from the response.\n\nOverall, this folder provides essential components for interacting with the Ergo blockchain explorer API and the Ergo Platform REST API, handling JSON serialization and deserialization, formatting collections of strings, adding authentication information to HTTP requests, and managing communication with the Ergo REST API.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/org/summary.md"}}],["243",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/java-client-generated/src/main/java/retrofit2/RetrofitUtil.java)\n\nThe `RetrofitUtil` class in the `ergo-appkit` project provides access to a package-private method called `loadServiceMethod` in the `Retrofit` class. This method is used to bypass the usual proxy generation that doesn't work under Graal native-image. \n\nThe purpose of this class is to allow the invocation of service methods in Retrofit, which is a type-safe HTTP client for Android and Java. The `invokeServiceMethod` method takes in a `Retrofit` instance, a `Method` object representing the service method to be invoked, and an array of arguments to be passed to the method. It then calls the `loadServiceMethod` method on the `Retrofit` instance to obtain a `ServiceMethod` object, which is used to create a `Call` object that can be used to make the HTTP request. \n\nThis class is likely used in the larger project to facilitate communication between the ErgoNodeFacade in the `lib-impl` module and the Ergo blockchain network. The `invokeServiceMethod` method can be used to make HTTP requests to the Ergo blockchain network using Retrofit, which provides a convenient and type-safe way to interact with the network. \n\nHere is an example of how this class might be used in the larger project:\n\n```java\n// create a Retrofit instance\nRetrofit retrofit = new Retrofit.Builder()\n    .baseUrl(\"https://api.ergoplatform.com\")\n    .build();\n\n// get a reference to the ErgoNodeFacade service interface\nErgoNodeFacade ergoNodeFacade = retrofit.create(ErgoNodeFacade.class);\n\n// invoke a service method using RetrofitUtil\nCall<BlockHeader> call = RetrofitUtil.invokeServiceMethod(retrofit, \n    ErgoNodeFacade.class.getMethod(\"getBlockHeaderById\", String.class), \n    new Object[] { \"12345\" });\n\n// execute the HTTP request and get the response\nResponse<BlockHeader> response = call.execute();\nBlockHeader blockHeader = response.body();\n```\n\nIn this example, we create a `Retrofit` instance with a base URL of `https://api.ergoplatform.com`. We then use the `create` method to obtain a reference to the `ErgoNodeFacade` service interface, which defines methods for interacting with the Ergo blockchain network. We then use `RetrofitUtil.invokeServiceMethod` to invoke the `getBlockHeaderById` method on the `ErgoNodeFacade` interface, passing in the ID of the block header we want to retrieve. Finally, we execute the HTTP request and get the response, which contains the block header.\n## Questions: \n 1. What is the purpose of this class and why is it needed? \n   Answer: This class provides access to a package-private method in Retrofit that is required to bypass usual proxy generation which doesn't work under Graal native-image.\n\n2. What is the significance of the \"@see\" tag in the class documentation? \n   Answer: The \"@see\" tag provides a reference to the ErgoNodeFacade in lib-impl, which is related to the purpose of this class.\n\n3. What does the \"invokeServiceMethod\" method do and what are its parameters? \n   Answer: The \"invokeServiceMethod\" method takes in a Retrofit instance, a Method object, and an array of arguments. It invokes the package-private loadServiceMethod method on the Retrofit instance using the Method object, and returns a Call object with the specified type parameter T.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/retrofit2/RetrofitUtil.md"}}],["244",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/java-client-generated/src/main/java/retrofit2)\n\nThe `RetrofitUtil` class in the `ergo-appkit` project is a utility class that provides a way to bypass the usual proxy generation in Retrofit, which doesn't work under Graal native-image. Retrofit is a type-safe HTTP client for Android and Java, and this class allows the invocation of service methods in Retrofit.\n\nThe main functionality of this class is provided by the `invokeServiceMethod` method, which takes in a `Retrofit` instance, a `Method` object representing the service method to be invoked, and an array of arguments to be passed to the method. It then calls the `loadServiceMethod` method on the `Retrofit` instance to obtain a `ServiceMethod` object, which is used to create a `Call` object that can be used to make the HTTP request.\n\nThis class is likely used in the larger project to facilitate communication between the ErgoNodeFacade in the `lib-impl` module and the Ergo blockchain network. The `invokeServiceMethod` method can be used to make HTTP requests to the Ergo blockchain network using Retrofit, which provides a convenient and type-safe way to interact with the network.\n\nHere is an example of how this class might be used in the larger project:\n\n```java\n// create a Retrofit instance\nRetrofit retrofit = new Retrofit.Builder()\n    .baseUrl(\"https://api.ergoplatform.com\")\n    .build();\n\n// get a reference to the ErgoNodeFacade service interface\nErgoNodeFacade ergoNodeFacade = retrofit.create(ErgoNodeFacade.class);\n\n// invoke a service method using RetrofitUtil\nCall<BlockHeader> call = RetrofitUtil.invokeServiceMethod(retrofit, \n    ErgoNodeFacade.class.getMethod(\"getBlockHeaderById\", String.class), \n    new Object[] { \"12345\" });\n\n// execute the HTTP request and get the response\nResponse<BlockHeader> response = call.execute();\nBlockHeader blockHeader = response.body();\n```\n\nIn this example, we create a `Retrofit` instance with a base URL of `https://api.ergoplatform.com`. We then use the `create` method to obtain a reference to the `ErgoNodeFacade` service interface, which defines methods for interacting with the Ergo blockchain network. We then use `RetrofitUtil.invokeServiceMethod` to invoke the `getBlockHeaderById` method on the `ErgoNodeFacade` interface, passing in the ID of the block header we want to retrieve. Finally, we execute the HTTP request and get the response, which contains the block header.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/retrofit2/summary.md"}}],["245",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/java-client-generated/src/main/java)\n\nThe `.autodoc/docs/json/java-client-generated/src/main/java` folder contains essential components for interacting with the Ergo blockchain explorer API and the Ergo Platform REST API. These components handle JSON serialization and deserialization, formatting collections of strings, adding authentication information to HTTP requests, and managing communication with the Ergo REST API.\n\n### Ergo Blockchain Explorer API\n\nThe `explorer` subfolder provides components for interacting with the Ergo blockchain explorer API. The `DefaultApi.java` interface offers methods for fetching balances, transactions, blocks, and tokens. For example:\n\n```java\nDefaultApi api = new DefaultApi();\nString address = \"9f4QF8AD1nQ3nJahQVkM6c5jmBvG4Df6MAzvp8uss6R4XNt8vGt\";\nApiResponse<ConfirmedBalance> response = api.getApiV1AddressesP1BalanceConfirmed(address, 10);\n```\n\nThe `ExplorerApiClient.java` class is a wrapper around the Retrofit library, providing a convenient way to interact with a RESTful API. The `JSON.java` class is responsible for creating and configuring a `Gson` object for JSON serialization and deserialization. The `StringUtil.java` class provides utility methods for working with arrays of strings.\n\nThe `auth` subfolder contains classes for adding authentication information to HTTP requests made by the Ergo Explorer client, such as `ApiKeyAuth` and `HttpBasicAuth`.\n\n### Ergo Platform REST API\n\nThe `restapi` subfolder contains Java classes generated from the Ergo Platform REST API specification. These classes are used to interact with the Ergo blockchain through the REST API, allowing developers to easily integrate Ergo functionality into their Java applications.\n\nThe `ApiClient.java` class manages communication with the Ergo REST API, handling HTTP requests, authentication, and JSON serialization/deserialization. The `Configuration.java` class is used to configure the `ApiClient`. For example:\n\n```java\nConfiguration config = new Configuration();\nconfig.setApiKey(\"your_api_key\");\nconfig.setBasePath(\"https://api.ergoplatform.com\");\n\nApiClient apiClient = new ApiClient(config);\n```\n\nTo make API calls, you would use the `ApiClient` instance. For example, to get the balance of an address:\n\n```java\nString address = \"9f4QF8AD1nQ3nJahQVkM6c8qiuyhM1i8Kgh8Dt6hP8Xf8gsgg5u\";\nApiResponse<Balance> response = apiClient.invokeAPI(\"/addresses/\" + address + \"/balance\", \"GET\", null, null, null, null, null, \"application/json\", null, new TypeToken<Balance>(){}.getType());\n\nBalance balance = response.getData();\nSystem.out.println(\"Balance: \" + balance.getConfirmed().getNanoErgs());\n```\n\nThis code snippet demonstrates how to configure the `ApiClient`, make an API call to get the balance of an address, and extract the balance information from the response.\n\nOverall, this folder provides essential components for interacting with the Ergo blockchain explorer API and the Ergo Platform REST API, handling JSON serialization and deserialization, formatting collections of strings, adding authentication information to HTTP requests, and managing communication with the Ergo REST API.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/java/summary.md"}}],["246",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/java-client-generated/src/main)\n\nThe `.autodoc/docs/json/java-client-generated/src/main` folder contains essential components for interacting with the Ergo blockchain explorer API and the Ergo Platform REST API. These components handle JSON serialization and deserialization, formatting collections of strings, adding authentication information to HTTP requests, and managing communication with the Ergo REST API.\n\n### Ergo Blockchain Explorer API\n\nThe `explorer` subfolder provides components for interacting with the Ergo blockchain explorer API. The `DefaultApi.java` interface offers methods for fetching balances, transactions, blocks, and tokens. For example:\n\n```java\nDefaultApi api = new DefaultApi();\nString address = \"9f4QF8AD1nQ3nJahQVkM6c5jmBvG4Df6MAzvp8uss6R4XNt8vGt\";\nApiResponse<ConfirmedBalance> response = api.getApiV1AddressesP1BalanceConfirmed(address, 10);\n```\n\nThe `ExplorerApiClient.java` class is a wrapper around the Retrofit library, providing a convenient way to interact with a RESTful API. The `JSON.java` class is responsible for creating and configuring a `Gson` object for JSON serialization and deserialization. The `StringUtil.java` class provides utility methods for working with arrays of strings.\n\nThe `auth` subfolder contains classes for adding authentication information to HTTP requests made by the Ergo Explorer client, such as `ApiKeyAuth` and `HttpBasicAuth`.\n\n### Ergo Platform REST API\n\nThe `restapi` subfolder contains Java classes generated from the Ergo Platform REST API specification. These classes are used to interact with the Ergo blockchain through the REST API, allowing developers to easily integrate Ergo functionality into their Java applications.\n\nThe `ApiClient.java` class manages communication with the Ergo REST API, handling HTTP requests, authentication, and JSON serialization/deserialization. The `Configuration.java` class is used to configure the `ApiClient`. For example:\n\n```java\nConfiguration config = new Configuration();\nconfig.setApiKey(\"your_api_key\");\nconfig.setBasePath(\"https://api.ergoplatform.com\");\n\nApiClient apiClient = new ApiClient(config);\n```\n\nTo make API calls, you would use the `ApiClient` instance. For example, to get the balance of an address:\n\n```java\nString address = \"9f4QF8AD1nQ3nJahQVkM6c8qiuyhM1i8Kgh8Dt6hP8Xf8gsgg5u\";\nApiResponse<Balance> response = apiClient.invokeAPI(\"/addresses/\" + address + \"/balance\", \"GET\", null, null, null, null, null, \"application/json\", null, new TypeToken<Balance>(){}.getType());\n\nBalance balance = response.getData();\nSystem.out.println(\"Balance: \" + balance.getConfirmed().getNanoErgs());\n```\n\nThis code snippet demonstrates how to configure the `ApiClient`, make an API call to get the balance of an address, and extract the balance information from the response.\n\nOverall, this folder provides essential components for interacting with the Ergo blockchain explorer API and the Ergo Platform REST API, handling JSON serialization and deserialization, formatting collections of strings, adding authentication information to HTTP requests, and managing communication with the Ergo REST API.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/main/summary.md"}}],["247",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/java-client-generated/src)\n\nThe `.autodoc/docs/json/java-client-generated/src` folder contains essential components for interacting with the Ergo blockchain explorer API and the Ergo Platform REST API. These components handle JSON serialization and deserialization, formatting collections of strings, adding authentication information to HTTP requests, and managing communication with the Ergo REST API.\n\n### Ergo Blockchain Explorer API\n\nThe `explorer` subfolder provides components for interacting with the Ergo blockchain explorer API. The `DefaultApi.java` interface offers methods for fetching balances, transactions, blocks, and tokens. For example:\n\n```java\nDefaultApi api = new DefaultApi();\nString address = \"9f4QF8AD1nQ3nJahQVkM6c5jmBvG4Df6MAzvp8uss6R4XNt8vGt\";\nApiResponse<ConfirmedBalance> response = api.getApiV1AddressesP1BalanceConfirmed(address, 10);\n```\n\nThe `ExplorerApiClient.java` class is a wrapper around the Retrofit library, providing a convenient way to interact with a RESTful API. The `JSON.java` class is responsible for creating and configuring a `Gson` object for JSON serialization and deserialization. The `StringUtil.java` class provides utility methods for working with arrays of strings.\n\nThe `auth` subfolder contains classes for adding authentication information to HTTP requests made by the Ergo Explorer client, such as `ApiKeyAuth` and `HttpBasicAuth`.\n\n### Ergo Platform REST API\n\nThe `restapi` subfolder contains Java classes generated from the Ergo Platform REST API specification. These classes are used to interact with the Ergo blockchain through the REST API, allowing developers to easily integrate Ergo functionality into their Java applications.\n\nThe `ApiClient.java` class manages communication with the Ergo REST API, handling HTTP requests, authentication, and JSON serialization/deserialization. The `Configuration.java` class is used to configure the `ApiClient`. For example:\n\n```java\nConfiguration config = new Configuration();\nconfig.setApiKey(\"your_api_key\");\nconfig.setBasePath(\"https://api.ergoplatform.com\");\n\nApiClient apiClient = new ApiClient(config);\n```\n\nTo make API calls, you would use the `ApiClient` instance. For example, to get the balance of an address:\n\n```java\nString address = \"9f4QF8AD1nQ3nJahQVkM6c8qiuyhM1i8Kgh8Dt6hP8Xf8gsgg5u\";\nApiResponse<Balance> response = apiClient.invokeAPI(\"/addresses/\" + address + \"/balance\", \"GET\", null, null, null, null, null, \"application/json\", null, new TypeToken<Balance>(){}.getType());\n\nBalance balance = response.getData();\nSystem.out.println(\"Balance: \" + balance.getConfirmed().getNanoErgs());\n```\n\nThis code snippet demonstrates how to configure the `ApiClient`, make an API call to get the balance of an address, and extract the balance information from the response.\n\nOverall, this folder provides essential components for interacting with the Ergo blockchain explorer API and the Ergo Platform REST API, handling JSON serialization and deserialization, formatting collections of strings, adding authentication information to HTTP requests, and managing communication with the Ergo REST API.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/src/summary.md"}}],["248",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/java-client-generated)\n\nThe `.autodoc/docs/json/java-client-generated` folder contains essential components for interacting with the Ergo blockchain explorer API and the Ergo Platform REST API. These components handle JSON serialization and deserialization, formatting collections of strings, adding authentication information to HTTP requests, and managing communication with the Ergo REST API.\n\n### Ergo Blockchain Explorer API\n\nThe `explorer` subfolder provides components for interacting with the Ergo blockchain explorer API. The `DefaultApi.java` interface offers methods for fetching balances, transactions, blocks, and tokens. For example:\n\n```java\nDefaultApi api = new DefaultApi();\nString address = \"9f4QF8AD1nQ3nJahQVkM6c5jmBvG4Df6MAzvp8uss6R4XNt8vGt\";\nApiResponse<ConfirmedBalance> response = api.getApiV1AddressesP1BalanceConfirmed(address, 10);\n```\n\nThe `ExplorerApiClient.java` class is a wrapper around the Retrofit library, providing a convenient way to interact with a RESTful API. The `JSON.java` class is responsible for creating and configuring a `Gson` object for JSON serialization and deserialization. The `StringUtil.java` class provides utility methods for working with arrays of strings.\n\nThe `auth` subfolder contains classes for adding authentication information to HTTP requests made by the Ergo Explorer client, such as `ApiKeyAuth` and `HttpBasicAuth`.\n\n### Ergo Platform REST API\n\nThe `restapi` subfolder contains Java classes generated from the Ergo Platform REST API specification. These classes are used to interact with the Ergo blockchain through the REST API, allowing developers to easily integrate Ergo functionality into their Java applications.\n\nThe `ApiClient.java` class manages communication with the Ergo REST API, handling HTTP requests, authentication, and JSON serialization/deserialization. The `Configuration.java` class is used to configure the `ApiClient`. For example:\n\n```java\nConfiguration config = new Configuration();\nconfig.setApiKey(\"your_api_key\");\nconfig.setBasePath(\"https://api.ergoplatform.com\");\n\nApiClient apiClient = new ApiClient(config);\n```\n\nTo make API calls, you would use the `ApiClient` instance. For example, to get the balance of an address:\n\n```java\nString address = \"9f4QF8AD1nQ3nJahQVkM6c8qiuyhM1i8Kgh8Dt6hP8Xf8gsgg5u\";\nApiResponse<Balance> response = apiClient.invokeAPI(\"/addresses/\" + address + \"/balance\", \"GET\", null, null, null, null, null, \"application/json\", null, new TypeToken<Balance>(){}.getType());\n\nBalance balance = response.getData();\nSystem.out.println(\"Balance: \" + balance.getConfirmed().getNanoErgs());\n```\n\nThis code snippet demonstrates how to configure the `ApiClient`, make an API call to get the balance of an address, and extract the balance information from the response.\n\nOverall, this folder provides essential components for interacting with the Ergo blockchain explorer API and the Ergo Platform REST API, handling JSON serialization and deserialization, formatting collections of strings, adding authentication information to HTTP requests, and managing communication with the Ergo REST API.","metadata":{"source":".autodoc/docs/markdown/java-client-generated/summary.md"}}],["249",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/BlockHeader.java)\n\nThe code above defines an interface called `BlockHeader` which extends another interface called `PreHeader`. This interface is part of the `ergo-appkit` project and is used to represent the header of a block in the Ergo blockchain. \n\nThe `BlockHeader` interface defines several methods that can be used to retrieve information about a block header. These methods include `getId()`, which returns the ID of the block, `getStateRoot()`, which returns the root hash of the Merkle tree representing the state of the blockchain after the block has been applied, `getAdProofsRoot()`, which returns the root hash of the Merkle tree representing the proofs of inclusion of transactions in the block, `getTransactionsRoot()`, which returns the root hash of the Merkle tree representing the transactions in the block, `getExtensionHash()`, which returns the hash of the extension data associated with the block, `getPowSolutionsPk()`, which returns the public key used to generate the proof-of-work solution for the block, `getPowSolutionsW()`, which returns the witness used to generate the proof-of-work solution for the block, `getPowSolutionsD()`, which returns the difficulty of the proof-of-work solution for the block, and `getPowSolutionsN()`, which returns the nonce used to generate the proof-of-work solution for the block.\n\nThis interface can be used by developers who are building applications on top of the Ergo blockchain to retrieve information about blocks in the blockchain. For example, a developer might use the `getTransactionsRoot()` method to retrieve the root hash of the Merkle tree representing the transactions in a block, and then use that hash to verify that a particular transaction is included in the block. \n\nOverall, the `BlockHeader` interface is an important part of the `ergo-appkit` project, as it provides developers with a way to interact with the Ergo blockchain and retrieve information about blocks.\n## Questions: \n 1. What is the purpose of this code and what does it do?\n   This code defines an interface for a block header in the Ergo blockchain, which includes various properties such as the state root, transaction root, and proof-of-work solutions.\n\n2. What is the significance of the AvlTree and GroupElement data types used in this code?\n   The AvlTree data type represents a Merkle tree used to store and verify the state of the blockchain, while the GroupElement data type represents an element of a cryptographic group used in the proof-of-work algorithm.\n\n3. How might a developer use this code in their own Ergo blockchain application?\n   A developer could implement this interface in their own code to create and manipulate block headers in the Ergo blockchain, allowing them to interact with the blockchain and perform various operations such as mining new blocks or verifying transactions.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/BlockHeader.md"}}],["250",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/BlockchainContext.java)\n\nThe `BlockchainContext` interface is a representation of a specific context of the blockchain for executing transaction building scenarios. It contains methods for accessing blockchain data, current blockchain state, node information, etc. An instance of this interface can also be used to create new builders for creating new transactions and provers (used for transaction signing).\n\nThe `createPreHeader()` method creates a new PreHeader based on this blockchain context. The header of the last block is used to derive default values for the new PreHeader.\n\nThe `signedTxFromJson(String json)` method parses the given JSON string and creates a `SignedTransaction` instance. It should be inverse to `SignedTransaction#toJson(boolean)`.\n\nThe `newTxBuilder()` method creates a new builder of an unsigned transaction. A new builder is created for every call.\n\nThe `getDataSource()` method returns the blockchain data source this blockchain context was created from.\n\nThe `getBoxesById(String... boxIds)` method retrieves UTXO boxes available in this blockchain context.\n\nThe `newProverBuilder()` method creates a new builder of `ErgoProver`.\n\nThe `getNetworkType()` method returns a network type of this context.\n\nThe `getHeight()` method returns the height of the blockchain at the point of time when this context was created.\n\nThe `sendTransaction(SignedTransaction tx)` method sends a signed transaction to a blockchain node.\n\nThe `newContract(Values.ErgoTree ergoTree)` method creates a new `ErgoContract`.\n\nThe `compileContract(Constants constants, String ergoScript)` method compiles a contract.\n\nThe `getUnspentBoxesFor(Address address, int offset, int limit)` method gets unspent boxes owned by the given address starting from the given offset up to the given limit.\n\nThe `getCoveringBoxesFor(Address address, long amountToSpend, List<ErgoToken> tokensToSpend)` method gets unspent boxes owned by the given address starting from the given offset up to the given limit. It is deprecated and should be replaced with `BoxOperations#getCoveringBoxesFor(long, List, Function)`.\n\nThe `parseReducedTransaction(byte[] txBytes)` method deserializes the transaction from the serialized bytes of a `ReducedErgoLikeTransaction`.\n\nThe `parseSignedTransaction(byte[] txBytes)` method deserializes the transaction from the serialized bytes of an `ErgoLikeTransaction`.\n\nOverall, the `BlockchainContext` interface provides a set of methods for interacting with the blockchain and creating new transactions and provers. It is a key component of the `ergo-appkit` project and is used extensively throughout the project.\n## Questions: \n 1. What is the purpose of the `BlockchainContext` interface?\n- The `BlockchainContext` interface represents a specific context of blockchain for execution of transaction building scenario. It contains methods for accessing blockchain data, current blockchain state, node information, etc. An instance of this interface can also be used to create new builders for creating new transactions and provers (used for transaction signing).\n\n2. What is the purpose of the `createPreHeader()` method?\n- The `createPreHeader()` method creates a new PreHeader based on this blockchain context. The header of the last block is used to derive default values for the new PreHeader.\n\n3. What is the purpose of the `sendTransaction(SignedTransaction tx)` method?\n- The `sendTransaction(SignedTransaction tx)` method sends a signed transaction to a blockchain node. On the blockchain node, the transaction is first placed in a pool and then later can be selected by a miner and included in the next block. The new transactions are also replicated all over the network.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/BlockchainContext.md"}}],["251",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/BlockchainContextBuilder.java)\n\nThe code above defines an interface called `BlockchainContextBuilder` that is used to build new blockchain contexts. A blockchain context is a data structure that contains information about the current state of the blockchain, such as the current block height, the current difficulty level, and the current set of UTXOs (unspent transaction outputs).\n\nThe `BlockchainContextBuilder` interface has one method called `build()` that returns a new `BlockchainContext` object. The `build()` method throws an `ErgoClientException` if there is an error while building the context.\n\nThe `BlockchainContextBuilder` interface also defines a constant called `NUM_LAST_HEADERS` that has a value of 10. This constant represents the number of block headers that are available in the context. A block header is a data structure that contains information about a block, such as its hash, its timestamp, and the hash of the previous block.\n\nThis interface can be used by developers who want to interact with the Ergo blockchain in their applications. They can create a new instance of a class that implements the `BlockchainContextBuilder` interface and use it to build a new `BlockchainContext` object. They can then use the `BlockchainContext` object to query the blockchain for information about blocks, transactions, and UTXOs.\n\nHere is an example of how this interface might be used in a larger project:\n\n```\n// Create a new instance of a class that implements the BlockchainContextBuilder interface\nBlockchainContextBuilder builder = new MyBlockchainContextBuilder();\n\n// Build a new BlockchainContext object\nBlockchainContext context = builder.build();\n\n// Use the BlockchainContext object to query the blockchain for information\nint currentHeight = context.getHeight();\nList<Utxo> utxos = context.getUtxos();\n```\n\nIn this example, `MyBlockchainContextBuilder` is a class that implements the `BlockchainContextBuilder` interface. The `build()` method in `MyBlockchainContextBuilder` collects the necessary parameters to build a new `BlockchainContext` object. The `getHeight()` and `getUtxos()` methods in the `BlockchainContext` object are used to query the blockchain for information about the current block height and the current set of UTXOs, respectively.\n## Questions: \n 1. What is the purpose of this interface?\n   - This interface is used to build new blockchain contexts.\n\n2. What is the significance of the NUM_LAST_HEADERS constant?\n   - The NUM_LAST_HEADERS constant represents the number of headers available in the context and is defined by the Ergo protocol.\n\n3. What exception can be thrown by the build() method?\n   - The build() method can throw an ErgoClientException.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/BlockchainContextBuilder.md"}}],["252",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/BlockchainDataSource.java)\n\nThe `BlockchainDataSource` interface provides a way to access blockchain data source. This interface is a part of the `ergo-appkit` project. The data source always performs a request to the blockchain data and does not hold or cache any information. \n\nThe `BlockchainDataSource` interface has several methods that allow the user to interact with the blockchain. The `getParameters()` method returns the blockchain parameters that the data source is working with. The returned value might be cached by the data source as it is not subject to change frequently.\n\nThe `getLastBlockHeaders(int count, boolean onlyFullHeaders)` method returns the last headers objects sorted by descending order. The `count` parameter specifies the number of block headers that the user wants to retrieve. The `onlyFullHeaders` parameter restricts the returned list to full headers. If set to true, the amount of returned block headers might be less than `count`.\n\nThe `getBoxById(String boxId, boolean findInPool, boolean findInSpent)` method returns box contents for an unspent box by a unique identifier for use as an Input, including mempool boxes. The `boxId` parameter specifies the ID of the wanted box. The `findInPool` parameter specifies whether to find boxes that are currently in the mempool. The `findInSpent` parameter specifies whether to find boxes that are spent.\n\nThe `sendTransaction(SignedTransaction tx)` method sends an Ergo transaction. The `tx` parameter specifies the signed transaction to be posted to the blockchain. The method returns the transaction ID of the submitted transaction.\n\nThe `getUnspentBoxesFor(Address address, int offset, int limit)` method returns unspent boxes owned by the given address starting from the given offset up to the given limit (basically one page of the boxes). The `address` parameter specifies the owner of the boxes to be retrieved. The `offset` parameter specifies the optional zero-based offset of the first box in the list, default = 0. The `limit` parameter specifies the optional number of boxes to retrieve. Note that the returned list might contain fewer elements if data for some boxes couldn't be retrieved.\n\nThe `getUnconfirmedUnspentBoxesFor(Address address, int offset, int limit)` method returns unspent boxes owned by the given address starting from the given offset up to the given limit (basically one page of the boxes), restricted to mempool. The `address` parameter specifies the owner of the boxes to be retrieved. The `offset` parameter specifies the optional zero-based offset of the first box in the list, default = 0. The `limit` parameter specifies the optional number of boxes to retrieve. Note that the returned list might contain fewer elements if data for some boxes couldn't be retrieved.\n\nThe `getUnconfirmedTransactions(int offset, int limit)` method returns unconfirmed transactions from mempool. The `offset` parameter specifies the optional zero-based offset of the first transaction in the list, default = 0. The `limit` parameter specifies the optional number of transactions to retrieve. Note that the returned list might contain fewer elements if data for some transactions couldn't be retrieved.\n\nOverall, the `BlockchainDataSource` interface provides a way to interact with the blockchain data source. The methods in this interface allow the user to retrieve blockchain parameters, block headers, unspent boxes, and unconfirmed transactions. The user can also send an Ergo transaction using this interface. This interface is a part of the `ergo-appkit` project and can be used to build applications that interact with the Ergo blockchain.\n## Questions: \n 1. What is the purpose of this interface and what methods does it provide?\n- This interface provides methods to access blockchain data source, including getting blockchain parameters, retrieving block headers, boxes, and transactions, and sending transactions to the blockchain.\n\n2. What is the difference between `getUnspentBoxesFor` and `getUnconfirmedUnspentBoxesFor` methods?\n- `getUnspentBoxesFor` retrieves unspent boxes owned by the given address from the blockchain, while `getUnconfirmedUnspentBoxesFor` retrieves unspent boxes owned by the given address from the mempool.\n\n3. What is the purpose of the `BlockchainParameters` class and how is it used in this interface?\n- The `BlockchainParameters` class represents the parameters of the blockchain that this data source is working with, and is used in the `getParameters` method to return the blockchain parameters that might be cached by the data source.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/BlockchainDataSource.md"}}],["253",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/BlockchainParameters.java)\n\nThe code above defines an interface called `BlockchainParameters` which contains methods that return various parameters related to the blockchain. These parameters include the network type (mainnet or testnet), the cost of storing 1 byte in UTXO for four years, the minimum value per byte of an output, the maximum block size in bytes, the cost of a token contained in a transaction, the cost of a transaction input, the cost of a transaction data input, the cost of a transaction output, the computation units limit per block, and the protocol version.\n\nThis interface is likely used in the larger project to provide a way for developers to access and modify blockchain parameters. For example, a developer may want to retrieve the current network type in order to determine which network they are currently connected to. They could do this by calling the `getNetworkType()` method on an instance of the `BlockchainParameters` interface.\n\nSimilarly, a developer may want to modify the maximum block size in order to increase the throughput of the blockchain. They could do this by calling the `getMaxBlockSize()` method to retrieve the current maximum block size, modifying it as desired, and then setting the new value using a setter method (not shown in this code snippet).\n\nOverall, this interface provides a standardized way for developers to access and modify important blockchain parameters, which can help to ensure consistency and compatibility across different parts of the project.\n## Questions: \n 1. What is the purpose of this interface?\n    \n    This interface defines the parameters of the blockchain, such as network type, storage fee factor, and computation unit costs for various transaction components.\n\n2. What is the expected format of the return values for the methods in this interface?\n    \n    The return values for the methods in this interface are expected to be integers or bytes, depending on the method.\n\n3. Are there any default values for these parameters, or are they set externally?\n    \n    It is not clear from this code whether there are default values for these parameters or if they are set externally. This information may be available in other parts of the `ergo-appkit` project.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/BlockchainParameters.md"}}],["254",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/BoxOperations.java)\n\nThe `BoxOperations` class in the ergo-appkit project provides a collection of utility operations for working with Ergo boxes, tokens, and transactions. It allows users to create, sign, and send transactions, as well as load unspent boxes to cover specified amounts of NanoErgs and tokens.\n\nThe class provides several factory methods for creating instances of `BoxOperations` with different configurations, such as a single sender address, a list of sender addresses, or a prover with EIP-3 addresses. It also allows users to set various properties like the amount to spend, tokens to spend, fee amount, attachment, and maximum input boxes to select.\n\nThe `send` method sends the specified amount and tokens to a recipient address, while the `loadTop` method loads unspent boxes covering the given amount of NanoErgs, fee, and tokens. The `putToContractTx` and `putToContractTxUnsigned` methods create signed and unsigned transactions, respectively, which send the given amount and tokens to a specified contract.\n\nThe `IUnspentBoxesLoader` interface allows users to customize the behavior of unspent box loading. The default implementation, `ExplorerApiUnspentLoader`, loads unspent boxes directly from the Explorer API. Users can extend this class to add custom filtering or loading logic.\n\nExample usage:\n\n```java\nBoxOperations boxOps = BoxOperations.createForSender(senderAddress, blockchainContext)\n    .withAmountToSpend(1000000)\n    .withTokensToSpend(tokenList)\n    .withFeeAmount(150000)\n    .withMessage(\"Hello, Ergo!\");\n\nString txJson = boxOps.send(recipientAddress);\n```\n\nThis example creates a `BoxOperations` instance for a sender address, sets the amount to spend, tokens to spend, fee amount, and an optional message. It then sends the transaction to a recipient address and returns the JSON representation of the signed transaction.\n## Questions: \n 1. **What is the purpose of the `BoxOperations` class?**\n\n   The `BoxOperations` class is a collection of utility operations implemented in terms of abstract Appkit interfaces. It provides methods for constructing and sending transactions, loading unspent boxes, and working with Ergo tokens.\n\n2. **How does the `IUnspentBoxesLoader` interface work?**\n\n   The `IUnspentBoxesLoader` interface is used to adapt the behavior of unspent boxes loading. It provides methods for preparing the loader with a list of addresses, gross amount, and tokens to spend, preparing for a single address, and loading a page of unspent boxes for a given address.\n\n3. **What is the purpose of the `ExplorerApiUnspentLoader` class?**\n\n   The `ExplorerApiUnspentLoader` class is the default loader for unspent boxes. It loads unspent boxes for an address directly from the Explorer API. It implements the `IUnspentBoxesLoader` interface and provides methods for preparing the loader and loading a page of unspent boxes for a given address.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/BoxOperations.md"}}],["255",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/ConstantsBuilder.java)\n\nThe `ConstantsBuilder` class is a utility class that is used to build instances of the `Constants` class. The `Constants` class is used in ErgoScript contracts to define constants that can be used in the contract logic. The purpose of this class is to simplify the process of creating instances of the `Constants` class by providing a fluent interface for adding items to the constants map.\n\nThe `ConstantsBuilder` class has three methods: `item`, `build`, and two static methods `create` and `empty`. The `item` method is used to add a new item to the constants map. It takes two arguments: a `String` name and an `Object` value. The `name` argument is the name of the constant and the `value` argument is the value of the constant. The `item` method returns the `ConstantsBuilder` instance to allow for method chaining.\n\nThe `build` method is used to create a new instance of the `Constants` class with the items that have been added to the constants map using the `item` method. It returns the new instance of the `Constants` class.\n\nThe `create` method is a static factory method that is used to create a new instance of the `ConstantsBuilder` class. This method returns a new instance of the `ConstantsBuilder` class.\n\nThe `empty` method is a static method that is used to create an empty instance of the `Constants` class. It does this by calling the `create` method and then calling the `build` method on the new instance of the `ConstantsBuilder` class.\n\nHere is an example of how this class can be used:\n\n```\nConstants constants = ConstantsBuilder.create()\n    .item(\"myConstant\", 42)\n    .item(\"anotherConstant\", \"hello world\")\n    .build();\n```\n\nThis code creates a new instance of the `Constants` class with two items: `myConstant` with a value of `42` and `anotherConstant` with a value of `\"hello world\"`. The `constants` variable now holds this new instance of the `Constants` class and can be used in an ErgoScript contract.\n## Questions: \n 1. What is the purpose of this code?\n   - This code defines a class called `ConstantsBuilder` that is used to build instances of `Constants` which can be used in ErgoScript contracts.\n\n2. What methods are available in the `ConstantsBuilder` class?\n   - The `ConstantsBuilder` class has four methods: `item`, `build`, `create`, and `empty`. The `item` method is used to add a new name-value pair to the `Constants` instance being built. The `build` method returns the completed `Constants` instance. The `create` method returns a new instance of `ConstantsBuilder`. The `empty` method returns an empty `Constants` instance.\n\n3. What is the relationship between the `ConstantsBuilder` and `Constants` classes?\n   - The `ConstantsBuilder` class is used to build instances of the `Constants` class. The `Constants` class is the class that actually holds the name-value pairs that can be used in ErgoScript contracts.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/ConstantsBuilder.md"}}],["256",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/CoveringBoxes.java)\n\nThe `CoveringBoxes` class in the `ergo-appkit` project represents a collection of input boxes that cover a given amount of NanoErgs to spend. The class allows for partial coverage, which is useful for collecting boxes in multiple steps. \n\nThe class has four instance variables: `_amountToSpend`, `_boxes`, `tokensToSpend`, and `changeBoxNeeded`. `_amountToSpend` is the amount of NanoErgs to spend, `_boxes` is a list of input boxes that cover the amount, `tokensToSpend` is a list of tokens to spend, and `changeBoxNeeded` is a boolean value that indicates whether a change box is needed to spend the selected boxes. \n\nThe class has five methods. `getCoveredAmount()` returns the amount covered by the boxes in the set. `getCoveredTokens()` returns a list of tokens covered by the boxes. `isCovered()` returns true if the amount and tokens are covered by the boxes in the set, and false otherwise. `getBoxes()` returns a list of boxes stored in the set. `isChangeBoxNeeded()` returns true if a change box is needed to spend the selected boxes. \n\nThe `getCoveredAmount()` method iterates through the `_boxes` list and sums the value of each box to calculate the total amount covered. The `getCoveredTokens()` method iterates through the `_boxes` list and creates a `HashMap` of tokens covered by the boxes. If a token is already in the map, its value is updated. The method returns a list of values in the map. \n\nThe `isCovered()` method checks if the amount covered by the boxes is greater than or equal to the amount to spend and if the tokens to spend are covered by the boxes. It uses the `SelectTokensHelper` class to check if the tokens are covered. \n\nOverall, the `CoveringBoxes` class is a useful tool for managing input boxes that cover a given amount of NanoErgs to spend. It allows for partial coverage and provides methods for checking if the amount and tokens are covered by the boxes.\n## Questions: \n 1. What is the purpose of the `CoveringBoxes` class?\n- The `CoveringBoxes` class represents a collection of boxes covering a given amount of NanoErgs to spend, allowing for partial coverage and collection of boxes in many steps.\n\n2. What does the `getCoveredTokens` method do?\n- The `getCoveredTokens` method returns a list of tokens covered by the boxes in the `CoveringBoxes` set.\n\n3. What does the `isCovered` method check for?\n- The `isCovered` method checks if the amount and tokens are covered by the boxes in the `CoveringBoxes` set, returning true if they are and false otherwise.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/CoveringBoxes.md"}}],["257",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/ErgoClient.java)\n\nThe code defines an interface called ErgoClient, which represents a client object for interacting with the Ergo blockchain. The purpose of this interface is to provide a common way to interact with the blockchain, regardless of the specific implementation used. \n\nThe ErgoClient interface has two methods: getDataSource() and execute(). The getDataSource() method returns a BlockchainDataSource object, which is used to fetch data from the blockchain. The execute() method takes a Function object as an argument, which represents some action to be performed on the blockchain. The execute() method creates a BlockchainContext object, which represents the current state of the blockchain, and passes it to the action. The action returns a result of type T, which is then returned by the execute() method.\n\nThe ErgoClient interface is designed to be used as a runner of some action in a blockchain context. The BlockchainContext object is created by the specific ErgoClient implementation and passed to the action. This allows the action to interact with the blockchain in a consistent way, regardless of the specific implementation used.\n\nThe ErgoClient interface is intended to be implemented by different classes, each of which represents a different way of interacting with the Ergo blockchain. For example, one implementation might use the Ergo REST API to communicate with the blockchain, while another might use a direct connection to a node running in the same JVM. The actual implementation used to fetch data can be accessed from the BlockchainDataSource object returned by the getDataSource() method.\n\nOverall, the ErgoClient interface provides a high-level abstraction for interacting with the Ergo blockchain, allowing developers to write code that is independent of the specific implementation used. This makes it easier to write code that can be reused across different projects and environments. \n\nExample usage:\n\n```\n// create an instance of ErgoClient\nErgoClient client = new MyErgoClient();\n\n// define an action to be performed on the blockchain\nFunction<BlockchainContext, Integer> action = (context) -> {\n    // perform some operation on the blockchain\n    int result = context.getHeight();\n    return result;\n};\n\n// execute the action using the ErgoClient\nint result = client.execute(action);\n```\n## Questions: \n 1. What is the purpose of the ErgoClient interface?\n    \n    The ErgoClient interface is used to represent an object that connects to the Ergo blockchain network and can be used to execute actions in a blockchain context.\n\n2. What is the role of the BlockchainDataSource interface in this code?\n    \n    The BlockchainDataSource interface provides the actual implementation to fetch data for the ErgoClient.\n\n3. What is the purpose of the explorerUrlNotSpecifiedMessage variable?\n    \n    The explorerUrlNotSpecifiedMessage variable is used as a message when the explorer is requested in \"node-only\" mode and the URL is not specified.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/ErgoClient.md"}}],["258",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/ErgoProver.java)\n\nThe `ErgoProver` interface is part of the `ergo-appkit` project and defines the methods that a prover must implement to sign transactions and messages. \n\nThe `ErgoProver` interface has several methods that allow the prover to sign transactions and messages. The `getP2PKAddress()` method returns the Pay-To-Public-Key address of the prover. The `getAddress()` method returns the Pay-To-Public-Key address of the prover represented as an `Address` object. The `getSecretKey()` method returns the master secret key of the prover. The `getEip3Addresses()` method returns a list of `Address` objects that correspond to the Ethereum Improvement Proposal 3 (EIP-3) addresses derived from the master secret key.\n\nThe `sign()` method signs an unsigned transaction using the configured secrets. The `sign()` method with two parameters signs an unsigned transaction and takes a `baseCost` parameter that represents the computational cost before the transaction validation. The `signMessage()` method signs an arbitrary message under a key representing a statement provable via a sigma-protocol. The `reduce()` method reduces an unsigned transaction to a reduced transaction. The `signReduced()` method signs a reduced transaction and takes a `baseCost` parameter that represents the computational cost before the transaction validation.\n\nOverall, the `ErgoProver` interface is an important part of the `ergo-appkit` project as it defines the methods that a prover must implement to sign transactions and messages. Developers can use this interface to create custom provers that can sign transactions and messages in a variety of ways. Below is an example of how to use the `ErgoProver` interface to sign a transaction:\n\n```\nErgoProver prover = new MyCustomProver();\nUnsignedTransaction unsignedTx = new UnsignedTransaction();\nSignedTransaction signedTx = prover.sign(unsignedTx);\n```\n## Questions: \n 1. What is the purpose of this code file?\n    \n    This code file defines the interface for an ErgoProver, which can be used to sign transactions and messages in the Ergo blockchain.\n\n2. What is the difference between the `sign` and `signReduced` methods?\n    \n    The `sign` method signs an unsigned transaction, while the `signReduced` method signs a reduced transaction. A reduced transaction is a version of the transaction that has been simplified to reduce the computational cost of signing it.\n\n3. What is the `hintsBag` parameter in the `signMessage` method used for?\n    \n    The `hintsBag` parameter provides additional hints for the signer, which can be useful for distributed signing.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/ErgoProver.md"}}],["259",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/ErgoProverBuilder.java)\n\nThe `ErgoProverBuilder` interface is used to configure and build a new `ErgoProver` instance. The `ErgoProver` is used to generate proofs for spending Ergo tokens. The `ErgoProverBuilder` interface provides several methods to configure the `ErgoProver` instance.\n\nThe `withMnemonic` method is used to configure the `ErgoProverBuilder` to use a secret seed phrase and password to generate proofs. The `usePre1627KeyDerivation` parameter is used to specify whether to use the previous BIP32 derivation or not. The `withMnemonic` method can also be used to configure the `ErgoProverBuilder` to use a `Mnemonic` instance containing the secret seed phrase.\n\nThe `withEip3Secret` method is used to configure the `ErgoProverBuilder` to derive the new EIP-3 secret key with the given index. The derivation uses the master key derived from the mnemonic configured using the `withMnemonic` method.\n\nThe `withSecretStorage` method is used to configure the `ErgoProverBuilder` to use a `SecretStorage` instance containing an encrypted secret seed phrase to generate proofs.\n\nThe `withDHTData` method is used to configure the `ErgoProverBuilder` to use group elements and a secret integer for a ProveDHTuple statement when building a new `ErgoProver`. The ProveDHTuple statement consists of 4 group elements and requires the prover to prove knowledge of a secret integer. The `withDLogSecret` method is used to add additional secrets for use in proveDlog when the secret is not part of the wallet.\n\nThe `build` method is used to build a new `ErgoProver` instance using the provided configuration.\n\nExample usage:\n\n```\nErgoProverBuilder builder = new ErgoProverBuilderImpl();\nbuilder.withMnemonic(mnemonicPhrase, mnemonicPass, false);\nbuilder.withEip3Secret(0);\nErgoProver prover = builder.build();\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code defines an interface for configuring and building a new ErgoProver, which is used for generating proofs in the Ergo blockchain.\n\n2. What is the difference between `withMnemonic(SecretString, SecretString, Boolean)` and `withMnemonic(Mnemonic, Boolean)` methods?\n- The first method takes a secret seed phrase and its password as separate arguments, while the second method takes a Mnemonic instance containing the seed phrase and its password. Additionally, the first method allows specifying whether to use an incorrect BIP32 derivation for old wallets, while the second method assumes the correct derivation for old wallets.\n\n3. What is the purpose of the `withDHTData` method?\n- This method configures the builder to use group elements and a secret integer for a ProveDHTuple statement, which requires proving knowledge of the secret integer x such that u = g^x and y = h^x. This is used for Diffie-Hellman tuple protocols in the Ergo blockchain.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/ErgoProverBuilder.md"}}],["260",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/ExplorerAndPoolUnspentBoxesLoader.java)\n\nThe `ExplorerAndPoolUnspentBoxesLoader` class is an implementation of the `BoxOperations.IUnspentBoxesLoader` interface, which is used to load unspent boxes (i.e., boxes that have not been used as inputs in any transaction) for use in transactions made by the `BoxOperations` class. This implementation is designed to be used with the `BoxOperations#withInputBoxesLoader(BoxOperations.IUnspentBoxesLoader)` method.\n\nThe purpose of this implementation is to fetch the mempool from the node connected to and blacklist the inputs so they aren't used for transactions made by `BoxOperations` methods. Additionally, it allows the use of boxes available on mempool to be spent, allowing for chained transactions.\n\nThe `ExplorerAndPoolUnspentBoxesLoader` class has a `withAllowChainedTx(boolean allowChainedTx)` method that can be used to enable or disable the use of chained transactions. By default, this is set to `false`.\n\nThe class overrides several methods from the `BoxOperations.ExplorerApiWithCheckerLoader` class, which is the default implementation of the `BoxOperations.IUnspentBoxesLoader` interface. The `prepare(BlockchainContext ctx, List<Address> addresses, long grossAmount, List<ErgoToken> tokensToSpend)` method fetches the mempool from the node connected to and blacklists the inputs so they aren't used for transactions made by `BoxOperations` methods. The `prepareForAddress(Address address)` method resets the state of the loader for a new address. The `canUseBox(InputBox box)` method checks if a box can be used based on whether it has been blacklisted. The `loadBoxesPage(BlockchainContext ctx, Address sender, Integer page)` method loads a page of input boxes and, if there are no boxes available and chained transactions are allowed, fetches unconfirmed transactions for the address and adds its boxes as the last page.\n\nOverall, the `ExplorerAndPoolUnspentBoxesLoader` class provides a way to load unspent boxes for use in transactions made by `BoxOperations` methods while also allowing the use of boxes available on mempool to be spent and blacklisting inputs so they aren't used for transactions.\n## Questions: \n 1. What is the purpose of this class and how does it differ from the default implementation?\n   \n   This class is an implementation of the `BoxOperations.IUnspentBoxesLoader` interface that fetches the mempool from the node connected to and blacklists the inputs so they aren't used for transactions made by `BoxOperations` methods. It also allows for the use of boxes available on mempool to be spent, allowing for chained transactions. This differs from the default implementation by providing additional functionality for handling unspent boxes.\n\n2. What is the purpose of the `prepare` method and what does it do?\n   \n   The `prepare` method is used to prepare the loader for loading input boxes. It clears the list of unconfirmed spent box IDs and fetches unconfirmed transactions from the blockchain data source. It then adds the IDs of the input boxes from these transactions to the list of unconfirmed spent box IDs.\n\n3. What is the purpose of the `loadBoxesPage` method and how does it handle chained transactions?\n   \n   The `loadBoxesPage` method loads a page of input boxes for a given sender address. If the list of input boxes is empty and chained transactions are allowed, it fetches unconfirmed unspent boxes for the sender address and adds them as the last page of input boxes. This is done to allow for chained transactions where the output of one transaction is used as the input for another transaction.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/ExplorerAndPoolUnspentBoxesLoader.md"}}],["261",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/InputBox.java)\n\nThe `InputBox` interface is part of the `ergo-appkit` project and provides an interface for UTXO boxes that can be accessed in the blockchain node. This interface extends the `TransactionBox` interface and provides additional methods for interacting with input boxes.\n\nThe `getId()` method returns the ID of the input box. The `withContextVars()` method extends the given input with context variables and returns a new instance of `InputBox` with the given variables attached. The `toJson()` method returns a JSON representation of the transaction, with the option to pretty-print the ErgoTrees. The `getBytes()` method returns the serialized bytes representing this `InputBox`, including transaction reference data. The `getTransactionId()` method returns the ID of the transaction that created the box, and the `getTransactionIndex()` method returns the 0-based index of this box in the output list of the transaction that created the box. Finally, the `toErgoValue()` method returns this box as an Ergo value to store in a register.\n\nThis interface can be used in the larger project to interact with input boxes in the blockchain node. For example, the `getId()` method can be used to retrieve the ID of a specific input box, and the `withContextVars()` method can be used to extend the input box with context variables. The `toJson()` method can be used to obtain a JSON representation of the transaction, which can be useful for debugging and analysis. The `getBytes()` method can be used to obtain the serialized bytes representing the input box, which can be useful for low-level operations. The `getTransactionId()` and `getTransactionIndex()` methods can be used to obtain information about the transaction that created the box. Finally, the `toErgoValue()` method can be used to obtain an Ergo value representing the input box, which can be stored in a register.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines an interface for UTXO boxes that can be accessed in a blockchain node, and provides methods for getting the box ID, extending the input with context variables, getting the JSON representation of the transaction, getting the serialized bytes representing the input box, getting the transaction ID, getting the transaction index, and getting the box as an Ergo value to store in a register.\n\n2. What is the relationship between this code and other parts of the ergo-appkit project?\n- This code is part of the ergo-appkit project and can be used in conjunction with other classes and interfaces in the project to interact with the Ergo blockchain.\n\n3. What are some potential use cases for this code?\n- This code could be used to build applications that interact with the Ergo blockchain, such as wallets, exchanges, or other financial applications. It could also be used for research or analysis of the Ergo blockchain.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/InputBox.md"}}],["262",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/InputBoxesValidator.scala)\n\nThe `InputBoxesValidator` class is a box selector implementation that performs validation and calculates the necessary change box. It is part of the `ergo-appkit` project and is used to build transactions. Unlike the `DefaultBoxSelector` from `ergo-wallet`, this selector does not select input boxes. Instead, it validates the input boxes and calculates the necessary change box.\n\nThe `InputBoxesValidator` class extends the `BoxSelector` trait and overrides its `select` method. The `select` method takes an iterator of input boxes, an external filter, a target balance, and target assets. It returns either a `BoxSelectionResult` or a `BoxSelectionError`. The `BoxSelectionResult` contains the selected input boxes and the change boxes, while the `BoxSelectionError` contains an error message.\n\nThe `InputBoxesValidator` class also has a `formChangeBoxes` method that constructs change outputs. It takes the found balance, target balance, found box assets, and target box assets. It returns either a sequence of `ErgoBoxAssets` or a `BoxSelectionError`. The `ErgoBoxAssets` contains the balance and assets of a box.\n\nThe `InputBoxesValidator` class uses mutable structures to collect results. It selects all input boxes and validates them. It then checks if it found all the required tokens. If it did, it constructs the change boxes using the `formChangeBoxes` method. If it did not, it returns a `NotEnoughTokensError`. If it did not find enough ERGs, it returns a `NotEnoughErgsError`.\n\nIn summary, the `InputBoxesValidator` class is a box selector implementation that performs validation and calculates the necessary change box. It is used to build transactions in the `ergo-appkit` project. It selects all input boxes, validates them, and constructs the change boxes. If it encounters an error, it returns a `BoxSelectionError`.\n## Questions: \n 1. What is the purpose of this code and how does it differ from DefaultBoxSelector from ergo-wallet?\n- This code is a pass-through implementation of the box selector that performs validation and calculates the necessary change box. Unlike DefaultBoxSelector from ergo-wallet, it does not select input boxes as it is done in appkit.\n\n2. What is the role of the formChangeBoxes method?\n- The formChangeBoxes method is a helper method that constructs change outputs. It takes in the found balance, target balance, found box assets, and target box assets, and returns either an error or a sequence of ErgoBoxAssets representing the change boxes.\n\n3. What happens if there are not enough tokens in the input boxes to send the target assets?\n- If there are not enough tokens in the input boxes to send the target assets, the code will return a NotEnoughTokensError with a message indicating that there are not enough tokens in the input boxes to send the target assets.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/InputBoxesValidator.md"}}],["263",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/InputBoxesValidatorJavaHelper.scala)\n\nThe `InputBoxesValidatorJavaHelper` object provides a method for validating a list of unspent input boxes to ensure they contain enough funds and tokens to cover a specified amount and set of tokens. This is useful for constructing transactions in the Ergo blockchain.\n\nThe `validateBoxes` method takes three arguments: a list of `InputBox` objects representing unspent boxes, a `Long` amount to spend, and a list of `ErgoToken` objects representing the tokens to spend. The method first converts the `unspentBoxes` and `tokensToSpend` arguments to Scala collections using the `convertTo` method from the `Iso` object. It then creates a `targetAssets` map from the `tokensToSpend` argument. \n\nThe method then calls the `select` method of an `InputBoxesValidator` object with the converted `inputBoxes`, `amountToSpend`, and `targetAssets` arguments. The `select` method returns either a `Left` value representing an error or a `Right` value representing a successful selection of input boxes. \n\nIf the `select` method returns a `Left` value, the method throws an exception based on the type of error. If the error is a `NotEnoughCoinsForChangeBoxesError`, the method throws a `NotEnoughCoinsForChangeException`. If the error is a `NotEnoughErgsError`, the method checks if the balance found in the input boxes is greater than or equal to the amount to spend. If it is, the method throws a `NotEnoughCoinsForChangeException`. Otherwise, the method throws a `NotEnoughErgsException`. If the error is a `NotEnoughTokensError`, the method creates a `HashMap` of token IDs and values and throws a `NotEnoughTokensException`. If the error is any other type of error, the method throws an `InputBoxesSelectionException`.\n\nIf the `select` method returns a `Right` value, the method does nothing and returns `Unit`.\n\nOverall, this code provides a useful utility for validating input boxes for constructing transactions in the Ergo blockchain. Here is an example usage of the `validateBoxes` method:\n\n```scala\nimport org.ergoplatform.appkit._\n\nval unspentBoxes: java.util.List[InputBox] = ???\nval amountToSpend: Long = ???\nval tokensToSpend: java.util.List[ErgoToken] = ???\n\nInputBoxesValidatorJavaHelper.validateBoxes(unspentBoxes, amountToSpend, tokensToSpend)\n```\n## Questions: \n 1. What is the purpose of the `InputBoxesValidatorJavaHelper` object?\n- The `InputBoxesValidatorJavaHelper` object provides a method `validateBoxes` that validates a list of unspent input boxes against a target amount and tokens to spend.\n\n2. What external libraries or dependencies does this code use?\n- This code uses several external libraries including `org.ergoplatform`, `scorex.util`, and `java.util`.\n\n3. What exceptions can be thrown by the `validateBoxes` method?\n- The `validateBoxes` method can throw several exceptions including `NotEnoughErgsException`, `NotEnoughTokensException`, and `InputBoxesSelectionException`.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/InputBoxesValidatorJavaHelper.md"}}],["264",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/OutBox.java)\n\nThe code above defines an interface called `OutBox` which represents output boxes on newly created transactions. Each `OutBox` corresponds to an `ErgoBoxCandidate` which is not yet part of the Unspent Transaction Output (UTXO) and hence doesn't have a transaction id and box index parameter. \n\nThe `OutBox` interface extends the `TransactionBox` interface, which means that it inherits all the methods defined in the `TransactionBox` interface. \n\nThe `OutBox` interface has two methods defined in it. The first method, `getBytesWithNoRef()`, returns the serialized bytes of this output box without any transaction reference data. This method can be used to get the serialized bytes of the output box, which can be useful for debugging purposes or for sending the output box to another node. \n\nThe second method, `convertToInputWith(String txId, short outputIndex)`, converts this box candidate into a new instance of `InputBox` by associating it with the given transaction and output position. This method can be used to create input boxes from scratch, without retrieving them from the UTXOs. Thus created boxes can be indistinguishable from those loaded from the blockchain node, and as a result, can be used to create new transactions. This method can also be used to create chains of transactions in advance. \n\nOverall, the `OutBox` interface is an important part of the `ergo-appkit` project as it provides a way to represent output boxes on newly created transactions and convert them into input boxes. This interface can be used by developers to create new transactions and interact with the Ergo blockchain. \n\nExample usage of `OutBox` interface:\n\n```java\nOutBox outBox = new OutBoxImpl(); // create a new instance of OutBox\nbyte[] bytes = outBox.getBytesWithNoRef(); // get the serialized bytes of the output box\nInputBox inputBox = outBox.convertToInputWith(\"txId\", (short) 0); // convert the output box to an input box\n```\n## Questions: \n 1. What is the purpose of the `OutBox` interface?\n- The `OutBox` interface is used to represent output boxes on newly created transactions that correspond to `ErgoBoxCandidate` which is not yet part of UTXO and hence doesn't have transaction id and box index parameter.\n\n2. What is the `getBytesWithNoRef()` method used for?\n- The `getBytesWithNoRef()` method is used to return the serialized bytes of this output box without any transaction reference data.\n\n3. What is the purpose of the `convertToInputWith()` method?\n- The `convertToInputWith()` method is used to convert this box candidate into a new instance of `InputBox` by associating it with the given transaction and output position. This method can be used to create input boxes from scratch, without retrieving them from the UTXOs, and can also be used to create chains of transactions in advance.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/OutBox.md"}}],["265",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/OutBoxBuilder.java)\n\nThe `OutBoxBuilder` interface is a part of the `ergo-appkit` project and is used to build a new output box that can be included in a new unsigned transaction. When the transaction is signed, sent to the blockchain, and then included by miners in a new block, the output constructed using this builder will be added to the UTXO set.\n\nThe `OutBoxBuilder` interface has several methods that can be used to configure the output box. The `value` method is used to configure the Erg amount of the output box. The `contract` method is used to configure the guarding contract of the output box. This contract will be compiled into ErgoTree, serialized, and then sent to the blockchain as part of the signed transaction. The `tokens` method is used to configure amounts for one or more tokens. Each Ergo box can store zero or more tokens. The `mintToken` method is used to mint a new token according to the EIP-0004 standard. The `registers` method is used to configure one or more optional registers of the output box. Each box has 4 mandatory registers holding the value of NanoErgs, guarding script, tokens, and creation info. Optional registers numbered from index 4 up to 9. The `creationHeight` method is used to configure the height when the transaction containing the box was created. This height, when explicitly specified, should not exceed the height of the block containing the transaction with this output box.\n\nThe `build` method is used to create an `OutBox` instance using the specified parameters. The output box can be added to an unsigned transaction using the `UnsignedTransactionBuilder` class.\n\nHere is an example of how to use the `OutBoxBuilder` interface to create an output box:\n\n```\nOutBoxBuilder outBoxBuilder = unsignedTxBuilder.outBoxBuilder()\n    .value(1000000000L)\n    .contract(new ErgoTreeContract(new ErgoTree(new byte[] {0x01, 0x02, 0x03})))\n    .tokens(new ErgoToken(\"Token1\", 100), new ErgoToken(\"Token2\", 200))\n    .registers(new LongConstant(12345L), new ByteArrayConstant(new byte[] {0x01, 0x02, 0x03}))\n    .creationHeight(1000);\n\nOutBox outBox = outBoxBuilder.build();\nunsignedTxBuilder.outputs(outBox);\n```\n\nIn this example, an `OutBoxBuilder` instance is created using the `outBoxBuilder` method of an `UnsignedTransactionBuilder` instance. The `value` method is used to set the Erg amount of the output box to 1000000000L. The `contract` method is used to set the guarding contract of the output box to an `ErgoTreeContract` instance. The `tokens` method is used to set the amounts for two tokens. The `registers` method is used to set two optional registers of the output box. The `creationHeight` method is used to set the height when the transaction containing the box was created to 1000. Finally, the `build` method is used to create an `OutBox` instance, which is added to the unsigned transaction using the `outputs` method of the `UnsignedTransactionBuilder` instance.\n## Questions: \n 1. What is the purpose of this interface and how is it used in the Ergo platform?\n- This interface is used to build a new output box that can be included in a new unsigned transaction. When the transaction is signed, sent to the blockchain, and included by miners in a new block, the output constructed using this builder will be added to the UTXO set.\n\n2. What are the different methods available in this interface and what do they do?\n- The `value` method configures the Erg amount of the output box. The `contract` method configures the guarding contract of the output box. The `tokens` method configures amounts for one or more tokens. The `mintToken` method mints a new token. The `registers` method configures one or more optional registers of the output box. The `creationHeight` method configures the height when the transaction containing the box was created. The `build` method creates an `OutBox` instance using the specified parameters.\n\n3. What is the relationship between this interface and other classes in the Ergo platform?\n- This interface is used in conjunction with other classes in the Ergo platform, such as `UnsignedTransactionBuilder`, `ErgoContract`, `ErgoToken`, `Eip4Token`, `ErgoValue`, `BlockchainContext`, and `OutBox`. It is used to build output boxes that can be added to unsigned transactions, which can then be signed and sent to the blockchain.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/OutBoxBuilder.md"}}],["266",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/PreHeader.java)\n\nThe code above defines an interface called PreHeader, which is a part of the ergo-appkit project. The purpose of this interface is to define the header fields that can be predicted by a miner. The PreHeader interface has seven methods that define the fields of a block header. These fields include the block version, the ID of the parent block, the block timestamp, the current difficulty, the block height, the miner public key, and the votes.\n\nThe getVersion() method returns the version of the block, which is incremented on every soft and hard fork. The getParentId() method returns the ID of the parent block, which is a collection of bytes. The getTimestamp() method returns the timestamp of the block in milliseconds since the beginning of the Unix Epoch. The getNBits() method returns the current difficulty of the block in a compressed view. The getHeight() method returns the height of the block. The getMinerPk() method returns the public key of the miner, which should be used to collect block rewards. Finally, the getVotes() method returns the votes for the block.\n\nThis interface can be used in the larger project to define the header of a block. By implementing this interface, developers can ensure that the header fields are consistent with the requirements of the ergo-appkit project. For example, a developer can create a class that implements the PreHeader interface and defines the header fields for a block. This class can then be used to create a block and submit it to the network.\n\nHere is an example of how this interface can be used:\n\n```\npublic class MyBlockHeader implements PreHeader {\n    private byte version;\n    private Coll<Byte> parentId;\n    private long timestamp;\n    private long nBits;\n    private int height;\n    private GroupElement minerPk;\n    private Coll<Byte> votes;\n\n    public MyBlockHeader(byte version, Coll<Byte> parentId, long timestamp, long nBits, int height, GroupElement minerPk, Coll<Byte> votes) {\n        this.version = version;\n        this.parentId = parentId;\n        this.timestamp = timestamp;\n        this.nBits = nBits;\n        this.height = height;\n        this.minerPk = minerPk;\n        this.votes = votes;\n    }\n\n    @Override\n    public byte getVersion() {\n        return version;\n    }\n\n    @Override\n    public Coll<Byte> getParentId() {\n        return parentId;\n    }\n\n    @Override\n    public long getTimestamp() {\n        return timestamp;\n    }\n\n    @Override\n    public long getNBits() {\n        return nBits;\n    }\n\n    @Override\n    public int getHeight() {\n        return height;\n    }\n\n    @Override\n    public GroupElement getMinerPk() {\n        return minerPk;\n    }\n\n    @Override\n    public Coll<Byte> getVotes() {\n        return votes;\n    }\n}\n```\n\nIn this example, a class called MyBlockHeader implements the PreHeader interface. The constructor of this class takes in the header fields as parameters and initializes the instance variables. The methods of the PreHeader interface are then implemented to return the corresponding instance variables. This class can then be used to create a block header and submit it to the network.\n## Questions: \n 1. What is the purpose of the `special.collection.Coll` and `special.sigma.GroupElement` imports?\n- A smart developer might wonder what these imports are used for and how they relate to the `PreHeader` interface. These imports are likely used for data structures and cryptographic operations within the `PreHeader` interface.\n\n2. What is the significance of the `getVotes()` method?\n- A smart developer might question why the `getVotes()` method is included in the `PreHeader` interface and what it returns. This method likely returns a collection of votes related to a consensus mechanism used by the blockchain.\n\n3. How is the `PreHeader` interface used within the `ergoplatform.appkit` project?\n- A smart developer might want to know how the `PreHeader` interface is implemented and used within the larger `ergoplatform.appkit` project. This interface is likely used to define and manipulate pre-header data for blocks in the blockchain.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/PreHeader.md"}}],["267",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/PreHeaderBuilder.java)\n\nThe code above is an interface called PreHeaderBuilder, which is part of the ergo-appkit project. This interface allows the building of PreHeaders to be used for transaction signing. PreHeaders are used to simulate the execution of contracts in specific contexts, resulting in corresponding signatures (aka proofs) to be generated for the transaction. \n\nThe PreHeaderBuilder interface has several methods that allow the setting of different parameters of the preheader. These methods include version, parentId, timestamp, nBits, height, minerPk, and votes. \n\nThe version method sets the block version, which is to be increased on every soft and hardfork. The parentId method sets the ID of the parent block. The timestamp method sets the block timestamp in milliseconds since the beginning of Unix Epoch. The nBits method sets the current difficulty in a compressed view. The height method sets the block height. The minerPk method sets the miner public key, which should be used to collect block rewards. Finally, the votes method sets the votes for the block. \n\nOnce all the necessary parameters have been set, the build method is called to create the PreHeader. The PreHeader can then be used for transaction signing. \n\nHere is an example of how the PreHeaderBuilder interface can be used in the larger project:\n\n```\nPreHeaderBuilder preHeaderBuilder = new PreHeaderBuilderImpl();\nPreHeader preHeader = preHeaderBuilder\n    .version(1)\n    .parentId(parentId)\n    .timestamp(timestamp)\n    .nBits(nbits)\n    .height(height)\n    .minerPk(minerPk)\n    .votes(votes)\n    .build();\n```\n\nIn the example above, a new PreHeaderBuilderImpl object is created, and the necessary parameters are set using the methods provided by the PreHeaderBuilder interface. Finally, the build method is called to create the PreHeader object. This PreHeader object can then be used for transaction signing.\n## Questions: \n 1. What is the purpose of the `PreHeaderBuilder` interface?\n    \n    The `PreHeaderBuilder` interface allows for the building of PreHeaders to be used for transaction signing, with the ability to set different parameters to simulate execution of contracts in specific contexts.\n\n2. What are the parameters that can be set using the `PreHeaderBuilder` interface?\n    \n    The parameters that can be set using the `PreHeaderBuilder` interface include the block version, parent block ID, block timestamp, current difficulty, block height, miner public key, and votes.\n\n3. What is the expected output of the `build()` method?\n    \n    The `build()` method is expected to return a `PreHeader` object, which can be used for transaction signing.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/PreHeaderBuilder.md"}}],["268",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/ReducedTransaction.java)\n\nThe `ReducedTransaction` interface is a part of the `ergo-appkit` project and is used to represent an unsigned transaction that has been reduced. A reduced transaction is an unsigned transaction that has been augmented with one `ReductionResult` for each `UnsignedInput`. The `ReducedTransaction` interface extends the `Transaction` interface, which means that it inherits all the methods of the `Transaction` interface.\n\nThe `ReducedTransaction` interface has three methods: `getTx()`, `getCost()`, and `toBytes()`. The `getTx()` method returns the underlying reduced transaction data. The `getCost()` method returns the cost accumulated while reducing the original unsigned transaction. The `toBytes()` method returns the serialized bytes of this transaction.\n\nThe `ReducedTransaction` interface can be used in the larger project to represent an unsigned transaction that has been reduced. For example, the `ReducedTransaction` interface can be used in a smart contract that requires an unsigned transaction to be reduced before it can be executed. The `ReducedTransaction` interface can also be used in a wallet application that allows users to create and sign transactions.\n\nHere is an example of how the `ReducedTransaction` interface can be used:\n\n```\n// create an unsigned transaction\nUnsignedTransaction unsignedTx = new UnsignedTransaction(inputs, outputs);\n\n// reduce the unsigned transaction\nReducedTransaction reducedTx = unsignedTx.reduce();\n\n// get the underlying reduced transaction data\nReducedErgoLikeTransaction reducedData = reducedTx.getTx();\n\n// get the cost accumulated while reducing the original unsigned transaction\nint cost = reducedTx.getCost();\n\n// serialize the reduced transaction\nbyte[] serializedTx = reducedTx.toBytes();\n```\n\nIn this example, we create an unsigned transaction using the `UnsignedTransaction` class. We then reduce the unsigned transaction using the `reduce()` method, which returns a `ReducedTransaction` object. We can then use the methods of the `ReducedTransaction` interface to get the underlying reduced transaction data, the cost accumulated while reducing the original unsigned transaction, and the serialized bytes of the reduced transaction.\n## Questions: \n 1. What is the purpose of this interface and how is it used in the ergo-appkit project?\n   - This interface represents an unsigned transaction that has been reduced and augmented with a `ReductionResult` for each `UnsignedInput`. It can be obtained by reducing an unsigned transaction. It is used to provide access to the reduced transaction data, cost, and serialized bytes.\n2. What is a `ReducedErgoLikeTransaction` and how is it related to this interface?\n   - `ReducedErgoLikeTransaction` is the underlying reduced transaction data that can be accessed through the `getTx()` method of this interface. It contains the reduced inputs and outputs of the original unsigned transaction.\n3. How is the cost of reducing the original unsigned transaction calculated and what does it represent?\n   - The cost of reducing the original unsigned transaction can be obtained through the `getCost()` method of this interface. It represents the amount of resources (e.g. time, memory) required to perform the reduction process.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/ReducedTransaction.md"}}],["269",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/SignedInput.java)\n\nThe code above defines an interface called `SignedInput` which represents an input of a `SignedTransaction`. A `SignedInput` contains information necessary to spend the input, including proofs of knowledge of necessary secrets (aka signatures). These proofs are generated by an `ErgoProver` configured with the secrets. When the transaction is validated, the proofs are verified (this is a generalization of a signature verification). \n\nThe `SignedInput` interface has four methods. The `getProofBytes()` method returns the bytes of the generated proofs (aka generalized signature). The `getContextVars()` method returns context variables attached by the prover to this input. These variables will be passed to the contract which protects this input. Each variable is accessible by id using the `getVar` function of ErgoScript. The `getId()` method returns the id of the box, which will be spent by the transaction. Finally, the `getTransaction()` method returns the transaction which contains this input.\n\nThis interface is an important part of the `ergo-appkit` project as it allows developers to create and manipulate `SignedInput` objects, which are necessary for creating and validating transactions on the Ergo blockchain. For example, a developer could create a `SignedInput` object and set its `proofBytes` and `contextVars` fields to the appropriate values, then add it to a `SignedTransaction` object using the `addInput()` method. The `SignedTransaction` object could then be signed and broadcast to the network using the `ErgoClient` class. \n\nOverall, the `SignedInput` interface provides a way for developers to interact with inputs in a transaction, including providing the necessary proofs and context variables for validation.\n## Questions: \n 1. What is the purpose of this code?\n- This code defines an interface for representing an input of a signed transaction in the Ergo blockchain platform.\n\n2. What is the significance of the `getProofBytes()` method?\n- The `getProofBytes()` method returns the bytes of the generated proofs (aka generalized signature) necessary to spend the input.\n\n3. What is the purpose of the `getContextVars()` method?\n- The `getContextVars()` method returns context variables attached by the prover to this input, which will be passed to the contract that protects this input. Each variable is accessible by id using the `getVar` function of ErgoScript.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/SignedInput.md"}}],["270",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/SignedTransaction.java)\n\nThe `SignedTransaction` interface is a representation of a signed transaction that can be sent to the blockchain. It extends the `Transaction` interface and provides additional methods for working with signed transactions.\n\nThe `toJson` method returns a JSON representation of the transaction. It takes a boolean parameter `prettyPrint` which determines whether the ErgoTrees will be pretty printed or output as hex strings. There is also an overloaded version of this method that takes an additional boolean parameter `formatJson` which determines whether the JSON output will be pretty printed.\n\nThe `getSignedInputs` method returns a list of all signed inputs that will be spent when the transaction is included in the blockchain. Each signed input has an attached signature (proof) that evidences that the prover knows the required secrets.\n\nThe `getOutputsToSpend` method returns a list of outputs of the transaction represented as `InputBox` objects ready to be spent in the next chained transaction. This method can be used to create a chain of transactions.\n\nThe `getCost` method returns the estimated cost of the transaction. Note that this cost is only an approximation of the actual cost of the transaction, which may depend on the blockchain context.\n\nThe `toBytes` method returns the serialized bytes of the transaction.\n\nOverall, the `SignedTransaction` interface provides a way to work with signed transactions in the Ergo platform. It can be used to create, sign, and send transactions to the blockchain. For example, a developer could use this interface to create a new transaction, sign it with a prover, and then send it to the blockchain using the `ErgoClient` class provided by the `ergo-appkit` project.\n## Questions: \n 1. What is the purpose of this interface and how does it relate to the Ergo blockchain?\n- This interface represents a signed transaction that can be sent to the Ergo blockchain. It contains signed inputs and outputs represented as InputBox objects, and provides methods for getting a JSON representation of the transaction, estimating its cost, and getting its serialized bytes.\n\n2. What is the difference between the two toJson() methods?\n- The first toJson() method takes a boolean parameter for pretty-printing the ErgoTrees in the JSON output, while the second method takes two boolean parameters for pretty-printing the ErgoTree and the JSON output, respectively.\n\n3. How can the getOutputsToSpend() method be used to create a chain of transactions?\n- The getOutputsToSpend() method returns a list of InputBox objects that can be used as input boxes for a new transaction. By calling this method on a SignedTransaction object and passing the resulting list of InputBox objects to the inputs parameter of a new UnsignedTransaction object, a chain of transactions can be created.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/SignedTransaction.md"}}],["271",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/Transaction.java)\n\nThe code above defines an interface called `Transaction` that represents a transaction in the Ergo blockchain platform. This interface provides methods that are available for all types of transactions, including `ReducedTransaction`, `SignedTransaction`, and `UnsignedTransaction`.\n\nThe `getId()` method returns the transaction ID as a Base16 string. The transaction ID is a unique identifier for the transaction and is used to reference the transaction in other parts of the Ergo platform.\n\nThe `getInputBoxesIds()` method returns a list of input box IDs for the transaction. In the Ergo platform, a box is a container for tokens and can be thought of as a digital asset. The input boxes for a transaction are the boxes that are being spent in the transaction.\n\nThe `getOutputs()` method returns a list of output boxes that will be created by the transaction. These output boxes represent the new boxes that are being created as a result of the transaction. Each output box contains a set of tokens and can be thought of as a new digital asset that is being created.\n\nThis interface is an important part of the Ergo Appkit project as it provides a standardized way to interact with transactions in the Ergo platform. Developers can use this interface to build applications that interact with the Ergo blockchain, such as wallets, exchanges, and other financial applications.\n\nHere is an example of how this interface can be used in a Java application:\n\n```\nimport org.ergoplatform.appkit.*;\n\npublic class MyTransaction {\n    public static void main(String[] args) {\n        // create a new transaction\n        Transaction tx = new UnsignedTransaction();\n\n        // get the transaction ID\n        String txId = tx.getId();\n\n        // get the input box IDs\n        List<String> inputBoxIds = tx.getInputBoxesIds();\n\n        // get the output boxes\n        List<OutBox> outputBoxes = tx.getOutputs();\n\n        // do something with the transaction data\n        // ...\n    }\n}\n```\n\nIn this example, we create a new `UnsignedTransaction` object and use the methods provided by the `Transaction` interface to get the transaction ID, input box IDs, and output boxes. We can then use this data to perform some action in our application.\n## Questions: \n 1. What is the purpose of the `Transaction` interface?\n- The `Transaction` interface represents a transaction and provides methods that are available for all of `ReducedTransaction`, `SignedTransaction`, and `UnsignedTransaction`.\n\n2. What does the `getId()` method return?\n- The `getId()` method returns the transaction id as a Base16 string.\n\n3. What does the `getOutputs()` method do?\n- The `getOutputs()` method gets the output boxes that will be created by this transaction.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/Transaction.md"}}],["272",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/TransactionBox.java)\n\nThe `TransactionBox` interface represents a box on a transaction, which can be either an `InputBox` or an `OutBox`. This interface provides several methods to retrieve information about the box, such as its value, creation height, tokens, registers, ErgoTree, and BoxAttachment.\n\nThe `getValue()` method returns the nanoERG value stored in the box, which represents the unspent value in UTXO. The `getCreationHeight()` method returns the height (block number) when the transaction containing this output box was created. The `getTokens()` method returns a list of `ErgoToken` objects stored in the box. The `getRegisters()` method returns a list of `ErgoValue` objects representing the values of the non-mandatory registers which are stored in the box (R4, R5, R6, R7, R8, R9). The index 0 corresponds to R4, 1 corresponds to R5, and so on. The `getErgoTree()` method returns the `ErgoTree` of the script guarding the box. Finally, the `getAttachment()` method returns the `BoxAttachment` stored in this box or null.\n\nThis interface is likely to be used extensively in the Ergo platform, which is a blockchain platform for creating decentralized applications. Developers can use this interface to retrieve information about boxes on a transaction, which can be used to implement various features of their applications. For example, a developer might use the `getValue()` method to calculate the total value of a transaction, or the `getTokens()` method to retrieve information about the tokens involved in a transaction. The `getErgoTree()` method can be used to retrieve the script guarding a box, which can be used to verify the validity of a transaction. Overall, the `TransactionBox` interface is an essential component of the Ergo platform, providing developers with a powerful tool for building decentralized applications.\n## Questions: \n 1. What is the purpose of this interface and how is it used in the ergo-appkit project?\n- This interface represents a box on a transaction, either an InputBox or an OutBox, and provides methods to retrieve information about the box such as its value, creation height, tokens, registers, ErgoTree, and BoxAttachment. It is likely used throughout the ergo-appkit project to interact with transaction boxes.\n\n2. What is the difference between an InputBox and an OutBox?\n- The code does not provide information on the difference between an InputBox and an OutBox. However, the interface references both types of boxes and provides links to their respective classes, suggesting that they are both used in the ergo-appkit project and have different implementations.\n\n3. What is the purpose of the getRegisters() method and how are the registers used in the ergo-appkit project?\n- The getRegisters() method returns values of the non-mandatory registers which are stored in the box (R4, R5, R6, R7, R8, R9). The purpose of these registers and how they are used in the ergo-appkit project is not clear from the code alone.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/TransactionBox.md"}}],["273",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/UnsignedTransaction.java)\n\nThe `UnsignedTransaction` interface is a part of the `ergo-appkit` project and is used to represent unsigned transactions after they are built using the `UnsignedTransactionBuilder`. This interface extends the `Transaction` interface and provides additional methods to retrieve information about the unsigned transaction.\n\nThe `getInputs()` method returns a list of unsigned input boxes that will be used in the transaction. The `getDataInputs()` method returns a list of data inputs that will be used in the transaction. The `getChangeAddress()` method returns the change address associated with the unsigned transaction.\n\nThe `getTokensToBurn()` method returns a list of tokens requested for burning in the transaction. If no burning was explicitly requested, an empty list is returned.\n\nThe `toJson(boolean prettyPrint)` method returns a formatted (pretty printed) JSON string representation of the transaction. The `toJson(boolean prettyPrint, boolean formatJson)` method returns a string with JSON text representation of the transaction. If `prettyPrint` is set to `true`, the ErgoTrees will be pretty printed, otherwise they will be output as hex strings. If `formatJson` is set to `true`, the JSON pretty printer is used to format the JSON output.\n\nThis interface can be used in the larger project to build and represent unsigned transactions. The `UnsignedTransactionBuilder` can be used to build unsigned transactions, and the `UnsignedTransaction` interface can be used to represent them. The methods provided by this interface can be used to retrieve information about the unsigned transaction, such as the input boxes, data inputs, change address, and tokens requested for burning. The `toJson()` methods can be used to obtain a JSON representation of the transaction.\n## Questions: \n 1. What is the purpose of the `UnsignedTransaction` interface?\n- The `UnsignedTransaction` interface is used to represent unsigned transactions after they are built using `UnsignedTransactionBuilder`.\n\n2. What methods are available for retrieving information about the transaction inputs?\n- The `getInputs()` method returns a list of unsigned input boxes that will be used in this transaction, while the `getDataInputs()` method returns a list of data inputs that will be used in this transaction.\n\n3. What is the purpose of the `getTokensToBurn()` method?\n- The `getTokensToBurn()` method returns a list of tokens requested (in builders) for burning in this transaction when it will be executed on blockchain. If no burning was explicitly requested, an empty list is returned.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/UnsignedTransaction.md"}}],["274",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/UnsignedTransactionBuilder.java)\n\nThe `UnsignedTransactionBuilder` interface is used to build a new `UnsignedTransaction` which can later be signed by an `ErgoProver`. A new instance of this builder can be obtained from the `BlockchainContext`. Before the unsigned transaction can be sent to the blockchain, it should be signed by a prover. The prover should be constructed by the `ErgoProverBuilder` obtained from the same `BlockchainContext`.\n\nThis interface provides several methods to add inputs, data inputs, outputs, transaction fees, tokens to burn, and change outputs to the transaction. The `addInputs` method adds input boxes to an already specified list of inputs or, if no input boxes are defined yet, as the boxes to spend. The `addDataInputs` method adds input boxes to an already specified list of data inputs or, if no data input boxes are defined yet, sets the boxes as the data input boxes to be used. The `addOutputs` method adds output boxes to an already specified list of outputs or, if no output boxes are defined yet, as the boxes to be output. The `fee` method configures the transaction fee amount in NanoErgs. The `tokensToBurn` method configures amounts for tokens to be burnt. The `sendChangeTo` method adds a change output to the specified address if needed.\n\nThe `build` method builds a new unsigned transaction in the `BlockchainContext` inherited from this builder. The `getCtx` method returns the context for which this builder is building transactions. The `getPreHeader` method returns the current (either default of configured) pre-header. The `getNetworkType` method returns the network type of the blockchain represented by the context of this builder. The `outBoxBuilder` method creates a new builder of output box. The `getInputBoxes` method returns all input boxes attached to this builder. The `getOutputBoxes` method returns all output boxes attached to this builder.\n\nOverall, this interface provides a convenient way to build unsigned transactions for the Ergo blockchain. It allows developers to specify inputs, data inputs, outputs, transaction fees, tokens to burn, and change outputs for the transaction. Once the transaction is built, it can be signed by a prover and sent to the blockchain.\n## Questions: \n 1. What is the purpose of this interface and how does it relate to the Ergo blockchain?\n- This interface is used to build a new unsigned transaction that can later be signed by a prover and sent to the Ergo blockchain. It is obtained from the BlockchainContext and allows for the addition of input and output boxes, transaction fees, and token burning.\n\n2. What is the difference between addInputs() and addDataInputs() methods?\n- The addInputs() method adds input boxes to the list of boxes to spend, while the addDataInputs() method adds input boxes to the list of data input boxes to be used. Both methods take an array of InputBox objects as a parameter.\n\n3. What is the purpose of the outBoxBuilder() method?\n- The outBoxBuilder() method creates a new builder of output boxes, which can be used to build a single instance of OutBox. A new OutBoxBuilder should be created for each new OutBox.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/UnsignedTransactionBuilder.md"}}],["275",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/babelfee/BabelFeeBoxContract.java)\n\nThe `BabelFeeBoxContract` class is a representation of a smart contract used in the Ergo blockchain. The purpose of this contract is to create a box (a data structure that holds assets in the Ergo blockchain) that can be used to pay for transaction fees in the Ergo network. \n\nThe contract is defined by an ErgoTreeTemplate, which is a binary representation of the contract's logic. The `contractTemplateHex` variable contains the hexadecimal representation of the ErgoTreeTemplate. The `contractTemplate` variable is a byte array that is obtained by decoding the `contractTemplateHex` variable. \n\nThe `BabelFeeBoxContract` class has two constructors. The first constructor takes an `ErgoId` object as a parameter. The `ErgoId` object represents the token that will be used to pay for transaction fees. The constructor creates an `ErgoTree` object by applying the `tokenId` parameter to the `contractTemplate`. The resulting `ErgoTree` object is stored in the `ergoTree` field. \n\nThe second constructor takes an `ErgoTree` object as a parameter. The `ErgoTree` object represents the contract's logic. The constructor creates an `ErgoId` object by extracting the token ID from the `ErgoTree` object. The `ErgoId` object is stored in the `tokenId` field. \n\nThe `getErgoTree` method returns the `ergoTree` field, which contains the contract's logic in the form of an `ErgoTree` object. The `getTokenId` method returns the `tokenId` field, which contains the token ID used to pay for transaction fees. \n\nThis class can be used in the larger project to create boxes that can be used to pay for transaction fees. For example, the following code creates a `BabelFeeBoxContract` object and uses it to create a box that can be used to pay for transaction fees:\n\n```\nErgoId tokenId = new ErgoId(\"1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\");\nBabelFeeBoxContract contract = new BabelFeeBoxContract(tokenId);\nValues.ErgoTree ergoTree = contract.getErgoTree();\nlong value = 1000000000L;\nErgoBox box = new ErgoBox(value, ergoTree);\n```\n\nIn this example, a new `ErgoId` object is created with a random token ID. A new `BabelFeeBoxContract` object is created with the `ErgoId` object as a parameter. The `getErgoTree` method is called to obtain the `ErgoTree` object. A new `ErgoBox` object is created with the `ErgoTree` object and a value of 1 Ergo. This box can be used to pay for transaction fees in the Ergo network.\n## Questions: \n 1. What is the purpose of this code and what problem does it solve?\n- This code defines a class called `BabelFeeBoxContract` which represents a smart contract used for Ergo blockchain transactions. It solves the problem of creating and managing a smart contract for handling fees in the Ergo blockchain.\n\n2. What is the significance of the `templateHash` variable?\n- The `templateHash` variable is a string representation of the hash of the ErgoTreeTemplate used by the `BabelFeeBoxContract`. It is used for Explorer requests to identify the contract.\n\n3. What is the difference between the two constructors of the `BabelFeeBoxContract` class?\n- The first constructor takes an `ErgoId` as a parameter and creates an `ErgoTree` using the `contractTemplate` and the `tokenId`. The second constructor takes an `ErgoTree` as a parameter and creates an `ErgoId` from the `tokenId` parameter of the `ErgoTree`.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/babelfee/BabelFeeBoxContract.md"}}],["276",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/babelfee/BabelFeeBoxState.java)\n\nThe `BabelFeeBoxState` class represents a state of a Babel Fee Box, which is a contract that allows paying transaction fees in tokens instead of the platform's primary token (ERG). This class provides methods to interact with the Babel Fee Box, such as calculating the amount of tokens to sell to receive a certain amount of nanoErgs, building a new Babel Fee Box state after a token swap, and building an `OutBox` representing the Babel Fee Box.\n\nThe constructor of the `BabelFeeBoxState` class takes a `TransactionBox` object as input and extracts the necessary information from it to initialize the state of the Babel Fee Box. The `TransactionBox` object represents an unspent output box of a transaction on the Ergo blockchain. The `BabelFeeBoxState` class extracts the value, registers, and tokens of the `TransactionBox` object to initialize the `value`, `boxCreator`, `pricePerToken`, `tokenId`, and `tokenAmount` fields of the `BabelFeeBoxState` object. The `value` field represents the overall nanoErg value in the box, the `boxCreator` field represents the owner of the Babel Fee Box, the `pricePerToken` field represents the nanoErg amount offered per raw token amount, the `tokenId` field represents the token id this Babel Fee Box is offering change for, and the `tokenAmount` field represents the raw amount of tokens already collected in the box.\n\nThe `BabelFeeBoxState` class provides getter methods for the `pricePerToken`, `tokenId`, `boxCreator`, `value`, and `tokenAmount` fields. It also provides methods to calculate the overall ERG value available to change for tokens, the max token raw amount possible to swap at the best price, and the amount of tokens to sell to receive a certain amount of nanoErgs. Additionally, it provides a method to build a new Babel Fee Box state after a token swap and a method to build an `OutBox` representing the Babel Fee Box.\n\nThe `buildSucceedingState` method takes a `tokenAmountChange` parameter, which represents the token amount to add to the new Babel Fee Box. It checks if the `tokenAmountChange` is greater than 0 and less than or equal to the max token amount to buy. If the `tokenAmountChange` is valid, it returns a new `BabelFeeBoxState` object with the updated `value` and `tokenAmount` fields.\n\nThe `buildOutbox` method takes a `txBuilder` parameter, which represents the `UnsignedTransactionBuilder` object used to build the new outbox, and an optional `precedingBabelBox` parameter, which represents the preceding Babel Fee Box if this is not the initial Babel Fee Box. It builds an `OutBoxBuilder` object with the necessary parameters, such as the contract, value, and registers, and returns an `OutBox` object representing the Babel Fee Box.\n\nOverall, the `BabelFeeBoxState` class provides a convenient way to interact with a Babel Fee Box on the Ergo blockchain. It allows developers to calculate the amount of tokens to sell to receive a certain amount of nanoErgs, build a new Babel Fee Box state after a token swap, and build an `OutBox` representing the Babel Fee Box.\n## Questions: \n 1. What is the purpose of the BabelFeeBoxState class?\n- The BabelFeeBoxState class represents a Babel Fee Box state, which is a contract that buys tokens and pays ERG, suitable to be used in any transaction.\n\n2. What are the main attributes of a BabelFeeBoxState object?\n- The main attributes of a BabelFeeBoxState object are pricePerToken, tokenId, boxCreator, value, and tokenAmount.\n\n3. What methods are available to interact with a BabelFeeBoxState object?\n- Some of the methods available to interact with a BabelFeeBoxState object include getPricePerToken(), getTokenId(), getBoxCreator(), getValue(), getTokenAmount(), calcTokensToSellForErgAmount(), buildSucceedingState(), and buildOutbox().","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/babelfee/BabelFeeBoxState.md"}}],["277",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/babelfee/BabelFeeBoxStateBuilder.java)\n\nThe `BabelFeeBoxStateBuilder` class is a builder that allows for the creation of a `BabelFeeBoxState` object with self-defined information. The `BabelFeeBoxState` object represents a box that contains a certain amount of tokens and nanoErgs, and is used to pay for transaction fees on the Ergo blockchain. \n\nThe `BabelFeeBoxStateBuilder` class has several methods that allow for the setting of different properties of the `BabelFeeBoxState` object. These methods include `withPricePerToken`, `withTokenId`, `withBoxCreator`, `withValue`, and `withTokenAmount`. Each of these methods sets a specific property of the `BabelFeeBoxState` object. \n\nThe `withPricePerToken` method sets the price per token of the `BabelFeeBoxState` object. The `withTokenId` method sets the ID of the token that the `BabelFeeBoxState` object contains. The `withBoxCreator` method sets the creator of the `BabelFeeBoxState` object. This can be either a `SigmaProp` object or an `Address` object. The `withValue` method sets the amount of nanoErgs that the `BabelFeeBoxState` object contains. The `withTokenAmount` method sets the amount of tokens that the `BabelFeeBoxState` object contains. \n\nThe `build` method creates a new `BabelFeeBoxState` object with the properties that have been set using the builder methods. Before creating the object, the method checks that the `boxCreator` and `tokenId` properties have been set, and that the `value` and `pricePerToken` properties are greater than 0. If any of these conditions are not met, an exception is thrown. \n\nOverall, the `BabelFeeBoxStateBuilder` class provides a convenient way to create `BabelFeeBoxState` objects with custom properties. This can be useful in the larger project when creating transactions that require payment of transaction fees using `BabelFeeBoxState` objects. \n\nExample usage:\n\n```\nBabelFeeBoxStateBuilder builder = new BabelFeeBoxStateBuilder();\nBabelFeeBoxState boxState = builder\n    .withPricePerToken(1000000)\n    .withTokenId(tokenId)\n    .withBoxCreator(boxCreator)\n    .withValue(1000000000)\n    .withTokenAmount(10)\n    .build();\n```\n## Questions: \n 1. What is the purpose of the `BabelFeeBoxStateBuilder` class?\n    \n    The `BabelFeeBoxStateBuilder` class is used to conveniently instantiate a `BabelFeeBoxState` object with self-defined information.\n\n2. What are the required parameters for building a `BabelFeeBoxState` object?\n    \n    The required parameters for building a `BabelFeeBoxState` object are `pricePerToken`, `tokenId`, `boxCreator`, `value`, and `tokenAmount`.\n\n3. What happens if the `value` or `pricePerToken` parameters are less than or equal to 0?\n    \n    If the `value` or `pricePerToken` parameters are less than or equal to 0, an `IllegalArgumentException` will be thrown.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/babelfee/BabelFeeBoxStateBuilder.md"}}],["278",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-api/src/main/java/org/ergoplatform/appkit/babelfee/BabelFeeOperations.java)\n\nThe `BabelFeeOperations` class provides methods for creating, canceling, and finding Babel fee boxes on the Ergo blockchain. Babel fee boxes are used to pay for transaction fees on the Ergo blockchain. \n\nThe `createNewBabelContractTx` method creates a new Babel fee box for a given token ID and price per token. It takes a `BoxOperations` object, which defines the box creator and amount to spend, a `tokenId`, and a `pricePerToken`. It returns a prepared transaction to create the new Babel fee box.\n\nThe `cancelBabelFeeContract` method cancels a Babel fee contract. It takes a `BoxOperations` object and an input Babel box. It returns an unsigned transaction to cancel the Babel fee contract.\n\nThe `findBabelFeeBox` method tries to fetch a Babel fee box for the given token ID from the blockchain data source using the given loader. If `maxPagesToLoadForPriceSearch` is 0, the Babel fee box with the best price satisfying `feeAmount` is returned. If `maxPagesToLoadForPriceSearch` is greater than 0, the box with the best price within these pages is returned. It takes the current blockchain context, a `BoxOperations.IUnspentBoxesLoader` object, a `tokenId`, a `feeAmount`, and a `maxPagesToLoadForPriceSearch`. It returns a Babel fee box satisfying the needs or null if none is available.\n\nThe `addBabelFeeBoxes` method adds Babel fee boxes (input and output) to the given transaction builder. It takes an unsigned transaction builder, an input Babel box to make the swap with, and nanoErgs to be covered by the Babel box, usually the fee amount needed, maybe a change amount as well.\n\nOverall, the `BabelFeeOperations` class provides a set of methods for creating, canceling, and finding Babel fee boxes on the Ergo blockchain. These methods can be used in the larger project to manage transaction fees on the Ergo blockchain.\n## Questions: \n 1. What is the purpose of the `BabelFeeOperations` class?\n- The `BabelFeeOperations` class contains static methods for creating and manipulating Babel fee boxes, which are used for swapping tokens on the Ergo blockchain.\n\n2. What is the `createNewBabelContractTx` method used for?\n- The `createNewBabelContractTx` method creates a new Babel fee box for a given token ID and price per token, using a prepared `BoxOperations` object to define the box creator and amount to spend.\n\n3. What is the `findBabelFeeBox` method used for?\n- The `findBabelFeeBox` method tries to fetch a Babel fee box for a given token ID and fee amount from the blockchain data source using a provided `BoxOperations.IUnspentBoxesLoader`. It returns the Babel fee box with the best price per token that satisfies the fee amount, or null if none are available.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/babelfee/BabelFeeOperations.md"}}],["279",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/lib-api/src/main/java/org/ergoplatform/appkit/babelfee)\n\nThe `babelfee` folder contains classes that enable the creation and management of Babel Fee Boxes on the Ergo blockchain. Babel Fee Boxes are used to pay for transaction fees using tokens instead of the platform's primary token (ERG).\n\nThe `BabelFeeBoxContract` class represents a smart contract used to create a Babel Fee Box. It has two constructors that take either an `ErgoId` or an `ErgoTree` object as input. The `getErgoTree` and `getTokenId` methods return the contract's logic and the token ID used to pay for transaction fees, respectively.\n\n```java\nErgoId tokenId = new ErgoId(\"1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\");\nBabelFeeBoxContract contract = new BabelFeeBoxContract(tokenId);\nValues.ErgoTree ergoTree = contract.getErgoTree();\nlong value = 1000000000L;\nErgoBox box = new ErgoBox(value, ergoTree);\n```\n\nThe `BabelFeeBoxState` class represents the state of a Babel Fee Box and provides methods to interact with it, such as calculating the amount of tokens to sell to receive a certain amount of nanoErgs, building a new Babel Fee Box state after a token swap, and building an `OutBox` representing the Babel Fee Box.\n\nThe `BabelFeeBoxStateBuilder` class allows for the creation of a `BabelFeeBoxState` object with custom properties. It provides methods like `withPricePerToken`, `withTokenId`, `withBoxCreator`, `withValue`, and `withTokenAmount` to set specific properties of the `BabelFeeBoxState` object.\n\n```java\nBabelFeeBoxStateBuilder builder = new BabelFeeBoxStateBuilder();\nBabelFeeBoxState boxState = builder\n    .withPricePerToken(1000000)\n    .withTokenId(tokenId)\n    .withBoxCreator(boxCreator)\n    .withValue(1000000000)\n    .withTokenAmount(10)\n    .build();\n```\n\nThe `BabelFeeOperations` class provides methods for creating, canceling, and finding Babel fee boxes on the Ergo blockchain. The `createNewBabelContractTx` method creates a new Babel fee box for a given token ID and price per token. The `cancelBabelFeeContract` method cancels a Babel fee contract. The `findBabelFeeBox` method fetches a Babel fee box for the given token ID from the blockchain data source. The `addBabelFeeBoxes` method adds Babel fee boxes (input and output) to the given transaction builder.\n\nThese classes can be used in the larger project to manage transaction fees on the Ergo blockchain using Babel Fee Boxes. They provide a convenient way to create, cancel, and find Babel fee boxes, as well as interact with their states and properties.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/appkit/babelfee/summary.md"}}],["280",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/lib-api/src/main/java/org/ergoplatform)\n\nIn the `org.ergoplatform` package, you will find the following files:\n\n1. `ErgoAddress.java`: This file contains the `ErgoAddress` class, which is responsible for handling Ergo addresses. It provides methods to create and validate addresses, as well as to convert them to different formats (e.g., Base58, P2PK, P2S). This class is essential for any operation that involves Ergo addresses, such as sending and receiving transactions.\n\n   Example usage:\n   ```java\n   ErgoAddress address = ErgoAddress.fromBase58(\"9f4QF8AD1nQDiyECtMvqYwJYwDk3N5xyaAU3zVVXgsg=\");\n   System.out.println(\"Address: \" + address.toString());\n   ```\n\n2. `ErgoBox.java`: This file contains the `ErgoBox` class, which represents an Ergo box (i.e., a UTXO). It provides methods to access the box's properties, such as its value, tokens, and additional registers. This class is crucial for working with Ergo transactions, as it allows you to manipulate and inspect the boxes involved in a transaction.\n\n   Example usage:\n   ```java\n   ErgoBox box = ErgoBox.fromJson(jsonString);\n   System.out.println(\"Box value: \" + box.getValue());\n   ```\n\n3. `ErgoId.java`: This file contains the `ErgoId` class, which represents a unique identifier for Ergo entities (e.g., boxes, transactions). It provides methods to create and validate Ergo IDs, as well as to convert them to different formats (e.g., Base16, Base58). This class is useful for any operation that requires unique identification of Ergo entities.\n\n   Example usage:\n   ```java\n   ErgoId id = ErgoId.fromBase16(\"6f1a8e7d8e1e4d7a8e1e4d7a8e1e4d7a8e1e4d7a8e1e4d7a\");\n   System.out.println(\"ID: \" + id.toString());\n   ```\n\n4. `ErgoLikeTransaction.java`: This file contains the `ErgoLikeTransaction` class, which represents an Ergo transaction. It provides methods to access the transaction's properties, such as its inputs, outputs, and data inputs. This class is essential for working with Ergo transactions, as it allows you to create, inspect, and manipulate transactions.\n\n   Example usage:\n   ```java\n   ErgoLikeTransaction tx = ErgoLikeTransaction.fromJson(jsonString);\n   System.out.println(\"Transaction inputs: \" + tx.getInputs());\n   ```\n\nThese classes are essential building blocks for working with Ergo blockchain data and transactions. They provide a foundation for developers to create, inspect, and manipulate Ergo entities, such as addresses, boxes, IDs, and transactions. By using these classes, developers can easily interact with the Ergo blockchain and build applications on top of it.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/ergoplatform/summary.md"}}],["281",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/lib-api/src/main/java/org)\n\nIn the `org.ergoplatform` package, you will find essential classes for working with Ergo blockchain data and transactions. These classes provide a foundation for developers to create, inspect, and manipulate Ergo entities, such as addresses, boxes, IDs, and transactions. By using these classes, developers can easily interact with the Ergo blockchain and build applications on top of it.\n\n1. `ErgoAddress.java`: This class is responsible for handling Ergo addresses. It provides methods to create and validate addresses, as well as to convert them to different formats (e.g., Base58, P2PK, P2S). This class is essential for any operation that involves Ergo addresses, such as sending and receiving transactions.\n\n   Example usage:\n   ```java\n   ErgoAddress address = ErgoAddress.fromBase58(\"9f4QF8AD1nQDiyECtMvqYwJYwDk3N5xyaAU3zVVXgsg=\");\n   System.out.println(\"Address: \" + address.toString());\n   ```\n\n2. `ErgoBox.java`: This class represents an Ergo box (i.e., a UTXO). It provides methods to access the box's properties, such as its value, tokens, and additional registers. This class is crucial for working with Ergo transactions, as it allows you to manipulate and inspect the boxes involved in a transaction.\n\n   Example usage:\n   ```java\n   ErgoBox box = ErgoBox.fromJson(jsonString);\n   System.out.println(\"Box value: \" + box.getValue());\n   ```\n\n3. `ErgoId.java`: This class represents a unique identifier for Ergo entities (e.g., boxes, transactions). It provides methods to create and validate Ergo IDs, as well as to convert them to different formats (e.g., Base16, Base58). This class is useful for any operation that requires unique identification of Ergo entities.\n\n   Example usage:\n   ```java\n   ErgoId id = ErgoId.fromBase16(\"6f1a8e7d8e1e4d7a8e1e4d7a8e1e4d7a8e1e4d7a8e1e4d7a\");\n   System.out.println(\"ID: \" + id.toString());\n   ```\n\n4. `ErgoLikeTransaction.java`: This class represents an Ergo transaction. It provides methods to access the transaction's properties, such as its inputs, outputs, and data inputs. This class is essential for working with Ergo transactions, as it allows you to create, inspect, and manipulate transactions.\n\n   Example usage:\n   ```java\n   ErgoLikeTransaction tx = ErgoLikeTransaction.fromJson(jsonString);\n   System.out.println(\"Transaction inputs: \" + tx.getInputs());\n   ```\n\nThese classes are essential building blocks for working with Ergo blockchain data and transactions. They provide a foundation for developers to create, inspect, and manipulate Ergo entities, such as addresses, boxes, IDs, and transactions. By using these classes, developers can easily interact with the Ergo blockchain and build applications on top of it.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/org/summary.md"}}],["282",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/lib-api/src/main/java)\n\nIn the `.autodoc/docs/json/lib-api/src/main/java` folder, you will find essential classes for working with Ergo blockchain data and transactions under the `org.ergoplatform` package. These classes provide a foundation for developers to create, inspect, and manipulate Ergo entities, such as addresses, boxes, IDs, and transactions. By using these classes, developers can easily interact with the Ergo blockchain and build applications on top of it.\n\n1. `ErgoAddress.java`: This class is responsible for handling Ergo addresses. It provides methods to create and validate addresses, as well as to convert them to different formats (e.g., Base58, P2PK, P2S). This class is essential for any operation that involves Ergo addresses, such as sending and receiving transactions.\n\n   Example usage:\n   ```java\n   ErgoAddress address = ErgoAddress.fromBase58(\"9f4QF8AD1nQDiyECtMvqYwJYwDk3N5xyaAU3zVVXgsg=\");\n   System.out.println(\"Address: \" + address.toString());\n   ```\n\n2. `ErgoBox.java`: This class represents an Ergo box (i.e., a UTXO). It provides methods to access the box's properties, such as its value, tokens, and additional registers. This class is crucial for working with Ergo transactions, as it allows you to manipulate and inspect the boxes involved in a transaction.\n\n   Example usage:\n   ```java\n   ErgoBox box = ErgoBox.fromJson(jsonString);\n   System.out.println(\"Box value: \" + box.getValue());\n   ```\n\n3. `ErgoId.java`: This class represents a unique identifier for Ergo entities (e.g., boxes, transactions). It provides methods to create and validate Ergo IDs, as well as to convert them to different formats (e.g., Base16, Base58). This class is useful for any operation that requires unique identification of Ergo entities.\n\n   Example usage:\n   ```java\n   ErgoId id = ErgoId.fromBase16(\"6f1a8e7d8e1e4d7a8e1e4d7a8e1e4d7a8e1e4d7a8e1e4d7a\");\n   System.out.println(\"ID: \" + id.toString());\n   ```\n\n4. `ErgoLikeTransaction.java`: This class represents an Ergo transaction. It provides methods to access the transaction's properties, such as its inputs, outputs, and data inputs. This class is essential for working with Ergo transactions, as it allows you to create, inspect, and manipulate transactions.\n\n   Example usage:\n   ```java\n   ErgoLikeTransaction tx = ErgoLikeTransaction.fromJson(jsonString);\n   System.out.println(\"Transaction inputs: \" + tx.getInputs());\n   ```\n\nThese classes are essential building blocks for working with Ergo blockchain data and transactions. They provide a foundation for developers to create, inspect, and manipulate Ergo entities, such as addresses, boxes, IDs, and transactions. By using these classes, developers can easily interact with the Ergo blockchain and build applications on top of it.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/java/summary.md"}}],["283",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/lib-api/src/main)\n\nIn the `.autodoc/docs/json/lib-api/src/main` folder, the `java` subfolder contains essential classes for working with Ergo blockchain data and transactions under the `org.ergoplatform` package. These classes provide a foundation for developers to create, inspect, and manipulate Ergo entities, such as addresses, boxes, IDs, and transactions. By using these classes, developers can easily interact with the Ergo blockchain and build applications on top of it.\n\n1. `ErgoAddress.java`: This class is responsible for handling Ergo addresses. It provides methods to create and validate addresses, as well as to convert them to different formats (e.g., Base58, P2PK, P2S). This class is essential for any operation that involves Ergo addresses, such as sending and receiving transactions.\n\n   Example usage:\n   ```java\n   ErgoAddress address = ErgoAddress.fromBase58(\"9f4QF8AD1nQDiyECtMvqYwJYwDk3N5xyaAU3zVVXgsg=\");\n   System.out.println(\"Address: \" + address.toString());\n   ```\n\n2. `ErgoBox.java`: This class represents an Ergo box (i.e., a UTXO). It provides methods to access the box's properties, such as its value, tokens, and additional registers. This class is crucial for working with Ergo transactions, as it allows you to manipulate and inspect the boxes involved in a transaction.\n\n   Example usage:\n   ```java\n   ErgoBox box = ErgoBox.fromJson(jsonString);\n   System.out.println(\"Box value: \" + box.getValue());\n   ```\n\n3. `ErgoId.java`: This class represents a unique identifier for Ergo entities (e.g., boxes, transactions). It provides methods to create and validate Ergo IDs, as well as to convert them to different formats (e.g., Base16, Base58). This class is useful for any operation that requires unique identification of Ergo entities.\n\n   Example usage:\n   ```java\n   ErgoId id = ErgoId.fromBase16(\"6f1a8e7d8e1e4d7a8e1e4d7a8e1e4d7a8e1e4d7a8e1e4d7a\");\n   System.out.println(\"ID: \" + id.toString());\n   ```\n\n4. `ErgoLikeTransaction.java`: This class represents an Ergo transaction. It provides methods to access the transaction's properties, such as its inputs, outputs, and data inputs. This class is essential for working with Ergo transactions, as it allows you to create, inspect, and manipulate transactions.\n\n   Example usage:\n   ```java\n   ErgoLikeTransaction tx = ErgoLikeTransaction.fromJson(jsonString);\n   System.out.println(\"Transaction inputs: \" + tx.getInputs());\n   ```\n\nThese classes are essential building blocks for working with Ergo blockchain data and transactions. They provide a foundation for developers to create, inspect, and manipulate Ergo entities, such as addresses, boxes, IDs, and transactions. By using these classes, developers can easily interact with the Ergo blockchain and build applications on top of it.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/main/summary.md"}}],["284",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/lib-api/src)\n\nIn the `.autodoc/docs/json/lib-api/src` folder, the `main` subfolder contains essential classes for working with Ergo blockchain data and transactions under the `org.ergoplatform` package. These classes provide a foundation for developers to create, inspect, and manipulate Ergo entities, such as addresses, boxes, IDs, and transactions. By using these classes, developers can easily interact with the Ergo blockchain and build applications on top of it.\n\n1. `ErgoAddress.java`: This class is responsible for handling Ergo addresses. It provides methods to create and validate addresses, as well as to convert them to different formats (e.g., Base58, P2PK, P2S). This class is essential for any operation that involves Ergo addresses, such as sending and receiving transactions.\n\n   Example usage:\n   ```java\n   ErgoAddress address = ErgoAddress.fromBase58(\"9f4QF8AD1nQDiyECtMvqYwJYwDk3N5xyaAU3zVVXgsg=\");\n   System.out.println(\"Address: \" + address.toString());\n   ```\n\n2. `ErgoBox.java`: This class represents an Ergo box (i.e., a UTXO). It provides methods to access the box's properties, such as its value, tokens, and additional registers. This class is crucial for working with Ergo transactions, as it allows you to manipulate and inspect the boxes involved in a transaction.\n\n   Example usage:\n   ```java\n   ErgoBox box = ErgoBox.fromJson(jsonString);\n   System.out.println(\"Box value: \" + box.getValue());\n   ```\n\n3. `ErgoId.java`: This class represents a unique identifier for Ergo entities (e.g., boxes, transactions). It provides methods to create and validate Ergo IDs, as well as to convert them to different formats (e.g., Base16, Base58). This class is useful for any operation that requires unique identification of Ergo entities.\n\n   Example usage:\n   ```java\n   ErgoId id = ErgoId.fromBase16(\"6f1a8e7d8e1e4d7a8e1e4d7a8e1e4d7a8e1e4d7a8e1e4d7a\");\n   System.out.println(\"ID: \" + id.toString());\n   ```\n\n4. `ErgoLikeTransaction.java`: This class represents an Ergo transaction. It provides methods to access the transaction's properties, such as its inputs, outputs, and data inputs. This class is essential for working with Ergo transactions, as it allows you to create, inspect, and manipulate transactions.\n\n   Example usage:\n   ```java\n   ErgoLikeTransaction tx = ErgoLikeTransaction.fromJson(jsonString);\n   System.out.println(\"Transaction inputs: \" + tx.getInputs());\n   ```\n\nThese classes are essential building blocks for working with Ergo blockchain data and transactions. They provide a foundation for developers to create, inspect, and manipulate Ergo entities, such as addresses, boxes, IDs, and transactions. By using these classes, developers can easily interact with the Ergo blockchain and build applications on top of it.","metadata":{"source":".autodoc/docs/markdown/lib-api/src/summary.md"}}],["285",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/lib-api)\n\nThe `.autodoc/docs/json/lib-api` folder contains essential classes for working with Ergo blockchain data and transactions under the `org.ergoplatform` package. These classes provide a foundation for developers to create, inspect, and manipulate Ergo entities, such as addresses, boxes, IDs, and transactions. By using these classes, developers can easily interact with the Ergo blockchain and build applications on top of it.\n\n1. `ErgoAddress.java`: This class is responsible for handling Ergo addresses. It provides methods to create and validate addresses, as well as to convert them to different formats (e.g., Base58, P2PK, P2S). This class is essential for any operation that involves Ergo addresses, such as sending and receiving transactions.\n\n   Example usage:\n   ```java\n   ErgoAddress address = ErgoAddress.fromBase58(\"9f4QF8AD1nQDiyECtMvqYwJYwDk3N5xyaAU3zVVXgsg=\");\n   System.out.println(\"Address: \" + address.toString());\n   ```\n\n2. `ErgoBox.java`: This class represents an Ergo box (i.e., a UTXO). It provides methods to access the box's properties, such as its value, tokens, and additional registers. This class is crucial for working with Ergo transactions, as it allows you to manipulate and inspect the boxes involved in a transaction.\n\n   Example usage:\n   ```java\n   ErgoBox box = ErgoBox.fromJson(jsonString);\n   System.out.println(\"Box value: \" + box.getValue());\n   ```\n\n3. `ErgoId.java`: This class represents a unique identifier for Ergo entities (e.g., boxes, transactions). It provides methods to create and validate Ergo IDs, as well as to convert them to different formats (e.g., Base16, Base58). This class is useful for any operation that requires unique identification of Ergo entities.\n\n   Example usage:\n   ```java\n   ErgoId id = ErgoId.fromBase16(\"6f1a8e7d8e1e4d7a8e1e4d7a8e1e4d7a8e1e4d7a8e1e4d7a\");\n   System.out.println(\"ID: \" + id.toString());\n   ```\n\n4. `ErgoLikeTransaction.java`: This class represents an Ergo transaction. It provides methods to access the transaction's properties, such as its inputs, outputs, and data inputs. This class is essential for working with Ergo transactions, as it allows you to create, inspect, and manipulate transactions.\n\n   Example usage:\n   ```java\n   ErgoLikeTransaction tx = ErgoLikeTransaction.fromJson(jsonString);\n   System.out.println(\"Transaction inputs: \" + tx.getInputs());\n   ```\n\nThese classes are essential building blocks for working with Ergo blockchain data and transactions. They provide a foundation for developers to create, inspect, and manipulate Ergo entities, such as addresses, boxes, IDs, and transactions. By using these classes, developers can easily interact with the Ergo blockchain and build applications on top of it.","metadata":{"source":".autodoc/docs/markdown/lib-api/summary.md"}}],["286",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/ApiFacade.java)\n\nThe `ApiFacade` class in the `ergo-appkit` project provides helper methods for executing API requests using the Retrofit library. The class is abstract and contains two static methods and one interface.\n\nThe `clientError` method creates a new instance of the `ErgoClientException` class with the given cause and uses the given `Retrofit` instance to format the error message. This method is used to wrap any exceptions that occur during API request execution and provide a more informative error message to the user.\n\nThe `Supplier` interface is a helper interface that defines a single method `get()` which can throw two checked exceptions: `NoSuchMethodException` and `IOException`. This interface is used to define a block of code that can be executed by the `execute` method.\n\nThe `execute` method takes a `Retrofit` instance and a `Supplier` block as input parameters. It executes the given `Supplier` block and returns the result of the block execution. If an exception occurs during the block execution, the `clientError` method is called to wrap the exception in an `ErgoClientException` and provide a more informative error message. This method is used to execute API requests and handle any exceptions that may occur during the request execution.\n\nOverall, the `ApiFacade` class provides a simple and convenient way to execute API requests using the Retrofit library and handle any exceptions that may occur during the request execution. Here is an example of how this class can be used:\n\n```\nRetrofit retrofit = new Retrofit.Builder()\n        .baseUrl(\"https://api.example.com/\")\n        .build();\n\nApiFacade.execute(retrofit, () -> {\n    // execute API request and return result\n    return someResult;\n});\n```\n## Questions: \n 1. What is the purpose of the `ApiFacade` class?\n    \n    The `ApiFacade` class is an abstract class that provides helper methods for executing API requests using a `Retrofit` instance.\n\n2. What is the purpose of the `clientError` method?\n    \n    The `clientError` method creates a new instance of `ErgoClientException` with a formatted error message using the `Retrofit` instance and the cause of the error.\n\n3. What is the purpose of the `Supplier` interface?\n    \n    The `Supplier` interface is a helper interface that defines a method for getting a result and throwing necessary exceptions. It is used in the `execute` method to execute a block of code and return the result.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/ApiFacade.md"}}],["287",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/BlockHeaderImpl.java)\n\nThe `BlockHeaderImpl` class is a concrete implementation of the `BlockHeader` interface in the `ergoplatform.appkit` package. It extends the `PreHeaderImpl` class and provides methods to access various properties of a block header in the Ergo blockchain. \n\nThe `BlockHeaderImpl` class has two instance variables: `sigmaHeader` of type `Header` and `header` of type `org.ergoplatform.restapi.client.BlockHeader`. The `sigmaHeader` variable is an instance of the `Header` class from the `special.sigma` package, which represents the header of a block in the Ergo blockchain. The `header` variable is an instance of the `org.ergoplatform.restapi.client.BlockHeader` class, which is a REST API representation of a block header.\n\nThe `BlockHeaderImpl` class provides a constructor that takes a `Header` object and a `BlockHeader` object as arguments. The constructor calls the constructor of the `PreHeaderImpl` class with the `Header` object as an argument and initializes the `sigmaHeader` and `header` instance variables.\n\nThe `BlockHeaderImpl` class also provides a static method `createFromRestApi` that takes a `BlockHeader` object as an argument and returns a new instance of the `BlockHeaderImpl` class. This method converts the `BlockHeader` object to a `Header` object using the `ScalaBridge.isoBlockHeader()` method and then calls the constructor of the `BlockHeaderImpl` class with the `Header` and `BlockHeader` objects as arguments.\n\nThe `BlockHeaderImpl` class implements the methods of the `BlockHeader` interface. These methods provide access to various properties of a block header, such as the ID, state root, AD proofs root, transactions root, extension hash, PoW solutions public key, PoW solutions W, PoW solutions D, and PoW solutions nonce. These properties are obtained from the `sigmaHeader` and `header` instance variables.\n\nThis class can be used in the larger project to retrieve information about a block header in the Ergo blockchain. For example, a developer can use the `createFromRestApi` method to create a `BlockHeaderImpl` object from a `BlockHeader` object obtained from the Ergo REST API. The developer can then use the methods of the `BlockHeader` interface to access various properties of the block header.\n## Questions: \n 1. What is the purpose of the `BlockHeaderImpl` class?\n- The `BlockHeaderImpl` class is an implementation of the `BlockHeader` interface and provides methods for accessing various properties of a block header.\n\n2. What is the relationship between `sigmaHeader` and `header`?\n- `sigmaHeader` is an instance of the `Header` class from the `special.sigma` package, while `header` is an instance of the `org.ergoplatform.restapi.client.BlockHeader` class. The constructor of `BlockHeaderImpl` takes both of these objects as arguments and assigns them to instance variables.\n\n3. What is the purpose of the `createFromRestApi` method?\n- The `createFromRestApi` method is a static factory method that creates a new instance of `BlockHeaderImpl` from an instance of `org.ergoplatform.restapi.client.BlockHeader`. It does this by converting the `BlockHeader` object to a `Header` object using a ScalaBridge and then passing both objects to the `BlockHeaderImpl` constructor.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/BlockHeaderImpl.md"}}],["288",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/BlockchainContextBase.java)\n\nThe `BlockchainContextBase` class is an abstract class that provides a base implementation for the `BlockchainContext` interface. It contains methods for creating and compiling Ergo contracts, getting the network type, and parsing reduced and signed transactions. \n\nThe `newContract` method takes an `ErgoTree` and returns an `ErgoContract` object. This method is used to create a new contract from an `ErgoTree`. The `compileContract` method takes `Constants` and an `ergoScript` string and returns an `ErgoContract` object. This method is used to compile an `ergoScript` into an `ErgoContract`.\n\nThe `getNetworkType` method returns the network type of the blockchain context. This method is used to get the network type of the blockchain context.\n\nThe `parseReducedTransaction` method takes a byte array of a reduced transaction and returns a `ReducedTransaction` object. This method is used to parse a reduced transaction.\n\nThe `parseSignedTransaction` method takes a byte array of a signed transaction and returns a `SignedTransaction` object. This method is used to parse a signed transaction.\n\nOverall, the `BlockchainContextBase` class provides a base implementation for the `BlockchainContext` interface. It is used to create and compile Ergo contracts, get the network type, and parse reduced and signed transactions. This class can be extended to provide additional functionality for a specific blockchain context. \n\nExample usage:\n\n```\nBlockchainContext context = new BlockchainContextBase(NetworkType.MAINNET);\nErgoContract contract = context.compileContract(ConstantsBuilder.create().build(), \"sigmaProp(true)\");\nNetworkType networkType = context.getNetworkType();\nbyte[] txBytes = ... // get transaction bytes\nReducedTransaction reducedTx = context.parseReducedTransaction(txBytes);\nSignedTransaction signedTx = context.parseSignedTransaction(txBytes);\n```\n## Questions: \n 1. What is the purpose of the `BlockchainContextBase` class?\n- The `BlockchainContextBase` class is an abstract class that implements the `BlockchainContext` interface and provides some common functionality for blockchain contexts.\n\n2. What is the difference between `ReducedTransaction` and `SignedTransaction`?\n- `ReducedTransaction` is a reduced version of an `ErgoLikeTransaction` that contains only the essential information, while `SignedTransaction` is a fully signed `ErgoLikeTransaction` that can be broadcasted to the network.\n\n3. What is the purpose of the `parseReducedTransaction` method?\n- The `parseReducedTransaction` method takes a byte array that represents a serialized reduced transaction and returns a `ReducedTransaction` object that can be used to interact with the transaction.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/BlockchainContextBase.md"}}],["289",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/BlockchainContextBuilderImpl.java)\n\nThe `BlockchainContextBuilderImpl` class is a part of the `ergo-appkit` project and is responsible for building a `BlockchainContext` object. The `BlockchainContext` object is used to interact with the Ergo blockchain and provides access to various blockchain-related functionalities.\n\nThe `BlockchainContextBuilderImpl` class implements the `BlockchainContextBuilder` interface, which defines a method `build()` that returns a `BlockchainContext` object. The `build()` method takes no arguments and throws an `ErgoClientException` if there is an error while building the `BlockchainContext` object.\n\nThe `BlockchainContextBuilderImpl` constructor takes two arguments: a `BlockchainDataSource` object and a `NetworkType` object. The `BlockchainDataSource` object represents the data source used to connect to the Ergo blockchain, while the `NetworkType` object represents the type of network (mainnet, testnet, etc.) that the `BlockchainContext` object will be used for.\n\nThe `build()` method creates a new `BlockchainContextImpl` object by passing the `BlockchainDataSource` and `NetworkType` objects to its constructor. The `BlockchainContextImpl` class is another implementation of the `BlockchainContext` interface and provides the actual implementation of the various blockchain-related functionalities.\n\nHere is an example of how the `BlockchainContextBuilderImpl` class can be used to build a `BlockchainContext` object:\n\n```\nBlockchainDataSource dataSource = new MyBlockchainDataSource();\nNetworkType networkType = NetworkType.TESTNET;\nBlockchainContextBuilder builder = new BlockchainContextBuilderImpl(dataSource, networkType);\nBlockchainContext context = builder.build();\n```\n\nIn this example, a custom `BlockchainDataSource` object is created and the `NetworkType` is set to `TESTNET`. Then, a new `BlockchainContextBuilderImpl` object is created by passing the `BlockchainDataSource` and `NetworkType` objects to its constructor. Finally, the `build()` method is called on the `BlockchainContextBuilderImpl` object to create a new `BlockchainContext` object. The `BlockchainContext` object can then be used to interact with the Ergo blockchain.\n## Questions: \n 1. What is the purpose of this code?\n- This code is a class implementation of the `BlockchainContextBuilder` interface for building a `BlockchainContext` object.\n\n2. What are the parameters of the `BlockchainContextBuilderImpl` constructor?\n- The constructor takes in a `BlockchainDataSource` object and a `NetworkType` object as parameters.\n\n3. What does the `build()` method do?\n- The `build()` method creates and returns a new `BlockchainContextImpl` object using the `_dataSource` and `_networkType` parameters passed in the constructor.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/BlockchainContextBuilderImpl.md"}}],["290",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/BlockchainContextImpl.java)\n\nThe `BlockchainContextImpl` class is a concrete implementation of the `BlockchainContextBase` abstract class. It provides a context for interacting with the Ergo blockchain, including accessing the blockchain data source, creating preheaders, building unsigned transactions, and creating provers. \n\nThe constructor takes a `BlockchainDataSource` and a `NetworkType` as parameters. It fetches the last block headers and blockchain parameters from the data source and stores them in the `_headers` and `_blockchainParameters` fields, respectively. It also checks that the network type of the data source matches the given network type.\n\nThe `createPreHeader()` method returns a new instance of `PreHeaderBuilderImpl`, which is used to build preheaders for transactions.\n\nThe `signedTxFromJson(String json)` method deserializes a JSON string into an `ErgoTransaction` object using the `Gson` library, and then converts it to an `ErgoLikeTransaction` object using the `ScalaBridge` library. It returns a new instance of `SignedTransactionImpl` with the `ErgoLikeTransaction` object and a zero index.\n\nThe `newTxBuilder()` method returns a new instance of `UnsignedTransactionBuilderImpl`, which is used to build unsigned transactions.\n\nThe `getDataSource()` method returns the data source used by the context.\n\nThe `getBoxesById(String... boxIds)` method takes an array of box IDs and returns an array of `InputBox` objects retrieved from the data source. It throws an `ErgoClientException` if any of the boxes cannot be retrieved.\n\nThe `newProverBuilder()` method returns a new instance of `ErgoProverBuilderImpl`, which is used to build provers.\n\nThe `getHeight()` method returns the height of the most recent block.\n\nThe `getParameters()` method returns the blockchain parameters.\n\nThe `getHeaders()` method returns the last block headers.\n\nThe `sendTransaction(SignedTransaction tx)` method sends a signed transaction to the data source and returns the transaction ID.\n\nThe `getUnspentBoxesFor(Address address, int offset, int limit)` method returns a list of unspent boxes for a given address, offset, and limit.\n\nThe `getCoveringBoxesFor(Address address, long amountToSpend, List<ErgoToken> tokensToSpend)` method returns a `CoveringBoxes` object containing a list of boxes that cover the specified amount and tokens. It uses the `BoxOperations` class to fetch unspent boxes from the data source.\n## Questions: \n 1. What is the purpose of this code file?\n- This code file contains the implementation of the `BlockchainContextImpl` class, which provides an implementation of the `BlockchainContext` interface for interacting with the Ergo blockchain.\n\n2. What are some of the methods provided by the `BlockchainContextImpl` class?\n- The `BlockchainContextImpl` class provides methods for creating pre-headers, building unsigned transactions, getting input boxes by ID, creating provers, getting the blockchain data source, getting the blockchain parameters, sending transactions, and getting unspent boxes and covering boxes for an address.\n\n3. What is the role of the `BlockchainDataSource` parameter in the constructor of `BlockchainContextImpl`?\n- The `BlockchainDataSource` parameter is used to fetch the last block headers and blockchain parameters, which are then stored in the `BlockchainContextImpl` instance for later use.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/BlockchainContextImpl.md"}}],["291",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/BoxAttachmentBuilder.java)\n\nThe `BoxAttachmentBuilder` class is part of the `ergo-appkit` project and provides utility methods for building box attachments. Box attachments are additional data that can be attached to an `ErgoBox` in the Ergo blockchain. The class provides methods for building attachments compliant with the EIP-29 standard, which defines a standard way of encoding attachments in Ergo transactions.\n\nThe `BoxAttachmentBuilder` class provides several static methods for building different types of attachments. The `getAttachmentRegisterIndex()` method returns the register number that should be used for the attachment according to the EIP-29 standard. The `buildFromHexEncodedErgoValue()` method builds an attachment from a hex-encoded Ergo value. The `buildFromAdditionalRegisters()` method builds an attachment from the additional registers of an `ErgoBox`, if one is found. The `buildFromTransactionBox()` method builds an attachment from the registers of a `TransactionBox`.\n\nThe class also provides methods for building specific types of attachments. The `createPlainTextAttachment()` method creates a `BoxAttachmentPlainText` attachment for a given text string. The `createMultiAttachment()` method creates a `BoxAttachmentMulti` attachment for a list of attachments.\n\nOverall, the `BoxAttachmentBuilder` class provides a convenient way to build box attachments for use in Ergo transactions. Developers can use the methods provided by this class to build attachments that comply with the EIP-29 standard, or to build custom attachments for their specific use case. For example, a developer could use the `createPlainTextAttachment()` method to attach a message to an `ErgoBox`, or use the `buildFromAdditionalRegisters()` method to extract an attachment from an existing box.\n## Questions: \n 1. What is the purpose of this code?\n    \n    This code provides utility methods for building EIP-29 compliant box attachments for Ergo transactions.\n\n2. What is EIP-29 and why is it relevant to this code?\n    \n    EIP-29 is a proposal for a standard way of attaching metadata to Ergo transactions. This code provides methods for building attachments that conform to this standard.\n\n3. What are some examples of the types of attachments that can be created using this code?\n    \n    This code provides methods for creating plain text attachments and multi-attachments, as well as attachments built from serialized Ergo values in additional registers or transaction boxes.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/BoxAttachmentBuilder.md"}}],["292",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/ColdBlockchainContext.scala)\n\nThe `ColdBlockchainContext` class is a part of the `ergo-appkit` project and is used to create a context for interacting with the Ergo blockchain. This class extends the `BlockchainContextBase` class and provides an implementation for several of its abstract methods. \n\nThe purpose of this class is to provide a context for interacting with the Ergo blockchain in a cold environment, meaning that it does not have access to a data source or pre header builder. This is useful for scenarios where the user wants to create and sign transactions offline, without the need for a network connection. \n\nThe `ColdBlockchainContext` class takes two parameters: `networkType` and `params`. `networkType` is an enum that specifies the network type (Mainnet or Testnet) and `params` is an instance of the `BlockchainParameters` class that contains various parameters related to the blockchain. \n\nThe class provides implementations for several methods, including `getParameters`, which returns the `BlockchainParameters` instance passed to the constructor, and `newProverBuilder`, which returns a new instance of `ErgoProverBuilderImpl` that can be used to create a new `ErgoProver` instance for signing transactions. \n\nOther methods such as `getHeight`, `sendTransaction`, `getUnspentBoxesFor`, and `getCoveringBoxesFor` are not implemented and will throw an exception if called. These methods are typically used for interacting with the blockchain data source and are not available in a cold environment. \n\nHere is an example of how the `ColdBlockchainContext` class can be used to create a new `ErgoProver` instance:\n\n```\nval networkType = NetworkType.TESTNET\nval params = new BlockchainParameters()\nval context = new ColdBlockchainContext(networkType, params)\nval prover = context.newProverBuilder().build()\n```\n\nIn this example, a new `ColdBlockchainContext` instance is created with the `TESTNET` network type and default blockchain parameters. A new `ErgoProver` instance is then created using the `newProverBuilder` method of the context. This `ErgoProver` instance can be used to sign transactions offline.\n## Questions: \n 1. What is the purpose of the `ColdBlockchainContext` class?\n- The `ColdBlockchainContext` class is a subclass of `BlockchainContextBase` that provides methods for interacting with the Ergo blockchain in a cold (offline) environment.\n\n2. What is the difference between `getUnspentBoxesFor` and `getCoveringBoxesFor` methods?\n- The `getUnspentBoxesFor` method returns a list of unspent input boxes for a given address, while the `getCoveringBoxesFor` method returns a `CoveringBoxes` object that contains a list of input boxes that cover a specified amount of Ergs and tokens for a given address.\n\n3. What does the `signedTxFromJson` method do?\n- The `signedTxFromJson` method is not implemented and throws a `NotImplementedError` when called. It is likely intended to parse a JSON string representation of a signed transaction and return a `SignedTransaction` object.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/ColdBlockchainContext.md"}}],["293",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/Eip4TokenBuilder.java)\n\nThe `Eip4TokenBuilder` class provides convenience methods for building an `Eip4Token`, which is a type of token used in the Ergo blockchain. The class contains several static methods that can be used to build an `Eip4Token` from different sources, such as hex-encoded registers, additional registers returned by the Ergo Explorer API, or an `ErgoBox` object.\n\nThe `buildFromHexEncodedRegisters` method takes a token ID, token amount, and a list of hex-encoded register values for registers R4-R9. It decodes the register values and creates an `Eip4Token` object with the given parameters.\n\nThe `buildFromAdditionalRegisters` method takes a token ID, token amount, and an `AdditionalRegisters` object returned by the Ergo Explorer API. It extracts the register values for registers R4-R9 from the `AdditionalRegisters` object and creates an `Eip4Token` object using the `buildFromHexEncodedRegisters` method.\n\nThe `buildFromExplorerByTokenId` and `buildFromExplorerByIssuingBox` methods use the Ergo Explorer API to retrieve information about a token or an issuing box and create an `Eip4Token` object from the returned data.\n\nThe `buildFromErgoBox` method takes a token ID and an `ErgoBox` object and creates an `Eip4Token` object from the token information stored in the `ErgoBox`.\n\nThe class also provides several methods for building specific types of `Eip4Token` objects, such as NFT picture, video, and audio tokens, as well as an NFT artwork collection token.\n\nOverall, the `Eip4TokenBuilder` class provides a convenient way to create `Eip4Token` objects from various sources, making it easier to work with tokens in the Ergo blockchain.\n## Questions: \n 1. What is the purpose of the `Eip4TokenBuilder` class?\n- The `Eip4TokenBuilder` class provides convenience methods for building an `Eip4Token`, which is a type of token used in the Ergo blockchain.\n\n2. What are the required and optional registers for building an EIP-4 compliant minting box?\n- The required registers for building an EIP-4 compliant minting box are R4, R5, and R6. The optional registers are R7, R8, and R9.\n\n3. What is the purpose of the `buildFromExplorerByTokenId` method?\n- The `buildFromExplorerByTokenId` method builds an `Eip4Token` from the information retrieved from the Ergo Explorer API using a token ID.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/Eip4TokenBuilder.md"}}],["294",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/ErgoProverBuilderImpl.scala)\n\nThe `ErgoProverBuilderImpl` class is a builder for creating an `ErgoProver` instance, which is used for generating proofs for spending Ergo transactions. The builder provides methods for setting up the necessary keys and secrets required for generating proofs.\n\nThe builder takes in a `BlockchainContextBase` instance in its constructor, which is used to create the `ErgoProver` instance. The `ErgoProver` instance is created by calling the `build` method on the builder.\n\nThe builder provides several methods for setting up the keys and secrets required for generating proofs. These methods include:\n\n- `withMnemonic`: This method takes in a `mnemonicPhrase` and a `mnemonicPass` and generates an `ExtendedSecretKey` from them. The `ExtendedSecretKey` is used as the master key for generating other secret keys required for generating proofs. This method can also take in a `usePre1627KeyDerivation` flag to specify whether to use the pre-1627 key derivation scheme or not.\n\n- `withEip3Secret`: This method generates a secret key for a given derivation index using the EIP-3 key derivation scheme. The EIP-3 scheme is used to generate secret keys for spending Ergo transactions.\n\n- `withSecretStorage`: This method takes in a `SecretStorage` instance and sets the master key for generating other secret keys required for generating proofs.\n\n- `withDHTData`: This method takes in the parameters required for generating a Diffie-Hellman tuple and generates a `DiffieHellmanTupleProverInput` instance. The `DiffieHellmanTupleProverInput` instance is used for generating proofs.\n\n- `withDLogSecret`: This method takes in a `BigInteger` and generates a `DLogProtocol.DLogProverInput` instance. The `DLogProtocol.DLogProverInput` instance is used for generating proofs.\n\nThe `build` method creates an `ErgoProver` instance using the keys and secrets set up by the builder. The `ErgoProver` instance is created using an `AppkitProvingInterpreter` instance, which takes in the keys and secrets set up by the builder.\n\nOverall, the `ErgoProverBuilderImpl` class provides a convenient way to set up the necessary keys and secrets required for generating proofs for spending Ergo transactions. It abstracts away the complexity of generating these keys and secrets and provides a simple interface for creating an `ErgoProver` instance.\n## Questions: \n 1. What is the purpose of the `ErgoProverBuilderImpl` class?\n- The `ErgoProverBuilderImpl` class is used to build an `ErgoProver` object, which is used to create and sign transactions on the Ergo blockchain.\n\n2. What is the difference between `withMnemonic` and `withEip3Secret` methods?\n- The `withMnemonic` methods are used to generate a master key from a mnemonic phrase, while the `withEip3Secret` method is used to generate a secret key from a derivation path index.\n\n3. What is the purpose of the `build` method?\n- The `build` method is used to create an `ErgoProver` object using the parameters and secrets provided to the builder.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/ErgoProverBuilderImpl.md"}}],["295",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/ErgoProverImpl.scala)\n\nThe `ErgoProverImpl` class is an implementation of the `ErgoProver` interface in the `ergoplatform.appkit` package. It provides methods for creating and signing transactions on the Ergo blockchain. \n\nThe `ErgoProverImpl` constructor takes two arguments: a `BlockchainContextBase` object and an `AppkitProvingInterpreter` object. The `BlockchainContextBase` object provides access to the blockchain data, while the `AppkitProvingInterpreter` object is used to sign transactions. \n\nThe `getP2PKAddress` method returns a `P2PKAddress` object, which is a pay-to-public-key address. It uses the first public key in the `AppkitProvingInterpreter` object to create the address. \n\nThe `getAddress` method returns an `Address` object, which is a wrapper around the `P2PKAddress` object returned by `getP2PKAddress`. \n\nThe `getSecretKey` method returns the private key associated with the first public key in the `AppkitProvingInterpreter` object. \n\nThe `getEip3Addresses` method returns a list of `Address` objects for the remaining public keys in the `AppkitProvingInterpreter` object. \n\nThe `sign` method is used to sign an `UnsignedTransaction` object. It takes an optional `baseCost` parameter, which is used to specify the minimum cost of the transaction. If `baseCost` is not specified, it defaults to 0. \n\nThe `signMessage` method is used to sign a message using a `SigmaProp` object. It takes a message as a byte array and a `HintsBag` object as parameters. \n\nThe `reduce` method is used to reduce an `UnsignedTransaction` object to a `ReducedTransaction` object. It takes an optional `baseCost` parameter, which is used to specify the minimum cost of the transaction. If `baseCost` is not specified, it defaults to 0. \n\nThe `signReduced` method is used to sign a `ReducedTransaction` object. It takes an optional `baseCost` parameter, which is used to specify the minimum cost of the transaction. If `baseCost` is not specified, it defaults to 0. \n\nOverall, the `ErgoProverImpl` class provides a convenient way to sign transactions on the Ergo blockchain. It can be used in conjunction with other classes in the `ergoplatform.appkit` package to build and submit transactions to the network. \n\nExample usage:\n\n```scala\nval prover = new ErgoProverImpl(ctx, interpreter)\nval tx = new UnsignedTransactionImpl(...)\nval signedTx = prover.sign(tx)\n```\n## Questions: \n 1. What is the purpose of the `ErgoProverImpl` class?\n- The `ErgoProverImpl` class is an implementation of the `ErgoProver` trait, which provides methods for signing and reducing transactions in the Ergo blockchain.\n\n2. What is the significance of the `networkPrefix` method?\n- The `networkPrefix` method returns the prefix of the network type of the blockchain context, which is used to create P2PK addresses.\n\n3. What is the role of the `sign` method in the `ErgoProverImpl` class?\n- The `sign` method is used to sign an unsigned transaction, either with or without a specified base cost, using the `AppkitProvingInterpreter` provided to the `ErgoProverImpl` instance.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/ErgoProverImpl.md"}}],["296",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/InputBoxImpl.java)\n\nThe `InputBoxImpl` class is part of the `ergo-appkit` project and provides an implementation of the `InputBox` interface. The purpose of this class is to represent an input box in an Ergo transaction. An input box is an ErgoBox that is being spent in a transaction. The class provides methods to access the properties of an input box such as its ID, value, creation height, tokens, registers, and ergo tree. It also provides methods to convert an input box to JSON format and to get the bytes of the input box.\n\nThe class has three constructors that take different types of input data. The first constructor takes an `ErgoTransactionOutput` object, which is the output of a previous transaction that is being spent. The second constructor takes an `OutputInfo` object, which is a summary of an output on the blockchain. The third constructor takes an `ErgoBox` object, which is an input box being spent in a transaction.\n\nThe `withContextVars` method allows the user to add context variables to the input box. Context variables are used to provide additional information to the script that is being executed in the input box. The `toErgoValue` method returns an `ErgoValue` object that represents the input box as a Sigma value.\n\nOverall, the `InputBoxImpl` class provides a convenient way to access the properties of an input box in an Ergo transaction. It can be used in the larger `ergo-appkit` project to build and sign Ergo transactions. Below is an example of how to use the `InputBoxImpl` class to get the value of an input box:\n\n```\nInputBox inputBox = new InputBoxImpl(ergoBox);\nlong value = inputBox.getValue();\n```\n## Questions: \n 1. What is the purpose of the `InputBoxImpl` class?\n    \n    `InputBoxImpl` is a class that implements the `InputBox` interface and provides methods to access and manipulate data related to an input box in the Ergo blockchain.\n\n2. What external libraries or dependencies does this code use?\n    \n    This code uses several external libraries, including `com.google.gson`, `org.ergoplatform`, `org.ergoplatform.appkit`, `org.ergoplatform.explorer.client.model`, `org.ergoplatform.restapi.client`, `sigmastate`, and `special.sigma`.\n\n3. What methods are available to access data related to an input box?\n    \n    The `InputBoxImpl` class provides several methods to access data related to an input box, including `getId()`, `getValue()`, `getCreationHeight()`, `getTokens()`, `getRegisters()`, `getErgoTree()`, `getAttachment()`, `withContextVars()`, `toJson()`, `getBytes()`, `getTransactionId()`, `getTransactionIndex()`, `getErgoBox()`, `getExtension()`, `toString()`, and `toErgoValue()`.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/InputBoxImpl.md"}}],["297",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/NodeAndExplorerDataSourceImpl.java)\n\nThe `NodeAndExplorerDataSourceImpl` class is an implementation of the `BlockchainDataSource` interface that provides access to blockchain data through both the Node API and the Explorer API. The Node API is preferred, but the Explorer API is optional and can be used as a fallback. \n\nThe class provides methods for retrieving blockchain parameters, block headers, input boxes, and unspent boxes for a given address. It also provides methods for sending transactions and retrieving unconfirmed transactions. \n\nThe `getNodeInfo` method retrieves information about the node, including the blockchain parameters, which are cached to avoid multiple fetches. The `getLastBlockHeaders` method retrieves the last `count` block headers, optionally including only full headers. The `getBoxById` method retrieves an input box by its ID, optionally searching for it in the pool or spent boxes. The `sendTransaction` method sends a signed transaction to the node, optionally checking it with the `checkTransaction` endpoint before sending. The `getUnspentBoxesFor` method retrieves unspent boxes for a given address, using the Explorer API. The `getUnconfirmedUnspentBoxesFor` method retrieves unconfirmed unspent boxes for a given address, using both the Node API and the Explorer API. The `getUnconfirmedTransactions` method retrieves unconfirmed transactions from the node. \n\nThe class also provides getters for the API clients, which can be used for making custom API calls. \n\nExample usage:\n\n```java\nErgoClient client = ...;\nBlockchainDataSource dataSource = client.getBlockchainContext().getDataSource();\nBlockchainParameters params = dataSource.getParameters();\nList<BlockHeader> headers = dataSource.getLastBlockHeaders(10, true);\nAddress address = Address.create(\"9f9e9d8d9c9b9a999897969594939291908f8e\");\nList<InputBox> unspentBoxes = dataSource.getUnspentBoxesFor(address, 0, 10);\nList<Transaction> unconfirmedTxs = dataSource.getUnconfirmedTransactions(0, 10);\n```\n## Questions: \n 1. What is the purpose of this class?\n    \n    This class is a BlockchainDataSource implementation that uses both Node API and Explorer API to interact with the Ergo blockchain. It provides methods to retrieve blockchain parameters, block headers, input boxes, and transactions, as well as to send signed transactions.\n\n2. What is the significance of the performCheckBeforeSend boolean variable?\n    \n    The performCheckBeforeSend boolean variable, when set to true, makes the sendTransaction method call the node's checkTransaction endpoint before actually sending the transaction. This is useful for verifying that the transaction is valid and will be accepted by the node before committing it to the blockchain.\n\n3. What is the purpose of the executeCall method?\n    \n    The executeCall method is a helper method that executes an API call and handles any exceptions that may occur. It is used throughout the class to execute API calls to both the Node API and Explorer API.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/NodeAndExplorerDataSourceImpl.md"}}],["298",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/NodeInfoParameters.java)\n\nThe `NodeInfoParameters` class is a part of the `ergo-appkit` project and implements the `BlockchainParameters` interface. It takes in a `NodeInfo` object as a parameter in its constructor and provides methods to retrieve various blockchain parameters from it. \n\nThe `NodeInfo` object contains information about the node, such as the network type, block size, and various costs associated with transactions. The `NodeInfoParameters` class extracts this information and provides it in a format that can be used by other parts of the `ergo-appkit` project.\n\nFor example, the `getNetworkType()` method returns the network type of the node, which can be used to determine whether the node is running on the mainnet or testnet. The `getMaxBlockSize()` method returns the maximum block size allowed by the node, which can be used to ensure that blocks created by the project do not exceed this limit.\n\nOverall, the `NodeInfoParameters` class provides a convenient way to access blockchain parameters from a `NodeInfo` object and use them in other parts of the `ergo-appkit` project. \n\nExample usage:\n\n```\nNodeInfo nodeInfo = getNodeInfo(); // get NodeInfo object from somewhere\nBlockchainParameters params = new NodeInfoParameters(nodeInfo);\nint maxBlockSize = params.getMaxBlockSize(); // get the maximum block size allowed by the node\n```\n## Questions: \n 1. What is the purpose of this code?\n    \n    This code defines a class called `NodeInfoParameters` that implements the `BlockchainParameters` interface and retrieves various blockchain parameters from a `NodeInfo` object.\n\n2. What is the `BlockchainParameters` interface and what methods does it define?\n    \n    The `BlockchainParameters` interface is implemented by the `NodeInfoParameters` class and defines methods for retrieving various blockchain parameters such as network type, storage fee factor, minimum value per byte, etc.\n\n3. What is the `NodeInfo` class and where does it come from?\n    \n    The `NodeInfo` class is used to retrieve information about a node on the Ergo blockchain network and is likely part of the Ergo REST API client library. It is used in this code to retrieve various blockchain parameters.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/NodeInfoParameters.md"}}],["299",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/OutBoxBuilderImpl.scala)\n\nThe `OutBoxBuilderImpl` class is a part of the `ergo-appkit` project and is used to build an `OutBox` object. An `OutBox` is a data structure that represents an output box of a transaction in the Ergo blockchain. The `OutBoxBuilderImpl` class provides methods to set the value, contract, tokens, registers, and creation height of an `OutBox`. \n\nThe `OutBoxBuilderImpl` class implements the `OutBoxBuilder` trait, which defines the methods that can be used to set the properties of an `OutBox`. The `OutBoxBuilderImpl` class has a private variable `_txB` of type `UnsignedTransactionBuilderImpl`, which is used to get the context of the blockchain. The context is obtained by casting the context of the transaction builder to `BlockchainContextImpl`. \n\nThe `OutBoxBuilderImpl` class has private variables `_value`, `_contract`, `_tokens`, `_registers`, and `_creationHeightOpt`. The `_value` variable is used to store the value of the output box. The `_contract` variable is used to store the contract of the output box. The `_tokens` variable is used to store the tokens of the output box. The `_registers` variable is used to store the registers of the output box. The `_creationHeightOpt` variable is used to store the creation height of the output box.\n\nThe `OutBoxBuilderImpl` class provides methods to set the value, contract, tokens, registers, and creation height of an `OutBox`. The `value` method is used to set the value of the output box. The `contract` method is used to set the contract of the output box. The `tokens` method is used to set the tokens of the output box. The `mintToken` method is used to mint a new token and add it to the output box. The `registers` method is used to set the registers of the output box. The `creationHeight` method is used to set the creation height of the output box.\n\nThe `build` method is used to build an `OutBox` object. The `build` method checks if the contract is defined and creates an `ErgoBoxCandidate` object using the value, contract, tokens, registers, and creation height of the output box. The `ErgoBoxCandidate` object is then used to create an `OutBoxImpl` object, which is returned by the `build` method.\n\nExample usage:\n\n```\nval outBoxBuilder = new OutBoxBuilderImpl(unsignedTransactionBuilder)\nval outBox = outBoxBuilder\n  .value(1000000000)\n  .contract(contract)\n  .tokens(token1, token2)\n  .registers(register1, register2)\n  .creationHeight(1000)\n  .build()\n```\n## Questions: \n 1. What is the purpose of the `OutBoxBuilderImpl` class?\n- The `OutBoxBuilderImpl` class is used to build an `OutBox` object, which represents an output box in the Ergo blockchain.\n\n2. What is the difference between the `tokens` and `mintToken` methods?\n- The `tokens` method is used to add one or more `ErgoToken` objects to the output box being built, while the `mintToken` method is used to add an `Eip4Token` object to the output box and also adds some additional registers to the output box.\n\n3. What happens if the `contract` parameter is not defined when calling the `build` method?\n- If the `contract` parameter is not defined when calling the `build` method, a `checkState` exception will be thrown with the message \"Contract is not defined\".","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/OutBoxBuilderImpl.md"}}],["300",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/OutBoxImpl.scala)\n\nThe `OutBoxImpl` class is a part of the `ergo-appkit` project and is used to represent an output box in the Ergo blockchain. An output box is a data structure that contains a certain amount of value, tokens, and registers, and is created by a transaction. The purpose of this class is to provide methods to access the properties of an output box.\n\nThe class implements the `OutBox` interface, which defines the methods that can be used to access the properties of an output box. The `OutBoxImpl` class provides implementations for all the methods defined in the `OutBox` interface.\n\nThe `getValue` method returns the value of the output box, which is the amount of Ergs (the native cryptocurrency of the Ergo blockchain) contained in the box. The `getCreationHeight` method returns the height of the block in which the output box was created. The `getTokens` method returns a list of `ErgoToken` objects, which represent the tokens contained in the box. The `getRegisters` method returns a list of `ErgoValue` objects, which represent the values stored in the registers of the box. The `getBytesWithNoRef` method returns the serialized bytes of the box without the reference to the transaction that created it. The `getErgoTree` method returns the ErgoTree of the box, which is a script that defines the spending conditions for the box.\n\nThe `getAttachment` method returns the `BoxAttachment` stored in the box, if any. A `BoxAttachment` is an arbitrary piece of data that can be attached to a box and can be used to store additional information about the box.\n\nThe `getErgoBoxCandidate` method is a package-private method that returns the `ErgoBoxCandidate` object that was used to create the output box.\n\nThe `convertToInputWith` method is used to convert the output box to an input box, which can be used as an input to a new transaction. The method takes two parameters: the transaction ID and the index of the output box in the transaction. The method creates a new `InputBoxImpl` object using the `ErgoBoxCandidate` object and returns it.\n\nOverall, the `OutBoxImpl` class provides a convenient way to access the properties of an output box in the Ergo blockchain and can be used in the larger `ergo-appkit` project to build applications that interact with the Ergo blockchain. Here is an example of how to use the `OutBoxImpl` class to get the value of an output box:\n\n```scala\nimport org.ergoplatform.appkit.impl.OutBoxImpl\n\nval outBox = new OutBoxImpl(ergoBoxCandidate)\nval value = outBox.getValue\n```\n## Questions: \n 1. What is the purpose of the `OutBoxImpl` class?\n    \n    Answer: The `OutBoxImpl` class is an implementation of the `OutBox` interface, which represents an output box of a transaction in the Ergo blockchain.\n\n2. What is the `BoxAttachment` and how is it related to the `OutBoxImpl` class?\n\n    Answer: The `BoxAttachment` is an object that can be stored in an output box of a transaction. The `OutBoxImpl` class has a method `getAttachment` that returns the `BoxAttachment` stored in the box, or null if there is none.\n\n3. What is the purpose of the `convertToInputWith` method in the `OutBoxImpl` class?\n\n    Answer: The `convertToInputWith` method takes a transaction ID and a box index as arguments, and returns an `InputBox` object that represents the same box as an input box in the specified transaction. This method is useful for spending an output box in a subsequent transaction.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/OutBoxImpl.md"}}],["301",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/PreHeaderBuilderImpl.java)\n\nThe `PreHeaderBuilderImpl` class is a part of the `ergo-appkit` project and is responsible for building a `PreHeader` object. A `PreHeader` is a data structure that contains information about a block header before it is mined. It is used to create a new block header and is included in the block header as a part of the block. The `PreHeaderBuilderImpl` class provides methods to set the various fields of the `PreHeader` object and build it.\n\nThe class has a constructor that takes a `BlockchainContextImpl` object as a parameter. The `BlockchainContextImpl` object provides access to the blockchain data and is used to get the latest block header.\n\nThe class has several private fields that correspond to the fields of the `PreHeader` object. These fields are set using the various setter methods provided by the class. The `version` field represents the version of the block header. The `parentId` field represents the hash of the parent block header. The `timestamp` field represents the timestamp of the block header. The `nBits` field represents the difficulty target of the block header. The `height` field represents the height of the block header. The `minerPk` field represents the public key of the miner who mined the block header. The `votes` field represents the votes for the block header.\n\nThe class provides setter methods for each of these fields. These methods take the corresponding data type as a parameter and return the `PreHeaderBuilder` object. This allows for method chaining and makes the code more readable.\n\nThe `build` method is used to build the `PreHeader` object. It uses the latest block header obtained from the `BlockchainContextImpl` object to set the default values for the fields that are not set using the setter methods. It then creates a new `CPreHeader` object using the values of the fields and returns a new `PreHeaderImpl` object using the `CPreHeader` object.\n\nOverall, the `PreHeaderBuilderImpl` class provides a convenient way to build a `PreHeader` object and is an important part of the `ergo-appkit` project. Here is an example of how to use this class:\n\n```\nBlockchainContextImpl ctx = new BlockchainContextImpl();\nPreHeaderBuilder builder = new PreHeaderBuilderImpl(ctx);\nPreHeader preHeader = builder.version(1)\n                              .parentId(new Coll<Byte>())\n                              .timestamp(System.currentTimeMillis())\n                              .nBits(123456789L)\n                              .height(1000)\n                              .minerPk(new GroupElement())\n                              .votes(new Coll<Byte>())\n                              .build();\n```\n## Questions: \n 1. What is the purpose of this code?\n   - This code defines a class `PreHeaderBuilderImpl` that implements the `PreHeaderBuilder` interface and provides methods to build a `PreHeader` object for the Ergo blockchain.\n\n2. What is the relationship between `PreHeaderBuilderImpl` and `BlockchainContextImpl`?\n   - `PreHeaderBuilderImpl` takes an instance of `BlockchainContextImpl` as a constructor argument, which is then used to retrieve the latest block header to set default values for the `PreHeader` object being built.\n\n3. What is the purpose of casting `Coll<Byte>` to `Coll<Object>` in some of the methods?\n   - The `Coll` class is a generic collection type that is used to represent collections of various types in the Ergo codebase. In this case, the `Coll` passed to the methods is expected to contain `Byte` objects, but the method signature requires a `Coll<Object>`. The cast is used to satisfy the type requirement and avoid a compilation error.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/PreHeaderBuilderImpl.md"}}],["302",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/PreHeaderImpl.java)\n\nThe `PreHeaderImpl` class is a part of the `ergo-appkit` project and is used to represent a pre-header of a block in the Ergo blockchain. A pre-header is a part of a block header that contains some basic information about the block, such as its version, parent block ID, timestamp, difficulty target, height, miner public key, and votes. \n\nThis class implements the `PreHeader` interface, which defines methods to access these fields. The constructor takes a `special.sigma.PreHeader` object as an argument and initializes the `_ph` field with it. The methods in this class simply delegate to the corresponding methods in the `_ph` object to retrieve the values of the pre-header fields.\n\nFor example, the `getVersion()` method returns the version of the block, which is obtained by calling the `version()` method on the `_ph` object. Similarly, the `getParentId()` method returns the parent block ID as a `Coll<Byte>` object, which is obtained by casting the result of calling the `parentId()` method on the `_ph` object to `Object` and then casting it to `Coll<Byte>`. \n\nThis class can be used in the larger `ergo-appkit` project to retrieve information about a block's pre-header. For example, if we have a `Block` object representing a block in the Ergo blockchain, we can get its pre-header by calling the `preHeader()` method on it, which returns a `special.sigma.PreHeader` object. We can then create a `PreHeaderImpl` object from this `special.sigma.PreHeader` object and use its methods to access the pre-header fields. \n\n```java\nBlock block = ...; // get a block object\nspecial.sigma.PreHeader ph = block.preHeader(); // get the pre-header\nPreHeader preHeader = new PreHeaderImpl(ph); // create a PreHeaderImpl object\nbyte version = preHeader.getVersion(); // get the version of the block\nColl<Byte> parentId = preHeader.getParentId(); // get the parent block ID\nlong timestamp = preHeader.getTimestamp(); // get the timestamp of the block\n// and so on\n``` \n\nOverall, the `PreHeaderImpl` class provides a convenient way to access the pre-header fields of a block in the Ergo blockchain.\n## Questions: \n 1. What is the purpose of the `PreHeader` interface and how is it used in the `ergo-appkit` project?\n- The `PreHeader` interface is used to represent a pre-header of a block in the Ergo blockchain. It is implemented by the `PreHeaderImpl` class in the `ergo-appkit` project.\n\n2. What is the significance of the `special.sigma` package and how does it relate to the `PreHeaderImpl` class?\n- The `special.sigma` package contains classes that are used to represent Sigma protocols in the Ergo blockchain. The `PreHeaderImpl` class uses a `special.sigma.PreHeader` object to implement the `PreHeader` interface.\n\n3. Why are type casts used in the `getParentId()` and `getVotes()` methods of the `PreHeaderImpl` class?\n- The `getParentId()` and `getVotes()` methods return a `Coll<Byte>` object, but the underlying `special.sigma.PreHeader` object returns a different type. The type casts are used to convert the return type to `Coll<Byte>`.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/PreHeaderImpl.md"}}],["303",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/ReducedTransactionImpl.java)\n\nThe `ReducedTransactionImpl` class is a part of the `ergo-appkit` project and provides an implementation of the `ReducedTransaction` interface. The purpose of this class is to provide a simplified view of an Ergo transaction that can be used by developers to interact with the Ergo blockchain.\n\nThe `ReducedTransactionImpl` constructor takes two parameters: a `BlockchainContextBase` object and a `ReducedErgoLikeTransaction` object. The `BlockchainContextBase` object provides context for the transaction, while the `ReducedErgoLikeTransaction` object represents the transaction itself. The `ReducedTransactionImpl` class provides several methods that allow developers to interact with the transaction.\n\nThe `getId()` method returns the ID of the transaction. The ID is a unique identifier for the transaction that can be used to retrieve it from the blockchain.\n\nThe `getInputBoxesIds()` method returns a list of IDs for the input boxes of the transaction. An input box is a box that is being spent by the transaction. The IDs can be used to retrieve the input boxes from the blockchain.\n\nThe `getOutputs()` method returns a list of `OutBox` objects that represent the output boxes of the transaction. An output box is a box that is being created by the transaction. The `OutBox` interface provides methods for interacting with the output box.\n\nThe `getTx()` method returns the underlying `ReducedErgoLikeTransaction` object.\n\nThe `getCost()` method returns the cost of the transaction. The cost is a measure of the computational resources required to execute the transaction.\n\nThe `toBytes()` method serializes the transaction to a byte array.\n\nThe `hashCode()` and `equals()` methods are used for comparing transactions.\n\nThe `toString()` method returns a string representation of the transaction.\n\nOverall, the `ReducedTransactionImpl` class provides a simplified view of an Ergo transaction that can be used by developers to interact with the Ergo blockchain. Developers can use the methods provided by this class to retrieve information about a transaction, such as its ID, input boxes, output boxes, and cost. They can also serialize the transaction to a byte array and compare transactions using the `hashCode()` and `equals()` methods.\n## Questions: \n 1. What is the purpose of the `ReducedTransactionImpl` class?\n- The `ReducedTransactionImpl` class is an implementation of the `ReducedTransaction` interface, which provides methods for retrieving information about a reduced version of an Ergo transaction.\n\n2. What is the significance of the `getOutputs` method?\n- The `getOutputs` method returns a list of `OutBox` objects, which represent the output boxes of the transaction.\n\n3. What is the purpose of the `toBytes` method?\n- The `toBytes` method serializes the `ReducedErgoLikeTransaction` object to a byte array using the Sigma serialization format.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/ReducedTransactionImpl.md"}}],["304",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/ScalaBridge.scala)\n\nThe `ScalaBridge` object in the `ergo-appkit` project provides a set of implicit conversions between Java and Scala data structures used in the Ergo platform. These conversions are essential for seamless interoperability between the Java-based Ergo AppKit and the Scala-based Ergo platform.\n\nThe conversions are implemented using `Iso` instances, which define a bidirectional mapping between two types. For example, the `isoSpendingProof` instance converts between `SpendingProof` (Java) and `ProverResult` (Scala) types. This allows developers to work with Ergo platform data structures in a more familiar Java environment while still leveraging the power of the Scala-based Ergo platform.\n\nSome of the key conversions provided by `ScalaBridge` include:\n\n- `isoSpendingProof`: Converts between `SpendingProof` and `ProverResult`.\n- `isoErgoTransactionDataInput`: Converts between `ErgoTransactionDataInput` and `DataInput`.\n- `isoErgoTransactionInput`: Converts between `ErgoTransactionInput` and `Input`.\n- `isoErgoTransactionUnsignedInput`: Converts between `ErgoTransactionUnsignedInput` and `UnsignedInput`.\n- `isoAssetToErgoToken`: Converts between `Asset` and `ErgoToken`.\n- `isoStringToErgoTree`: Converts between `String` and `ErgoTree`.\n- `isoRegistersToMap`: Converts between `Registers` and `AdditionalRegisters`.\n- `isoErgoTransactionOutput`: Converts between `ErgoTransactionOutput` and `ErgoBox`.\n- `isoBlockHeader`: Converts between `BlockHeader` and `Header`.\n- `isoErgoTransaction`: Converts between `ErgoTransaction` and `ErgoLikeTransaction`.\n- `isoUnsignedErgoTransaction`: Converts between `UnsignedErgoTransaction` and `UnsignedErgoLikeTransaction`.\n\nThese conversions are used throughout the Ergo AppKit to enable seamless interaction between Java and Scala components. For example, when creating a new Ergo transaction, a developer can use the Java-based `ErgoTransaction` class, which is then converted to the Scala-based `ErgoLikeTransaction` using the `isoErgoTransaction` conversion before being processed by the Ergo platform.\n## Questions: \n 1. **What is the purpose of the `ScalaBridge` object?**\n\n   The `ScalaBridge` object is used to provide implicit conversions (isomorphisms) between different types used in the ergo-appkit project. It helps to convert between Java and Scala types, as well as between different representations of the same data structures.\n\n2. **What are the main types being converted in this code?**\n\n   The main types being converted in this code are related to Ergo transactions, inputs, outputs, and additional data structures like ErgoToken, ErgoTree, and AdditionalRegisters. The conversions are provided as implicit values of type `Iso[A, B]`, which define a bidirectional conversion between types A and B.\n\n3. **How are the conversions between types implemented?**\n\n   The conversions between types are implemented using the `Iso[A, B]` trait, which defines two methods: `to(a: A): B` and `from(b: B): A`. Each implicit value of type `Iso[A, B]` provides a specific implementation of these methods to convert between the corresponding types A and B. The conversions are then used implicitly when needed, thanks to the `convertTo` and `convertFrom` extension methods provided by the `org.ergoplatform.appkit.JavaHelpers` object.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/ScalaBridge.md"}}],["305",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/SignedInputImpl.java)\n\nThe `SignedInputImpl` class is a part of the `ergo-appkit` project and is used to represent a signed input in a transaction. It implements the `SignedInput` interface and provides methods to retrieve the proof bytes, context variables, input ID, and the signed transaction that the input belongs to.\n\nThe `SignedInputImpl` constructor takes two arguments: a `SignedTransactionImpl` object and an `Input` object. The `SignedTransactionImpl` object represents the signed transaction that the input belongs to, while the `Input` object represents the input itself. The constructor initializes the private fields `_signedTx`, `_input`, and `_id` with the provided arguments.\n\nThe `getProofBytes()` method returns the proof bytes of the input's spending proof. The spending proof is a cryptographic proof that the input owner has the right to spend the input. The method simply returns the proof bytes as a byte array.\n\nThe `getContextVars()` method returns a map of context variables associated with the input's spending proof. The context variables are key-value pairs that provide additional information required to validate the spending proof. The method uses an isomorphism to convert the Scala map of evaluated values to a Java map of `ErgoValue` objects.\n\nThe `getId()` method returns the ID of the input. The ID is a unique identifier that is derived from the ID of the box that the input spends.\n\nThe `getTransaction()` method returns the signed transaction that the input belongs to. The method simply returns the `_signedTx` field.\n\nOverall, the `SignedInputImpl` class provides a convenient way to work with signed inputs in a transaction. It encapsulates the input's data and provides methods to retrieve important information such as the proof bytes and context variables. This class can be used in conjunction with other classes in the `ergo-appkit` project to build and manipulate Ergo transactions. \n\nExample usage:\n\n```java\n// create a signed input\nSignedTransactionImpl signedTx = new SignedTransactionImpl();\nInput input = new Input();\nSignedInputImpl signedInput = new SignedInputImpl(signedTx, input);\n\n// get the proof bytes\nbyte[] proofBytes = signedInput.getProofBytes();\n\n// get the context variables\nMap<Byte, ErgoValue<?>> contextVars = signedInput.getContextVars();\n\n// get the input ID\nErgoId inputId = signedInput.getId();\n\n// get the signed transaction\nSignedTransaction tx = signedInput.getTransaction();\n```\n## Questions: \n 1. What is the purpose of the `SignedInputImpl` class?\n- The `SignedInputImpl` class implements the `SignedInput` interface and provides methods for retrieving proof bytes, context variables, ID, and transaction related to a signed input.\n\n2. What external dependencies does this file have?\n- This file has dependencies on `org.ergoplatform.Input`, `org.ergoplatform.appkit.*`, `sigmastate.SType`, and `sigmastate.Values`.\n\n3. What is the significance of the `getContextVars` method and how is it implemented?\n- The `getContextVars` method returns a map of context variables associated with the input's spending proof. It is implemented using an isomorphism between Java and Scala maps, and an isomorphism between Ergo and Sigma values.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/SignedInputImpl.md"}}],["306",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/SignedTransactionImpl.java)\n\nThe `SignedTransactionImpl` class is a part of the `ergo-appkit` project and provides an implementation of the `SignedTransaction` interface. This class is responsible for creating a signed transaction and provides methods to interact with the transaction. \n\nThe `SignedTransactionImpl` class has three instance variables: `_ctx`, `_tx`, and `_txCost`. The `_ctx` variable is of type `BlockchainContextBase` and represents the blockchain context. The `_tx` variable is of type `ErgoLikeTransaction` and represents the signed transaction. The `_txCost` variable is of type `int` and represents the cost of the transaction.\n\nThe `SignedTransactionImpl` class provides several methods to interact with the transaction. The `getTx()` method returns the underlying `ErgoLikeTransaction`. The `getId()` method returns the ID of the transaction. The `toJson()` method returns the transaction in JSON format. The `getSignedInputs()` method returns a list of signed inputs. The `getOutputsToSpend()` method returns a list of output boxes that can be spent. The `getInputBoxesIds()` method returns a list of input box IDs. The `getOutputs()` method returns a list of output boxes. The `getCost()` method returns the cost of the transaction. The `toBytes()` method returns the transaction in byte format.\n\nThe `toJson()` method is particularly interesting as it takes two boolean parameters: `prettyPrint` and `formatJson`. If `prettyPrint` is true, the output JSON is formatted with indentation and line breaks. If `formatJson` is true, the output JSON is formatted with a consistent style. \n\nHere is an example of how to use the `SignedTransactionImpl` class:\n\n```java\nBlockchainContext ctx = ...; // create a blockchain context\nErgoLikeTransaction tx = ...; // create a signed transaction\nint txCost = ...; // set the cost of the transaction\nSignedTransaction signedTx = new SignedTransactionImpl(ctx, tx, txCost);\n\n// get the ID of the transaction\nString txId = signedTx.getId();\n\n// get the transaction in JSON format\nString txJson = signedTx.toJson(true, true);\n\n// get a list of signed inputs\nList<SignedInput> signedInputs = signedTx.getSignedInputs();\n\n// get a list of output boxes that can be spent\nList<InputBox> outputsToSpend = signedTx.getOutputsToSpend();\n\n// get a list of input box IDs\nList<String> inputBoxIds = signedTx.getInputBoxesIds();\n\n// get a list of output boxes\nList<OutBox> outputs = signedTx.getOutputs();\n\n// get the cost of the transaction\nint txCost = signedTx.getCost();\n\n// get the transaction in byte format\nbyte[] txBytes = signedTx.toBytes();\n```\n## Questions: \n 1. What is the purpose of the `SignedTransactionImpl` class?\n- The `SignedTransactionImpl` class is an implementation of the `SignedTransaction` interface and provides methods for interacting with a signed Ergo transaction.\n\n2. What is the `toJson` method used for?\n- The `toJson` method is used to serialize the transaction to JSON format. It takes two boolean parameters, `prettyPrint` and `formatJson`, which control the formatting of the output.\n\n3. What is the purpose of the `getOutputsToSpend` method?\n- The `getOutputsToSpend` method returns a list of `InputBox` objects that represent the outputs of previous transactions that are being spent by the current transaction.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/SignedTransactionImpl.md"}}],["307",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/UnsignedTransactionBuilderImpl.scala)\n\nThe `UnsignedTransactionBuilderImpl` class is a part of the `ergo-appkit` project and is used to build unsigned transactions for the Ergo blockchain. The class implements the `UnsignedTransactionBuilder` interface and provides methods to add inputs, outputs, and data inputs to the transaction, specify the fee, tokens to burn, and change address, and build the unsigned transaction.\n\nThe class has several private fields, including lists of input boxes, output boxes, and data input boxes, as well as options for tokens to burn, fee amount, change address, and pre-header. The class also has a method to create an `ErgoLikeStateContext` object that is used to validate the transaction.\n\nThe `UnsignedTransactionBuilderImpl` class provides several methods to add inputs, outputs, and data inputs to the transaction. The `addInputs` method adds one or more input boxes to the list of input boxes, while the `boxesToSpend` method sets the list of input boxes to the specified list. The `addDataInputs` method adds one or more data input boxes to the list of data input boxes, while the `withDataInputs` method sets the list of data input boxes to the specified list. The `addOutputs` method adds one or more output boxes to the list of output boxes, while the `outputs` method sets the list of output boxes to the specified list.\n\nThe `UnsignedTransactionBuilderImpl` class also provides methods to specify the fee, tokens to burn, and change address. The `fee` method sets the fee amount for the transaction, while the `tokensToBurn` method sets the tokens to burn for the transaction. The `sendChangeTo` method sets the change address for the transaction.\n\nThe `UnsignedTransactionBuilderImpl` class provides a `build` method that builds the unsigned transaction using the specified inputs, outputs, data inputs, fee, tokens to burn, and change address. The method creates an `ErgoLikeStateContext` object and uses it to validate the transaction. The method returns an `UnsignedTransactionImpl` object that represents the unsigned transaction.\n\nOverall, the `UnsignedTransactionBuilderImpl` class is an important part of the `ergo-appkit` project that provides a convenient way to build unsigned transactions for the Ergo blockchain. Developers can use this class to create and validate transactions without having to write low-level code.\n## Questions: \n 1. What is the purpose of the `UnsignedTransactionBuilderImpl` class?\n- The `UnsignedTransactionBuilderImpl` class is used to build unsigned transactions for the Ergo blockchain.\n\n2. What are some of the methods available in the `UnsignedTransactionBuilderImpl` class?\n- Some of the methods available in the `UnsignedTransactionBuilderImpl` class include `preHeader`, `addInputs`, `addDataInputs`, `addOutputs`, `fee`, `tokensToBurn`, and `sendChangeTo`.\n\n3. What is the purpose of the `createErgoLikeStateContext` method?\n- The `createErgoLikeStateContext` method is used to create an `ErgoLikeStateContext` object that contains information about the current state of the Ergo blockchain, including the headers and pre-header.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/UnsignedTransactionBuilderImpl.md"}}],["308",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/lib-impl/src/main/java/org/ergoplatform/appkit/impl/UnsignedTransactionImpl.java)\n\nThe `UnsignedTransactionImpl` class is a part of the `ergo-appkit` project and provides an implementation of the `UnsignedTransaction` interface. It represents an unsigned transaction that can be used to spend unspent transaction outputs (UTXOs) on the Ergo blockchain. \n\nThe class has several fields that store information about the transaction, including the unsigned transaction itself (`_tx`), the list of input boxes to spend (`_boxesToSpend`), the list of data boxes (`_dataBoxes`), the list of tokens to burn (`_tokensToBurn`), the list of outputs (`_outputs`), the change address (`_changeAddress`), the state context (`_stateContext`), and the blockchain context (`_ctx`).\n\nThe class provides several methods to access and manipulate the transaction data. The `getId()` method returns the ID of the transaction. The `getInputs()` method returns a list of input boxes as `InputBox` objects. The `getInputBoxesIds()` method returns a list of input box IDs as strings. The `getOutputs()` method returns a list of output boxes as `OutBox` objects. The `getDataInputs()` method returns a list of data boxes as `InputBox` objects. The `getChangeAddress()` method returns the change address for the transaction. The `getTokensToBurn()` method returns a list of tokens to burn.\n\nThe `toJson()` method returns a JSON representation of the transaction. It takes two boolean parameters: `prettyPrint` and `formatJson`. If `prettyPrint` is true, the JSON output is formatted with indentation and line breaks. If `formatJson` is true, the JSON output is formatted with additional whitespace.\n\nOverall, the `UnsignedTransactionImpl` class provides a convenient way to create and manipulate unsigned transactions on the Ergo blockchain. It can be used in conjunction with other classes in the `ergo-appkit` project to build more complex applications that interact with the blockchain. \n\nExample usage:\n\n```\n// create an unsigned transaction\nUnsignedErgoLikeTransaction tx = ...;\nList<ExtendedInputBox> boxesToSpend = ...;\nList<ErgoBox> dataBoxes = ...;\nErgoAddress changeAddress = ...;\nErgoLikeStateContext stateContext = ...;\nBlockchainContextImpl ctx = ...;\nList<ErgoToken> tokensToBurn = ...;\nUnsignedTransactionImpl unsignedTx = new UnsignedTransactionImpl(tx, boxesToSpend, dataBoxes, changeAddress, stateContext, ctx, tokensToBurn);\n\n// get the ID of the transaction\nString txId = unsignedTx.getId();\n\n// get the list of input boxes\nList<InputBox> inputBoxes = unsignedTx.getInputs();\n\n// get the list of output boxes\nList<OutBox> outputBoxes = unsignedTx.getOutputs();\n\n// get the change address\nErgoAddress changeAddr = unsignedTx.getChangeAddress();\n\n// convert the transaction to JSON\nString json = unsignedTx.toJson(true, true);\n```\n## Questions: \n 1. What is the purpose of the `UnsignedTransactionImpl` class?\n- The `UnsignedTransactionImpl` class is an implementation of the `UnsignedTransaction` interface and provides methods for constructing and manipulating unsigned Ergo transactions.\n\n2. What are the inputs and outputs of an unsigned transaction represented by this code?\n- The inputs of an unsigned transaction are represented by a list of `ExtendedInputBox` objects, while the outputs are represented by a list of `ErgoBoxCandidate` objects.\n- Additionally, there is a list of `ErgoBox` objects representing data inputs, and a single `ErgoAddress` object representing the change address.\n\n3. What is the purpose of the `toJson` method in this class?\n- The `toJson` method is used to serialize an unsigned transaction object to JSON format, with the option to pretty-print the output and format the resulting JSON string.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/impl/UnsignedTransactionImpl.md"}}],["309",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/lib-impl/src/main/java/org/ergoplatform/appkit)\n\nThe `lib-impl/src/main/java/org/ergoplatform/appkit` folder contains the implementation of the Ergo Appkit library, which provides a set of tools and utilities for building Ergo applications. The library is designed to simplify the interaction with the Ergo blockchain and make it easier for developers to create, test, and deploy their applications.\n\nHere is a brief overview of the files in this folder:\n\n1. **Address.java**: This file contains the `Address` class, which represents an Ergo address. It provides methods for creating and validating addresses, as well as converting them to and from different formats (e.g., Base58, ErgoTree).\n\n   Example usage:\n   ```java\n   Address address = Address.fromBase58(\"9f4QF8AD1nQ3nJahQVkM6c5RqW5iH6G3tBmaJxU8CHutaHRdPzg\");\n   ErgoTree ergoTree = address.getErgoTree();\n   ```\n\n2. **BlockchainContext.java**: This file contains the `BlockchainContext` interface, which defines methods for interacting with the Ergo blockchain. It allows developers to access blockchain data, such as the current height, box values, and transaction data.\n\n   Example usage:\n   ```java\n   BlockchainContext context = ...;\n   long currentHeight = context.getHeight();\n   List<InputBox> boxes = context.getBoxesByIds(boxIds);\n   ```\n\n3. **ErgoToken.java**: This file contains the `ErgoToken` class, which represents an Ergo token. It provides methods for creating and manipulating tokens, as well as converting them to and from different formats (e.g., JSON, ErgoBox).\n\n   Example usage:\n   ```java\n   ErgoToken token = new ErgoToken(tokenId, tokenAmount);\n   long amount = token.getValue();\n   ```\n\n4. **InputBox.java**: This file contains the `InputBox` class, which represents an input box in an Ergo transaction. It provides methods for accessing box properties, such as the box value, tokens, and ErgoTree.\n\n   Example usage:\n   ```java\n   InputBox box = ...;\n   long boxValue = box.getValue();\n   List<ErgoToken> tokens = box.getTokens();\n   ```\n\n5. **SignedTransaction.java**: This file contains the `SignedTransaction` class, which represents a signed Ergo transaction. It provides methods for accessing transaction properties, such as the transaction id, inputs, and outputs.\n\n   Example usage:\n   ```java\n   SignedTransaction tx = ...;\n   String txId = tx.getId();\n   List<InputBox> inputs = tx.getInputs();\n   List<OutputBox> outputs = tx.getOutputs();\n   ```\n\nThese classes and interfaces work together to provide a high-level API for interacting with the Ergo blockchain. Developers can use them to create, sign, and submit transactions, as well as query the blockchain for relevant data. By using the Ergo Appkit library, developers can focus on building their applications without having to worry about the low-level details of the Ergo protocol.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/appkit/summary.md"}}],["310",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/lib-impl/src/main/java/org/ergoplatform)\n\nThe `lib-impl/src/main/java/org/ergoplatform/appkit` folder contains the implementation of the Ergo Appkit library, which provides a set of tools and utilities for building Ergo applications. The library is designed to simplify the interaction with the Ergo blockchain and make it easier for developers to create, test, and deploy their applications.\n\nHere is a brief overview of the files in this folder:\n\n1. **Address.java**: This file contains the `Address` class, which represents an Ergo address. It provides methods for creating and validating addresses, as well as converting them to and from different formats (e.g., Base58, ErgoTree).\n\n   Example usage:\n   ```java\n   Address address = Address.fromBase58(\"9f4QF8AD1nQ3nJahQVkM6c5RqW5iH6G3tBmaJxU8CHutaHRdPzg\");\n   ErgoTree ergoTree = address.getErgoTree();\n   ```\n\n2. **BlockchainContext.java**: This file contains the `BlockchainContext` interface, which defines methods for interacting with the Ergo blockchain. It allows developers to access blockchain data, such as the current height, box values, and transaction data.\n\n   Example usage:\n   ```java\n   BlockchainContext context = ...;\n   long currentHeight = context.getHeight();\n   List<InputBox> boxes = context.getBoxesByIds(boxIds);\n   ```\n\n3. **ErgoToken.java**: This file contains the `ErgoToken` class, which represents an Ergo token. It provides methods for creating and manipulating tokens, as well as converting them to and from different formats (e.g., JSON, ErgoBox).\n\n   Example usage:\n   ```java\n   ErgoToken token = new ErgoToken(tokenId, tokenAmount);\n   long amount = token.getValue();\n   ```\n\n4. **InputBox.java**: This file contains the `InputBox` class, which represents an input box in an Ergo transaction. It provides methods for accessing box properties, such as the box value, tokens, and ErgoTree.\n\n   Example usage:\n   ```java\n   InputBox box = ...;\n   long boxValue = box.getValue();\n   List<ErgoToken> tokens = box.getTokens();\n   ```\n\n5. **SignedTransaction.java**: This file contains the `SignedTransaction` class, which represents a signed Ergo transaction. It provides methods for accessing transaction properties, such as the transaction id, inputs, and outputs.\n\n   Example usage:\n   ```java\n   SignedTransaction tx = ...;\n   String txId = tx.getId();\n   List<InputBox> inputs = tx.getInputs();\n   List<OutputBox> outputs = tx.getOutputs();\n   ```\n\nThese classes and interfaces work together to provide a high-level API for interacting with the Ergo blockchain. Developers can use them to create, sign, and submit transactions, as well as query the blockchain for relevant data. By using the Ergo Appkit library, developers can focus on building their applications without having to worry about the low-level details of the Ergo protocol.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/ergoplatform/summary.md"}}],["311",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/lib-impl/src/main/java/org)\n\nThe `lib-impl/src/main/java/org/ergoplatform/appkit` folder contains the implementation of the Ergo Appkit library, which provides a set of tools and utilities for building Ergo applications. The library is designed to simplify the interaction with the Ergo blockchain and make it easier for developers to create, test, and deploy their applications.\n\nHere is a brief overview of the files in this folder:\n\n1. **Address.java**: This file contains the `Address` class, which represents an Ergo address. It provides methods for creating and validating addresses, as well as converting them to and from different formats (e.g., Base58, ErgoTree).\n\n   Example usage:\n   ```java\n   Address address = Address.fromBase58(\"9f4QF8AD1nQ3nJahQVkM6c5RqW5iH6G3tBmaJxU8CHutaHRdPzg\");\n   ErgoTree ergoTree = address.getErgoTree();\n   ```\n\n2. **BlockchainContext.java**: This file contains the `BlockchainContext` interface, which defines methods for interacting with the Ergo blockchain. It allows developers to access blockchain data, such as the current height, box values, and transaction data.\n\n   Example usage:\n   ```java\n   BlockchainContext context = ...;\n   long currentHeight = context.getHeight();\n   List<InputBox> boxes = context.getBoxesByIds(boxIds);\n   ```\n\n3. **ErgoToken.java**: This file contains the `ErgoToken` class, which represents an Ergo token. It provides methods for creating and manipulating tokens, as well as converting them to and from different formats (e.g., JSON, ErgoBox).\n\n   Example usage:\n   ```java\n   ErgoToken token = new ErgoToken(tokenId, tokenAmount);\n   long amount = token.getValue();\n   ```\n\n4. **InputBox.java**: This file contains the `InputBox` class, which represents an input box in an Ergo transaction. It provides methods for accessing box properties, such as the box value, tokens, and ErgoTree.\n\n   Example usage:\n   ```java\n   InputBox box = ...;\n   long boxValue = box.getValue();\n   List<ErgoToken> tokens = box.getTokens();\n   ```\n\n5. **SignedTransaction.java**: This file contains the `SignedTransaction` class, which represents a signed Ergo transaction. It provides methods for accessing transaction properties, such as the transaction id, inputs, and outputs.\n\n   Example usage:\n   ```java\n   SignedTransaction tx = ...;\n   String txId = tx.getId();\n   List<InputBox> inputs = tx.getInputs();\n   List<OutputBox> outputs = tx.getOutputs();\n   ```\n\nThese classes and interfaces work together to provide a high-level API for interacting with the Ergo blockchain. Developers can use them to create, sign, and submit transactions, as well as query the blockchain for relevant data. By using the Ergo Appkit library, developers can focus on building their applications without having to worry about the low-level details of the Ergo protocol.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/org/summary.md"}}],["312",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/lib-impl/src/main/java)\n\nThe `lib-impl/src/main/java/org/ergoplatform/appkit` folder contains the implementation of the Ergo Appkit library, which provides a set of tools and utilities for building Ergo applications. The library is designed to simplify the interaction with the Ergo blockchain and make it easier for developers to create, test, and deploy their applications.\n\nHere is a brief overview of the files in this folder:\n\n1. **Address.java**: This file contains the `Address` class, which represents an Ergo address. It provides methods for creating and validating addresses, as well as converting them to and from different formats (e.g., Base58, ErgoTree).\n\n   Example usage:\n   ```java\n   Address address = Address.fromBase58(\"9f4QF8AD1nQ3nJahQVkM6c5RqW5iH6G3tBmaJxU8CHutaHRdPzg\");\n   ErgoTree ergoTree = address.getErgoTree();\n   ```\n\n2. **BlockchainContext.java**: This file contains the `BlockchainContext` interface, which defines methods for interacting with the Ergo blockchain. It allows developers to access blockchain data, such as the current height, box values, and transaction data.\n\n   Example usage:\n   ```java\n   BlockchainContext context = ...;\n   long currentHeight = context.getHeight();\n   List<InputBox> boxes = context.getBoxesByIds(boxIds);\n   ```\n\n3. **ErgoToken.java**: This file contains the `ErgoToken` class, which represents an Ergo token. It provides methods for creating and manipulating tokens, as well as converting them to and from different formats (e.g., JSON, ErgoBox).\n\n   Example usage:\n   ```java\n   ErgoToken token = new ErgoToken(tokenId, tokenAmount);\n   long amount = token.getValue();\n   ```\n\n4. **InputBox.java**: This file contains the `InputBox` class, which represents an input box in an Ergo transaction. It provides methods for accessing box properties, such as the box value, tokens, and ErgoTree.\n\n   Example usage:\n   ```java\n   InputBox box = ...;\n   long boxValue = box.getValue();\n   List<ErgoToken> tokens = box.getTokens();\n   ```\n\n5. **SignedTransaction.java**: This file contains the `SignedTransaction` class, which represents a signed Ergo transaction. It provides methods for accessing transaction properties, such as the transaction id, inputs, and outputs.\n\n   Example usage:\n   ```java\n   SignedTransaction tx = ...;\n   String txId = tx.getId();\n   List<InputBox> inputs = tx.getInputs();\n   List<OutputBox> outputs = tx.getOutputs();\n   ```\n\nThese classes and interfaces work together to provide a high-level API for interacting with the Ergo blockchain. Developers can use them to create, sign, and submit transactions, as well as query the blockchain for relevant data. By using the Ergo Appkit library, developers can focus on building their applications without having to worry about the low-level details of the Ergo protocol.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/java/summary.md"}}],["313",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/lib-impl/src/main)\n\nThe `lib-impl/src/main/java/org/ergoplatform/appkit` folder contains the implementation of the Ergo Appkit library, which provides a set of tools and utilities for building Ergo applications. The library is designed to simplify the interaction with the Ergo blockchain and make it easier for developers to create, test, and deploy their applications.\n\nHere is a brief overview of the files in this folder:\n\n1. **Address.java**: This file contains the `Address` class, which represents an Ergo address. It provides methods for creating and validating addresses, as well as converting them to and from different formats (e.g., Base58, ErgoTree).\n\n   Example usage:\n   ```java\n   Address address = Address.fromBase58(\"9f4QF8AD1nQ3nJahQVkM6c5RqW5iH6G3tBmaJxU8CHutaHRdPzg\");\n   ErgoTree ergoTree = address.getErgoTree();\n   ```\n\n2. **BlockchainContext.java**: This file contains the `BlockchainContext` interface, which defines methods for interacting with the Ergo blockchain. It allows developers to access blockchain data, such as the current height, box values, and transaction data.\n\n   Example usage:\n   ```java\n   BlockchainContext context = ...;\n   long currentHeight = context.getHeight();\n   List<InputBox> boxes = context.getBoxesByIds(boxIds);\n   ```\n\n3. **ErgoToken.java**: This file contains the `ErgoToken` class, which represents an Ergo token. It provides methods for creating and manipulating tokens, as well as converting them to and from different formats (e.g., JSON, ErgoBox).\n\n   Example usage:\n   ```java\n   ErgoToken token = new ErgoToken(tokenId, tokenAmount);\n   long amount = token.getValue();\n   ```\n\n4. **InputBox.java**: This file contains the `InputBox` class, which represents an input box in an Ergo transaction. It provides methods for accessing box properties, such as the box value, tokens, and ErgoTree.\n\n   Example usage:\n   ```java\n   InputBox box = ...;\n   long boxValue = box.getValue();\n   List<ErgoToken> tokens = box.getTokens();\n   ```\n\n5. **SignedTransaction.java**: This file contains the `SignedTransaction` class, which represents a signed Ergo transaction. It provides methods for accessing transaction properties, such as the transaction id, inputs, and outputs.\n\n   Example usage:\n   ```java\n   SignedTransaction tx = ...;\n   String txId = tx.getId();\n   List<InputBox> inputs = tx.getInputs();\n   List<OutputBox> outputs = tx.getOutputs();\n   ```\n\nThese classes and interfaces work together to provide a high-level API for interacting with the Ergo blockchain. Developers can use them to create, sign, and submit transactions, as well as query the blockchain for relevant data. By using the Ergo Appkit library, developers can focus on building their applications without having to worry about the low-level details of the Ergo protocol.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/main/summary.md"}}],["314",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/lib-impl/src)\n\nThe `lib-impl/src/main/java/org/ergoplatform/appkit` folder contains the implementation of the Ergo Appkit library, which provides a set of tools and utilities for building Ergo applications. The library is designed to simplify the interaction with the Ergo blockchain and make it easier for developers to create, test, and deploy their applications.\n\nHere is a brief overview of the files in this folder:\n\n1. **Address.java**: This file contains the `Address` class, which represents an Ergo address. It provides methods for creating and validating addresses, as well as converting them to and from different formats (e.g., Base58, ErgoTree).\n\n   Example usage:\n   ```java\n   Address address = Address.fromBase58(\"9f4QF8AD1nQ3nJahQVkM6c5RqW5iH6G3tBmaJxU8CHutaHRdPzg\");\n   ErgoTree ergoTree = address.getErgoTree();\n   ```\n\n2. **BlockchainContext.java**: This file contains the `BlockchainContext` interface, which defines methods for interacting with the Ergo blockchain. It allows developers to access blockchain data, such as the current height, box values, and transaction data.\n\n   Example usage:\n   ```java\n   BlockchainContext context = ...;\n   long currentHeight = context.getHeight();\n   List<InputBox> boxes = context.getBoxesByIds(boxIds);\n   ```\n\n3. **ErgoToken.java**: This file contains the `ErgoToken` class, which represents an Ergo token. It provides methods for creating and manipulating tokens, as well as converting them to and from different formats (e.g., JSON, ErgoBox).\n\n   Example usage:\n   ```java\n   ErgoToken token = new ErgoToken(tokenId, tokenAmount);\n   long amount = token.getValue();\n   ```\n\n4. **InputBox.java**: This file contains the `InputBox` class, which represents an input box in an Ergo transaction. It provides methods for accessing box properties, such as the box value, tokens, and ErgoTree.\n\n   Example usage:\n   ```java\n   InputBox box = ...;\n   long boxValue = box.getValue();\n   List<ErgoToken> tokens = box.getTokens();\n   ```\n\n5. **SignedTransaction.java**: This file contains the `SignedTransaction` class, which represents a signed Ergo transaction. It provides methods for accessing transaction properties, such as the transaction id, inputs, and outputs.\n\n   Example usage:\n   ```java\n   SignedTransaction tx = ...;\n   String txId = tx.getId();\n   List<InputBox> inputs = tx.getInputs();\n   List<OutputBox> outputs = tx.getOutputs();\n   ```\n\nThese classes and interfaces work together to provide a high-level API for interacting with the Ergo blockchain. Developers can use them to create, sign, and submit transactions, as well as query the blockchain for relevant data. By using the Ergo Appkit library, developers can focus on building their applications without having to worry about the low-level details of the Ergo protocol.","metadata":{"source":".autodoc/docs/markdown/lib-impl/src/summary.md"}}],["315",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/lib-impl)\n\nThe `lib-impl/src/main/java/org/ergoplatform/appkit` folder contains the implementation of the Ergo Appkit library, which provides a set of tools and utilities for building Ergo applications. The library is designed to simplify the interaction with the Ergo blockchain and make it easier for developers to create, test, and deploy their applications.\n\nHere is a brief overview of the files in this folder:\n\n1. **Address.java**: This file contains the `Address` class, which represents an Ergo address. It provides methods for creating and validating addresses, as well as converting them to and from different formats (e.g., Base58, ErgoTree).\n\n   Example usage:\n   ```java\n   Address address = Address.fromBase58(\"9f4QF8AD1nQ3nJahQVkM6c5RqW5iH6G3tBmaJxU8CHutaHRdPzg\");\n   ErgoTree ergoTree = address.getErgoTree();\n   ```\n\n2. **BlockchainContext.java**: This file contains the `BlockchainContext` interface, which defines methods for interacting with the Ergo blockchain. It allows developers to access blockchain data, such as the current height, box values, and transaction data.\n\n   Example usage:\n   ```java\n   BlockchainContext context = ...;\n   long currentHeight = context.getHeight();\n   List<InputBox> boxes = context.getBoxesByIds(boxIds);\n   ```\n\n3. **ErgoToken.java**: This file contains the `ErgoToken` class, which represents an Ergo token. It provides methods for creating and manipulating tokens, as well as converting them to and from different formats (e.g., JSON, ErgoBox).\n\n   Example usage:\n   ```java\n   ErgoToken token = new ErgoToken(tokenId, tokenAmount);\n   long amount = token.getValue();\n   ```\n\n4. **InputBox.java**: This file contains the `InputBox` class, which represents an input box in an Ergo transaction. It provides methods for accessing box properties, such as the box value, tokens, and ErgoTree.\n\n   Example usage:\n   ```java\n   InputBox box = ...;\n   long boxValue = box.getValue();\n   List<ErgoToken> tokens = box.getTokens();\n   ```\n\n5. **SignedTransaction.java**: This file contains the `SignedTransaction` class, which represents a signed Ergo transaction. It provides methods for accessing transaction properties, such as the transaction id, inputs, and outputs.\n\n   Example usage:\n   ```java\n   SignedTransaction tx = ...;\n   String txId = tx.getId();\n   List<InputBox> inputs = tx.getInputs();\n   List<OutputBox> outputs = tx.getOutputs();\n   ```\n\nThese classes and interfaces work together to provide a high-level API for interacting with the Ergo blockchain. Developers can use them to create, sign, and submit transactions, as well as query the blockchain for relevant data. By using the Ergo Appkit library, developers can focus on building their applications without having to worry about the low-level details of the Ergo protocol.","metadata":{"source":".autodoc/docs/markdown/lib-impl/summary.md"}}],["316",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/src/main/resources/META-INF/native-image/jni-config.json)\n\nThe code above is a JSON object that represents an exception class and its constructor method. Specifically, it defines the `java.lang.InternalError` class and its constructor method with a single parameter of type `java.lang.String`. \n\nIn the context of the larger project, this code may be used as part of a configuration file or metadata for the project's error handling system. By defining the exception class and its constructor method in this way, the project can ensure that any instances of `java.lang.InternalError` are properly handled and logged with the appropriate message.\n\nFor example, if the project encounters an error that results in an `InternalError` being thrown, the code could catch the exception and log the error message using the constructor defined in this JSON object. This would ensure that the error message is consistent and easily identifiable in the project's logs.\n\nHere is an example of how this code could be used in Java:\n\n```java\ntry {\n  // some code that may throw an InternalError\n} catch (InternalError e) {\n  // log the error message using the defined constructor\n  String errorMessage = \"An internal error occurred: \" + e.getMessage();\n  Logger.log(new InternalError(errorMessage));\n}\n```\n\nOverall, this code serves as a way to define and standardize error handling for the `java.lang.InternalError` class in the larger project.\n## Questions: \n 1. **What is the purpose of this code?**\\\nThis code defines a JSON object that represents a Java `InternalError` class and its constructor method.\n\n2. **Why is the `parameterTypes` array only containing one element?**\\\nThe `parameterTypes` array specifies the types of the parameters for the constructor method. In this case, the `InternalError` constructor only takes one parameter of type `String`.\n\n3. **Is this code part of a larger project or module?**\\\nIt is unclear from this code snippet alone whether it is part of a larger project or module within the `ergo-appkit`. Further context is needed to determine this.","metadata":{"source":".autodoc/docs/markdown/src/main/resources/META-INF/native-image/jni-config.md"}}],["317",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/src/main/resources/META-INF/native-image/proxy-config.json)\n\nThe code provided is an empty list and does not perform any specific functionality. Therefore, it is difficult to provide a detailed technical explanation of what this code does. However, it is important to note that this file may be used as a placeholder for future code implementation in the ergo-appkit project.\n\nIn general, the ergo-appkit project is likely to be a software development kit (SDK) or a collection of tools and libraries that developers can use to build decentralized applications (dApps) on the Ergo blockchain. The purpose of this project is to simplify the development process and provide developers with the necessary tools to create secure and efficient dApps.\n\nIn the larger project, this file may be used as a starting point for implementing new features or functionality. For example, if a developer wants to add a new module to the ergo-appkit project, they can create a new file and add the necessary code to it. This file can then be imported into other parts of the project and used as needed.\n\nOverall, while this specific code does not perform any specific functionality, it is an important part of the ergo-appkit project as it provides a foundation for future code implementation. As the project evolves and new features are added, this file may be updated or replaced with new code to support the project's goals.\n## Questions: \n 1. What is the purpose of this file?\n   - It is impossible to determine the purpose of this file as it contains no code.\n\n2. Is this file supposed to be empty or is there missing code?\n   - It is unclear whether this file is supposed to be empty or if there is missing code. Further investigation or communication with the project team may be necessary.\n\n3. What is the context of this file within the overall ergo-appkit project?\n   - Without additional information, it is difficult to determine the context of this file within the overall ergo-appkit project. It may be necessary to review other files or documentation to gain a better understanding.","metadata":{"source":".autodoc/docs/markdown/src/main/resources/META-INF/native-image/proxy-config.md"}}],["318",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/src/main/resources/META-INF/native-image/reflect-config.json)\n\nThis code appears to be a list of classes and their associated fields and methods. The purpose of this code is likely to provide a reference for developers working on the ergo-appkit project to understand the available classes and their capabilities. \n\nThe classes listed include a mix of standard Java classes such as `java.lang.Throwable` and `java.util.Locale`, as well as classes specific to the ergo-appkit project such as `org.ergoplatform.appkit.NetworkType` and `org.ergoplatform.restapi.client.BlocksApi`. \n\nSome of the classes have associated fields, such as `org.ergoplatform.appkit.NetworkType` which has two fields `MAINNET` and `TESTNET`. Other classes have associated methods, such as `org.ergoplatform.restapi.client.BlocksApi` which has a method `getLastHeaders` that takes a `java.math.BigDecimal` parameter. \n\nOverall, this code provides a useful reference for developers working on the ergo-appkit project to understand the available classes and their associated fields and methods. It can be used to inform decisions about which classes to use and how to interact with them. \n\nExample usage of this code might include a developer looking to implement a feature that requires interacting with the blockchain, and using this code to identify the relevant classes and methods to use.\n## Questions: \n 1. What is the purpose of this file in the ergo-appkit project?\n- The code in this file appears to be a list of class names, fields, and methods. It is unclear what the purpose of this list is within the context of the ergo-appkit project.\n\n2. What are some of the classes and methods included in this file?\n- The file includes a variety of classes and methods from different packages, including com.google.common.util.concurrent, java.lang, org.ergoplatform.appkit, org.ergoplatform.restapi.client, sigmastate, and special.sigma. Some of the methods listed include getNodeInfo, sendTransaction, and walletUnspentBoxes.\n\n3. Is there any documentation or explanation provided for the classes and methods listed in this file?\n- No, there is no documentation or explanation provided for the classes and methods listed in this file. It is unclear why this list was created and what its intended use is within the ergo-appkit project.","metadata":{"source":".autodoc/docs/markdown/src/main/resources/META-INF/native-image/reflect-config.md"}}],["319",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/src/main/resources/META-INF/native-image/resource-config.json)\n\nThis code is a JSON object that defines a list of resources for the ergo-appkit project. The \"resources\" key contains an array of objects, each of which has a \"pattern\" key and a corresponding value. The \"pattern\" key specifies a file or directory pattern that matches the resources to be included in the project. \n\nFor example, the first object in the array specifies a pattern of \"reference.conf\", which means that any file with that name will be included in the project. The second object specifies a pattern of \"sun/net/idn/uidna.spp\", which means that any file located in the \"sun/net/idn\" directory with a name of \"uidna.spp\" will be included. The third object specifies a pattern of \"sun/text/resources/unorm.icu\", which means that any file located in the \"sun/text/resources\" directory with a name of \"unorm.icu\" will be included. Finally, the fourth object specifies a pattern of \"version.conf\", which means that any file with that name will be included in the project.\n\nThis code is used to specify the resources that are required for the ergo-appkit project to function properly. By including these resources in the project, the code can access them at runtime and use them as needed. For example, the \"reference.conf\" file may contain configuration settings for the project, while the \"unorm.icu\" file may contain Unicode normalization data that is used by the code.\n\nOverall, this code is a simple but important part of the ergo-appkit project, as it ensures that all necessary resources are included and available for the code to function properly.\n## Questions: \n 1. What is the purpose of this code block?\n   - This code block defines a list of resources with their file patterns.\n\n2. What is the significance of the file patterns in the resource list?\n   - The file patterns specify the files that should be included as resources in the project.\n\n3. Are there any other properties that can be defined for each resource in the list?\n   - It is unclear from this code block if there are any other properties that can be defined for each resource.","metadata":{"source":".autodoc/docs/markdown/src/main/resources/META-INF/native-image/resource-config.md"}}],["320",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/src/main/resources/META-INF/native-image/sigmastate/proxy-config.json)\n\nThe code provided is an empty list, and therefore does not have any high-level purpose or functionality. It is likely that this file is simply a placeholder or a starting point for future code development within the ergo-appkit project. \n\nWithout any actual code to analyze, it is difficult to provide specific examples of how this file may be used in the larger project. However, it is possible that this file could be used as a module or package within the project, and other files could import and utilize its contents. \n\nOverall, while this specific file may not have any practical use or functionality, it is important to have a clear and organized file structure within a project in order to facilitate efficient and effective development.\n## Questions: \n 1. What is the purpose of this file?\n   - It is impossible to determine the purpose of this file as it contains no code.\n\n2. Is this file supposed to be empty or is there missing code?\n   - It is unclear whether this file is supposed to be empty or if there is missing code. Further investigation or communication with the project team may be necessary.\n\n3. What is the context of this file within the overall ergo-appkit project?\n   - Without additional information, it is difficult to determine the context of this file within the overall ergo-appkit project. It may be necessary to review other files or documentation to gain a better understanding.","metadata":{"source":".autodoc/docs/markdown/src/main/resources/META-INF/native-image/sigmastate/proxy-config.md"}}],["321",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/src/main/resources/META-INF/native-image/sigmastate/reflect-config.json)\n\nThis code is a JSON configuration file that specifies a set of Scala classes and their methods to be exposed for use in the larger ergo-appkit project. The configuration file is organized as a list of objects, where each object represents a Scala class and its associated methods or constructors.\n\nFor example, the first object in the list represents the `scala.Some` class, and it specifies that all public constructors of this class should be exposed. Similarly, the `scala.collection.immutable.Vector` class is represented by an object that specifies the `iterator` method with no parameters should be exposed.\n\nThe configuration file also includes classes from the `sigmastate` package, which are related to the Ergo blockchain's cryptographic operations and smart contract language. For instance, the `sigmastate.AND` class is included with all its public constructors exposed.\n\nAdditionally, the file includes classes from the `special.collection` package, which are related to specialized collections and their operations. For example, the `special.collection.Coll` class is included with all its public methods exposed.\n\nHere's an example of how this configuration might be used in the larger project:\n\n```scala\nimport scala.collection.immutable.Vector\n\nval myVector = Vector(1, 2, 3)\nval iterator = myVector.iterator\nwhile (iterator.hasNext) {\n  println(iterator.next())\n}\n```\n\nIn this example, we import the `Vector` class from the `scala.collection.immutable` package, which is specified in the configuration file. We then create a new `Vector` instance, obtain an iterator using the exposed `iterator` method, and iterate through the elements of the vector, printing each one.\n## Questions: \n 1. **What is the purpose of this code?**\n\n   This code is a JSON representation of various Scala classes and their methods, constructors, and fields. It appears to be a part of a larger project called `ergo-appkit`, and this file might be used for code generation, documentation, or reflection purposes.\n\n2. **What are the main components of this code?**\n\n   The main components of this code are the JSON objects representing Scala classes. Each object has a `name` field indicating the fully qualified class name, and optional fields like `allPublicConstructors`, `allPublicMethods`, `allDeclaredMethods`, and `methods` that provide information about the constructors, methods, and fields of the class.\n\n3. **How are the classes and their methods organized in this code?**\n\n   The classes are organized as a JSON array, with each element being a JSON object representing a class. The methods of each class are represented as an array of JSON objects within the `methods` field of the class object. Each method object has a `name` field for the method name and a `parameterTypes` field containing an array of parameter types.","metadata":{"source":".autodoc/docs/markdown/src/main/resources/META-INF/native-image/sigmastate/reflect-config.md"}}],["322",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/src/main/resources/META-INF/native-image/sigmastate/resource-config.json)\n\nThe code above is a JSON object that defines a list of resources for the ergo-appkit project. The \"resources\" key contains an array of objects, each with a \"pattern\" key and a corresponding value. These patterns are used to specify the location of various resources that are needed by the project.\n\nThe first pattern specifies the location of a service provider file for the SLF4J logging framework. This file is used to configure the logging system for the project. The second pattern specifies the location of a library properties file, which contains information about the project's dependencies. The third and fourth patterns specify the locations of properties files for the Scalactic and ScalaTest libraries, respectively. These files contain localized messages that are used by the libraries.\n\nThe final pattern specifies the location of a class file for the ScalaTest library. This class is used to define test suites for the project.\n\nOverall, this code is used to specify the locations of various resources that are needed by the ergo-appkit project. These resources include configuration files, library properties files, and test suite definitions. By defining these resources in a centralized location, the project can easily access and use them as needed. \n\nExample usage:\n\nTo access the location of the SLF4J service provider file, the following code could be used:\n\n```\nString slf4jServiceProviderLocation = resources.get(0).get(\"pattern\");\n```\n\nThis would retrieve the first object in the \"resources\" array and then retrieve the value of the \"pattern\" key. The resulting string would be the location of the SLF4J service provider file.\n## Questions: \n 1. What is the purpose of this code?\n   - This code defines a list of resources for the ergo-appkit project, including files related to logging and testing.\n\n2. What is the format of the \"pattern\" values?\n   - The \"pattern\" values are strings that specify file paths or patterns to match against files in the project's resources.\n\n3. How are these resources used in the ergo-appkit project?\n   - Without more context, it's unclear how these resources are used in the project. However, it's likely that they are used for logging and testing purposes.","metadata":{"source":".autodoc/docs/markdown/src/main/resources/META-INF/native-image/sigmastate/resource-config.md"}}],["323",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/src/main/resources/META-INF/native-image/sigmastate)\n\nThe `.autodoc/docs/json/src/main/resources/META-INF/native-image/sigmastate` folder contains JSON configuration files that are crucial for the ergo-appkit project. These files define various resources, classes, and methods that are exposed and used throughout the project.\n\n`proxy-config.json` is an empty list, likely serving as a placeholder or starting point for future code development. Although it currently has no functionality, it is important to maintain a clear and organized file structure for efficient development.\n\n`reflect-config.json` is a JSON configuration file that specifies Scala classes and their methods to be exposed for use in the project. It includes classes from the `scala`, `sigmastate`, and `special.collection` packages. For example, the `scala.collection.immutable.Vector` class is represented with its `iterator` method exposed:\n\n```scala\nimport scala.collection.immutable.Vector\n\nval myVector = Vector(1, 2, 3)\nval iterator = myVector.iterator\nwhile (iterator.hasNext) {\n  println(iterator.next())\n}\n```\n\n`resource-config.json` defines a list of resources for the project, such as configuration files, library properties files, and test suite definitions. These resources are specified by patterns, which indicate their locations. For instance, to access the location of the SLF4J service provider file, the following code could be used:\n\n```java\nString slf4jServiceProviderLocation = resources.get(0).get(\"pattern\");\n```\n\nIn summary, this folder contains JSON configuration files that define resources, classes, and methods for the ergo-appkit project. These files are essential for organizing and accessing various components of the project, ensuring efficient development and usage.","metadata":{"source":".autodoc/docs/markdown/src/main/resources/META-INF/native-image/sigmastate/summary.md"}}],["324",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/src/main/resources/META-INF/native-image)\n\nThe `.autodoc/docs/json/src/main/resources/META-INF/native-image` folder contains JSON configuration files that are crucial for the ergo-appkit project. These files define various resources, classes, and methods that are exposed and used throughout the project.\n\n`jni-config.json` defines the `java.lang.InternalError` class and its constructor method with a single parameter of type `java.lang.String`. This configuration ensures that any instances of `java.lang.InternalError` are properly handled and logged with the appropriate message. For example:\n\n```java\ntry {\n  // some code that may throw an InternalError\n} catch (InternalError e) {\n  // log the error message using the defined constructor\n  String errorMessage = \"An internal error occurred: \" + e.getMessage();\n  Logger.log(new InternalError(errorMessage));\n}\n```\n\n`proxy-config.json` is an empty list, likely serving as a placeholder or starting point for future code development. Although it currently has no functionality, it is important to maintain a clear and organized file structure for efficient development.\n\n`reflect-config.json` is a JSON configuration file that specifies Java classes and their methods to be exposed for use in the project. It includes classes from the `java.lang`, `java.util`, and `org.ergoplatform` packages. For example, the `org.ergoplatform.restapi.client.BlocksApi` class is represented with its `getLastHeaders` method exposed:\n\n```java\nimport org.ergoplatform.restapi.client.BlocksApi;\n\nBlocksApi blocksApi = new BlocksApi();\nBigDecimal headersCount = new BigDecimal(10);\nList<BlockHeader> lastHeaders = blocksApi.getLastHeaders(headersCount);\n```\n\n`resource-config.json` defines a list of resources for the project, such as configuration files and library properties files. These resources are specified by patterns, which indicate their locations. For instance, to access the location of the `reference.conf` file, the following code could be used:\n\n```java\nString referenceConfLocation = resources.get(0).get(\"pattern\");\n```\n\nIn summary, this folder contains JSON configuration files that define resources, classes, and methods for the ergo-appkit project. These files are essential for organizing and accessing various components of the project, ensuring efficient development and usage.","metadata":{"source":".autodoc/docs/markdown/src/main/resources/META-INF/native-image/summary.md"}}],["325",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/src/main/resources/META-INF)\n\nThe `.autodoc/docs/json/src/main/resources/META-INF` folder contains JSON configuration files that are crucial for the ergo-appkit project. These files define various resources, classes, and methods that are exposed and used throughout the project.\n\nThe `native-image` subfolder contains the following JSON configuration files:\n\n- `jni-config.json`: This file defines the `java.lang.InternalError` class and its constructor method with a single parameter of type `java.lang.String`. This configuration ensures that any instances of `java.lang.InternalError` are properly handled and logged with the appropriate message. For example:\n\n```java\ntry {\n  // some code that may throw an InternalError\n} catch (InternalError e) {\n  // log the error message using the defined constructor\n  String errorMessage = \"An internal error occurred: \" + e.getMessage();\n  Logger.log(new InternalError(errorMessage));\n}\n```\n\n- `proxy-config.json`: This file is an empty list, likely serving as a placeholder or starting point for future code development. Although it currently has no functionality, it is important to maintain a clear and organized file structure for efficient development.\n\n- `reflect-config.json`: This JSON configuration file specifies Java classes and their methods to be exposed for use in the project. It includes classes from the `java.lang`, `java.util`, and `org.ergoplatform` packages. For example, the `org.ergoplatform.restapi.client.BlocksApi` class is represented with its `getLastHeaders` method exposed:\n\n```java\nimport org.ergoplatform.restapi.client.BlocksApi;\n\nBlocksApi blocksApi = new BlocksApi();\nBigDecimal headersCount = new BigDecimal(10);\nList<BlockHeader> lastHeaders = blocksApi.getLastHeaders(headersCount);\n```\n\n- `resource-config.json`: This file defines a list of resources for the project, such as configuration files and library properties files. These resources are specified by patterns, which indicate their locations. For instance, to access the location of the `reference.conf` file, the following code could be used:\n\n```java\nString referenceConfLocation = resources.get(0).get(\"pattern\");\n```\n\nIn summary, this folder contains JSON configuration files that define resources, classes, and methods for the ergo-appkit project. These files are essential for organizing and accessing various components of the project, ensuring efficient development and usage.","metadata":{"source":".autodoc/docs/markdown/src/main/resources/META-INF/summary.md"}}],["326",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/src/main/resources)\n\nThe `.autodoc/docs/json/src/main/resources` folder contains JSON configuration files that are crucial for the ergo-appkit project. These files define various resources, classes, and methods that are exposed and used throughout the project. The folder has a subfolder named `META-INF`, which contains another subfolder called `native-image`.\n\nThe `native-image` subfolder contains the following JSON configuration files:\n\n- `jni-config.json`: This file defines the `java.lang.InternalError` class and its constructor method with a single parameter of type `java.lang.String`. This configuration ensures that any instances of `java.lang.InternalError` are properly handled and logged with the appropriate message. For example:\n\n```java\ntry {\n  // some code that may throw an InternalError\n} catch (InternalError e) {\n  // log the error message using the defined constructor\n  String errorMessage = \"An internal error occurred: \" + e.getMessage();\n  Logger.log(new InternalError(errorMessage));\n}\n```\n\n- `proxy-config.json`: This file is an empty list, likely serving as a placeholder or starting point for future code development. Although it currently has no functionality, it is important to maintain a clear and organized file structure for efficient development.\n\n- `reflect-config.json`: This JSON configuration file specifies Java classes and their methods to be exposed for use in the project. It includes classes from the `java.lang`, `java.util`, and `org.ergoplatform` packages. For example, the `org.ergoplatform.restapi.client.BlocksApi` class is represented with its `getLastHeaders` method exposed:\n\n```java\nimport org.ergoplatform.restapi.client.BlocksApi;\n\nBlocksApi blocksApi = new BlocksApi();\nBigDecimal headersCount = new BigDecimal(10);\nList<BlockHeader> lastHeaders = blocksApi.getLastHeaders(headersCount);\n```\n\n- `resource-config.json`: This file defines a list of resources for the project, such as configuration files and library properties files. These resources are specified by patterns, which indicate their locations. For instance, to access the location of the `reference.conf` file, the following code could be used:\n\n```java\nString referenceConfLocation = resources.get(0).get(\"pattern\");\n```\n\nIn summary, this folder contains JSON configuration files that define resources, classes, and methods for the ergo-appkit project. These files are essential for organizing and accessing various components of the project, ensuring efficient development and usage.","metadata":{"source":".autodoc/docs/markdown/src/main/resources/summary.md"}}],["327",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/src/main)\n\nThe `.autodoc/docs/json/src/main/resources` folder plays a crucial role in the ergo-appkit project by providing JSON configuration files that define various resources, classes, and methods used throughout the project. These files are essential for organizing and accessing different components of the project, ensuring efficient development and usage.\n\nThe `native-image` subfolder contains several JSON configuration files:\n\n1. `jni-config.json`: This file defines the `java.lang.InternalError` class and its constructor method with a single parameter of type `java.lang.String`. This configuration ensures that any instances of `java.lang.InternalError` are properly handled and logged with the appropriate message. For example:\n\n```java\ntry {\n  // some code that may throw an InternalError\n} catch (InternalError e) {\n  // log the error message using the defined constructor\n  String errorMessage = \"An internal error occurred: \" + e.getMessage();\n  Logger.log(new InternalError(errorMessage));\n}\n```\n\n2. `proxy-config.json`: This file is an empty list, likely serving as a placeholder or starting point for future code development. Although it currently has no functionality, it is important to maintain a clear and organized file structure for efficient development.\n\n3. `reflect-config.json`: This JSON configuration file specifies Java classes and their methods to be exposed for use in the project. It includes classes from the `java.lang`, `java.util`, and `org.ergoplatform` packages. For example, the `org.ergoplatform.restapi.client.BlocksApi` class is represented with its `getLastHeaders` method exposed:\n\n```java\nimport org.ergoplatform.restapi.client.BlocksApi;\n\nBlocksApi blocksApi = new BlocksApi();\nBigDecimal headersCount = new BigDecimal(10);\nList<BlockHeader> lastHeaders = blocksApi.getLastHeaders(headersCount);\n```\n\n4. `resource-config.json`: This file defines a list of resources for the project, such as configuration files and library properties files. These resources are specified by patterns, which indicate their locations. For instance, to access the location of the `reference.conf` file, the following code could be used:\n\n```java\nString referenceConfLocation = resources.get(0).get(\"pattern\");\n```\n\nIn summary, the `.autodoc/docs/json/src/main/resources` folder contains JSON configuration files that are vital for the ergo-appkit project. These files help in defining resources, classes, and methods, which are essential for organizing and accessing various components of the project, ensuring efficient development and usage.","metadata":{"source":".autodoc/docs/markdown/src/main/summary.md"}}],["328",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/src)\n\nThe `.autodoc/docs/json/src/main/resources` folder is crucial for the ergo-appkit project as it contains JSON configuration files that define various resources, classes, and methods used throughout the project. These files are essential for organizing and accessing different components of the project, ensuring efficient development and usage.\n\nThe `native-image` subfolder contains several JSON configuration files:\n\n1. `jni-config.json`: This file defines the `java.lang.InternalError` class and its constructor method with a single parameter of type `java.lang.String`. This configuration ensures that any instances of `java.lang.InternalError` are properly handled and logged with the appropriate message. For example:\n\n```java\ntry {\n  // some code that may throw an InternalError\n} catch (InternalError e) {\n  // log the error message using the defined constructor\n  String errorMessage = \"An internal error occurred: \" + e.getMessage();\n  Logger.log(new InternalError(errorMessage));\n}\n```\n\n2. `proxy-config.json`: This file is an empty list, likely serving as a placeholder or starting point for future code development. Although it currently has no functionality, it is important to maintain a clear and organized file structure for efficient development.\n\n3. `reflect-config.json`: This JSON configuration file specifies Java classes and their methods to be exposed for use in the project. It includes classes from the `java.lang`, `java.util`, and `org.ergoplatform` packages. For example, the `org.ergoplatform.restapi.client.BlocksApi` class is represented with its `getLastHeaders` method exposed:\n\n```java\nimport org.ergoplatform.restapi.client.BlocksApi;\n\nBlocksApi blocksApi = new BlocksApi();\nBigDecimal headersCount = new BigDecimal(10);\nList<BlockHeader> lastHeaders = blocksApi.getLastHeaders(headersCount);\n```\n\n4. `resource-config.json`: This file defines a list of resources for the project, such as configuration files and library properties files. These resources are specified by patterns, which indicate their locations. For instance, to access the location of the `reference.conf` file, the following code could be used:\n\n```java\nString referenceConfLocation = resources.get(0).get(\"pattern\");\n```\n\nIn summary, the `.autodoc/docs/json/src/main/resources` folder contains JSON configuration files that are vital for the ergo-appkit project. These files help in defining resources, classes, and methods, which are essential for organizing and accessing various components of the project, ensuring efficient development and usage.","metadata":{"source":".autodoc/docs/markdown/src/summary.md"}}],["329",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/storage/E1.json)\n\nThe code provided is a JSON object that contains encryption-related information. Specifically, it contains the ciphertext, salt, initialization vector (IV), authentication tag, and cipher parameters. This information is likely used in the larger project to encrypt and decrypt sensitive data.\n\nThe ciphertext is the encrypted version of the original plaintext. The salt is a random value that is used to prevent attackers from precomputing the key needed to decrypt the ciphertext. The IV is another random value that is used to ensure that the same plaintext does not always result in the same ciphertext. The authentication tag is used to ensure that the ciphertext has not been tampered with during transmission or storage.\n\nThe cipher parameters provide additional information about the encryption process. The \"prf\" parameter specifies the pseudorandom function used to derive the key from the password. The \"c\" parameter specifies the number of iterations used in the key derivation process. The \"dkLen\" parameter specifies the length of the derived key.\n\nTo use this information to decrypt the ciphertext, the project likely uses a cryptographic library that supports the same encryption algorithm and mode as the one used to encrypt the data. The library would use the salt and password to derive the key, and then use the key, IV, and ciphertext to decrypt the data. The library would also verify the authentication tag to ensure that the data has not been tampered with.\n\nHere is an example of how this information might be used in Java using the Bouncy Castle cryptographic library:\n\n```java\nimport org.bouncycastle.crypto.digests.SHA256Digest;\nimport org.bouncycastle.crypto.generators.PKCS5S2ParametersGenerator;\nimport org.bouncycastle.crypto.params.KeyParameter;\nimport org.bouncycastle.crypto.params.ParametersWithIV;\nimport org.bouncycastle.crypto.modes.GCMBlockCipher;\nimport org.bouncycastle.crypto.params.AEADParameters;\nimport org.bouncycastle.util.encoders.Hex;\n\n// Parse the JSON object\nString cipherText = \"3d5fdd90a549c461bf69b8d6520098c2cc4e88bd941b89fe6970707057833c34703bc14b451341adbe4f4f0ac384cdd3d238f6dc32a9c570ec9bfa8d612d7dc7\";\nString salt = \"e4ebbb1b8c00c2e93a0a4ff9ae97ab0302f16c6c6d3a78af8a5de2d0617ac166\";\nString iv = \"18ee1e68802d4abff539aeeb\";\nString authTag = \"7485ded5f1305a0f9b60b4674cc1fda9\";\nint c = 128000;\nint dkLen = 256;\n\n// Derive the key from the password and salt\nPKCS5S2ParametersGenerator generator = new PKCS5S2ParametersGenerator(new SHA256Digest());\ngenerator.init(\"password\".getBytes(), Hex.decode(salt), c);\nKeyParameter key = (KeyParameter)generator.generateDerivedParameters(dkLen);\n\n// Decrypt the ciphertext\nGCMBlockCipher cipher = new GCMBlockCipher(new org.bouncycastle.crypto.engines.AESFastEngine());\nAEADParameters params = new AEADParameters(key, 128, Hex.decode(iv), Hex.decode(authTag));\ncipher.init(false, params);\nbyte[] ciphertext = Hex.decode(cipherText);\nbyte[] plaintext = new byte[cipher.getOutputSize(ciphertext.length)];\nint len = cipher.processBytes(ciphertext, 0, ciphertext.length, plaintext, 0);\nlen += cipher.doFinal(plaintext, len);\nSystem.out.println(new String(plaintext, 0, len));\n```\n## Questions: \n 1. What type of encryption is being used in this code?\n- The code is using an encryption algorithm that is not specified in the given code snippet.\n\n2. What is the purpose of the salt and iv values?\n- The salt and iv values are used to add randomness to the encryption process, making it more difficult to crack the encryption.\n\n3. What is the significance of the authTag value?\n- The authTag value is used to verify the integrity of the encrypted data, ensuring that it has not been tampered with during transmission or storage.","metadata":{"source":".autodoc/docs/markdown/storage/E1.md"}}],["330",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/storage/E2.json)\n\nThe code provided is a JSON object that contains encrypted data and the parameters used to encrypt it. The purpose of this code is to provide a secure way to store and transmit sensitive information within the larger ergo-appkit project.\n\nThe `cipherText` field contains the encrypted data, which is the result of applying an encryption algorithm to the original plaintext. The `salt` field is a random value used to add complexity to the encryption process, making it harder to crack. The `iv` field is the initialization vector, which is used to ensure that the same plaintext does not result in the same ciphertext. The `authTag` field is the authentication tag, which is used to verify the integrity of the encrypted data.\n\nThe `cipherParams` field contains the parameters used to encrypt the data. The `prf` field specifies the pseudorandom function used to derive the encryption key from the password. The `c` field specifies the number of iterations used in the key derivation process, which is a measure of the computational effort required to derive the key. The `dkLen` field specifies the length of the derived key.\n\nThis code can be used in the larger ergo-appkit project to securely store and transmit sensitive information, such as user credentials or financial data. The encrypted data can be decrypted using the same parameters used to encrypt it, which are stored alongside the ciphertext. Here is an example of how this code could be used in the project:\n\n```python\nimport json\nfrom cryptography.hazmat.primitives.ciphers.aead import AESGCM\n\n# Load the encrypted data and parameters from a file\nwith open('encrypted_data.json', 'r') as f:\n    data = json.load(f)\n\n# Derive the encryption key from a password using the specified parameters\nkdf = AESGCM.algorithm.key_derivation_function\nkey = kdf(data['cipherParams']['prf'], password.encode(), data['salt'], data['cipherParams']['c'])\n\n# Decrypt the ciphertext using the derived key and other parameters\ncipher = AESGCM(key)\nplaintext = cipher.decrypt(data['iv'].encode(), data['cipherText'].encode(), data['authTag'].encode())\n\n# Use the decrypted data in the application\nprint(plaintext.decode())\n```\n## Questions: \n 1. What type of encryption is being used in this code?\n- The code is using an encryption algorithm that is not specified in the given code snippet.\n\n2. What is the purpose of the salt and iv values?\n- The salt and iv values are used to add randomness to the encryption process, making it more difficult for attackers to decrypt the data.\n\n3. What is the significance of the authTag value?\n- The authTag value is used to verify the integrity of the encrypted data, ensuring that it has not been tampered with during transmission or storage.","metadata":{"source":".autodoc/docs/markdown/storage/E2.md"}}],["331",{"pageContent":"[View code on GitHub](https://github.com/ergoplatform/ergo-appkit/.autodoc/docs/json/storage)\n\nThe `.autodoc/docs/json/storage` folder contains JSON files that store encrypted data and encryption-related information for the ergo-appkit project. This secure storage and transmission of sensitive information, such as user credentials or financial data, is crucial for the project's security.\n\nThe JSON files (E1.json and E2.json) contain fields like `cipherText`, `salt`, `iv`, and `authTag`, which store the encrypted data, salt, initialization vector, and authentication tag, respectively. These fields are essential for the encryption and decryption process. The `cipherParams` field contains additional encryption parameters, such as the pseudorandom function (`prf`), the number of iterations (`c`), and the derived key length (`dkLen`).\n\nTo decrypt the data, the project would use a cryptographic library that supports the same encryption algorithm and mode as the one used to encrypt the data. The library would use the salt and password to derive the key, and then use the key, IV, and ciphertext to decrypt the data. The library would also verify the authentication tag to ensure that the data has not been tampered with.\n\nHere's an example of how the JSON data might be used in Java using the Bouncy Castle cryptographic library:\n\n```java\n// ... (Parsing the JSON object and deriving the key from the password and salt)\n\n// Decrypt the ciphertext\nGCMBlockCipher cipher = new GCMBlockCipher(new org.bouncycastle.crypto.engines.AESFastEngine());\nAEADParameters params = new AEADParameters(key, 128, Hex.decode(iv), Hex.decode(authTag));\ncipher.init(false, params);\nbyte[] ciphertext = Hex.decode(cipherText);\nbyte[] plaintext = new byte[cipher.getOutputSize(ciphertext.length)];\nint len = cipher.processBytes(ciphertext, 0, ciphertext.length, plaintext, 0);\nlen += cipher.doFinal(plaintext, len);\nSystem.out.println(new String(plaintext, 0, len));\n```\n\nAnd here's an example of how the JSON data might be used in Python using the cryptography library:\n\n```python\n# ... (Loading the encrypted data and parameters from a file and deriving the encryption key)\n\n# Decrypt the ciphertext using the derived key and other parameters\ncipher = AESGCM(key)\nplaintext = cipher.decrypt(data['iv'].encode(), data['cipherText'].encode(), data['authTag'].encode())\n\n# Use the decrypted data in the application\nprint(plaintext.decode())\n```\n\nIn summary, the `.autodoc/docs/json/storage` folder plays a vital role in the ergo-appkit project by providing a secure way to store and transmit sensitive information. The JSON files contain encrypted data and encryption parameters, which can be used in conjunction with cryptographic libraries to decrypt the data and ensure its integrity.","metadata":{"source":".autodoc/docs/markdown/storage/summary.md"}}]]